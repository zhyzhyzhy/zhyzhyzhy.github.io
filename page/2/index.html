<!DOCTYPE html>
<html >
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="zhy" />


    
    


<meta property="og:type" content="website">
<meta property="og:title" content="LoveZhy">
<meta property="og:url" content="http://zhyzhyzhy.github.io/page/2/index.html">
<meta property="og:site_name" content="LoveZhy">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LoveZhy">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="LoveZhy" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>LoveZhy</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: undefined
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">zhy</a></h1>
        </hgroup>

        

        


        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:zhuyichen1017@gmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/zhyzhyzhy" title="GitHub"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                
                

                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">江湖里卧虎，人心里藏龙</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">zhy</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">zhy</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:zhuyichen1017@gmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/zhyzhyzhy" title="GitHub"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-brpc-doc笔记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/04/11/brpc-doc笔记/" class="article-date">
      <time datetime="2018-04-10T16:00:00.000Z" itemprop="datePublished">2018-04-11</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/11/brpc-doc笔记/">brpc-doc笔记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="原子指令"><a href="#原子指令" class="headerlink" title="原子指令"></a>原子指令</h2><p>在涉及到多线程时一般会用到锁。</p>
<p>但是重量级锁带来的race condition又会大量的消耗性能。</p>
<p>于是有了乐观锁，典型的就是借助原子指令，CAS来进行操作。这个还依赖的是硬件的发展。</p>
<p>但是原子指令又会带来ABA问题和memory face问题。</p>
<p>如果只是简单的变值的ABA其实是没什么问题的，但是链表的ABA问题就大了。</p>
<p><a href="https://www.zhihu.com/question/23281499" target="_blank" rel="noopener">ABA</a></p>
<p>Memory face之前没有了解过，看了看是内存屏障的意思。</p>
<p>有点像volatile的禁止指令局部指令重排序的样子。</p>
<p><a href="https://en.wikipedia.org/wiki/Memory_barrier" target="_blank" rel="noopener">memory face</a></p>
<h2 id="Cacheline"><a href="#Cacheline" class="headerlink" title="Cacheline"></a>Cacheline</h2><p>Cache Entry </p>
<blockquote>
<p>Data is transferred between memory and cache in blocks of fixed size, called <em>cache lines</em> or <em>cache blocks</em>. When a cache line is copied from memory into the cache, a cache entry is created. The cache entry will include the copied data as well as the requested memory location (called a tag).</p>
</blockquote>
<p><br></p>
<blockquote>
<p>When the processor needs to read or write a location in main memory, it first checks for a corresponding entry in the cache. The cache checks for the contents of the requested memory location in any cache lines that might contain that address. If the processor finds that the memory location is in the cache, a cache hit has occurred. However, if the processor does not find the memory location in the cache, a cache miss has occurred. In the case of a cache hit, the processor immediately reads or writes the data in the cache line. For a cache miss, the cache allocates a new entry and copies data from main memory, then the request is fulfilled from the contents of the cache.</p>
<p>​                                                                                                                                                            — wiki</p>
</blockquote>
<p>这里涉及到修改common memory让其他cpu的cache line中的值失效的问题。</p>
<blockquote>
<p>当另一个核心读或写同一处内存时，它得确认看到其他核心中对应的cacheline。对于软件来说，这个过程是原子的，不能在中间穿插其他代码，只能等待CPU完成<a href="https://en.wikipedia.org/wiki/Cache_coherence" target="_blank" rel="noopener">一致性同步</a>，这个复杂的硬件算法使得原子操作会变得很慢，在E5-2620上竞争激烈时fetch_add会耗费700纳秒左右。</p>
<p>访问被多个线程频繁共享的内存往往是比较慢的。</p>
</blockquote>
<p><br> </p>
<blockquote>
<p>要提高性能，就要避免让CPU频繁同步cacheline。这不单和原子指令本身的性能有关，还会影响到程序的整体性能。最有效的解决方法很直白：<strong>尽量避免共享</strong>。</p>
</blockquote>
<p><br> </p>
<blockquote>
<p>一个依赖全局多生产者多消费者队列(MPMC)的程序难有很好的多核扩展性，因为这个队列的极限吞吐取决于同步cache的延时，而不是核心的个数。最好是用多个SPMC或多个MPSC队列，甚至多个SPSC队列代替，在源头就规避掉竞争。</p>
</blockquote>
<p><br></p>
<blockquote>
<p> 另一个例子是计数器，如果所有线程都频繁修改一个计数器，性能就会很差，原因同样在于不同的核心在不停地同步同一个cacheline。如果这个计数器只是用作打打日志之类的，那我们完全可以让每个线程修改thread-local变量，在需要时再合并所有线程中的值，性能可能有几十倍的差别</p>
</blockquote>
<p><br></p>
<h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2><p>之前感觉在JMM中理解过类似的。</p>
<p><a href="https://kb.cnblogs.com/page/504824/" target="_blank" rel="noopener">缓存一致性</a></p>
<p>重点还是在多核心的pc中，每个核心都有自己的一级或者二级的缓存。</p>
<p>然后如果一个核去修改主存中的值，如果其他的核没有收到信号，那么可能会导致并发问题。</p>
<p>这个问题的解决就是缓存一致性，从文章里我们可以看到其实现代的cpu已经自带的缓存一致性。</p>
<p>那么问题来了，那为什么volatile还要发明出来。</p>
<p>cpu不直接和主存通信，那么修改了变量之后，什么时候把修改过得值写到主存中呢？</p>
<p>一般有两种方式</p>
<ul>
<li><p>直写</p>
<blockquote>
<p>我们透过本级缓存，直接把数据写到下一级缓存（或直接到内存）中，如果对应的段被缓存了，我们同时更新缓存中的内容（甚至直接丢弃）</p>
</blockquote>
</li>
<li><p>回写</p>
<blockquote>
<p><strong>回写定律</strong>：当所有的脏段被回写后，任意级别缓存中的缓存段的内容，等同于它对应的内存中的内容。</p>
<p>换句话说，回写模式的定律中，我们去掉了“在任意时刻”这个修饰语</p>
</blockquote>
</li>
</ul>
<p><br><br>如果都是直写，那么当然没什么问题，但是如果出现回写，数据写回不及时，在并发情况下就会出问题。</p>
<p><br><br>那么<code>volatile</code>的增强写语义就很好理解了。</p>
<p>那么增强的读语义呢？</p>
<p>这个我还是觉得有点奇怪的</p>
<p>首先读写主存是独占的，一个核写了之后，因为缓存一致性的存在，那么必然会导致其他核的缓存失效。</p>
<p>那么这时候就只能去读主存中的值了。</p>
<p>所以<code>volatile</code>的读语义其实并没有被<code>Jvm</code>增强，这是硬件所必然的结果。</p>
<p>那么另外一个经典的<code>volatile</code>修饰<code>boolean</code>变量，如果不修饰，另外一个线程可能永远读不到修改后的值的问题。</p>
<p>再仔细想想的话，真的是没读到吗，肯定是读到了，因为缓存一致性的存在，那么那个线程中的值肯定是修改之后的，但是为什么表现的还是没读到的样子呢，那是指令重排序的问题。</p>
<p>所以<code>JSR133</code>增强了<code>volatile</code>，就是在指令重排序上。</p>
<p><br><br></p>
<h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><blockquote>
<p><strong>重排指令</strong>导致了读写顺序的变化。只要没有依赖，代码中在后面的指令就可能跑到前面去</p>
<p><a href="http://preshing.com/20120625/memory-ordering-at-compile-time/" target="_blank" rel="noopener">编译器</a>和<a href="https://en.wikipedia.org/wiki/Out-of-order_execution" target="_blank" rel="noopener">CPU</a>都会这么做。</p>
<p>这么做的动机非常自然，CPU要尽量塞满每个cycle，在单位时间内运行尽量多的指令。</p>
<p>如上节中提到的，访存指令在等待cacheline同步时要花费数百纳秒，最高效地自然是同时同步多个cacheline，而不是一个个做。</p>
<p>一个线程在代码中对多个变量的依次修改，可能会以不同的次序同步到另一个线程所在的核心上。</p>
<p>不同线程对数据的需求不同，按需同步也会导致cacheline的读序和写序不同。</p>
</blockquote>
<p>简单说就是为了结果指令重排序带来的并发问题。</p>
<p><code>Java</code>内存模型中引入了<code>happens-before原则</code>和<code>volatile</code>来解决。</p>
<p><br><br></p>
<h2 id="wait-free-amp-lock-free"><a href="#wait-free-amp-lock-free" class="headerlink" title="wait-free &amp; lock-free"></a>wait-free &amp; lock-free</h2><blockquote>
<p>原子指令能为我们的服务赋予两个重要属性：<a href="http://en.wikipedia.org/wiki/Non-blocking_algorithm#Wait-freedom" target="_blank" rel="noopener">wait-free</a>和<a href="http://en.wikipedia.org/wiki/Non-blocking_algorithm#Lock-freedom" target="_blank" rel="noopener">lock-free</a>。</p>
<p>前者指不管OS如何调度线程，每个线程都始终在做有用的事；</p>
<p>后者比前者弱一些，指不管OS如何调度线程，至少有一个线程在做有用的事。</p>
</blockquote>
<p><br></p>
<blockquote>
<p>如果我们的服务中使用了锁，那么OS可能把一个刚获得锁的线程切换出去，这时候所有依赖这个锁的线程都在等待，而没有做有用的事，所以用了锁就不是lock-free，更不会是wait-free。</p>
<p>为了确保一件事情总在确定时间内完成，实时系统的关键代码至少是lock-free的。</p>
</blockquote>
<p><br></p>
<blockquote>
<p>在百度广泛又多样的在线服务中，对时效性也有着严苛的要求，如果RPC中最关键的部分满足wait-free或lock-free，就可以提供更稳定的服务质量。事实上，brpc中的读写都是wait-free的。</p>
<p>值得提醒的是，常见想法是lock-free或wait-free的算法会更快，但事实可能相反，因为：</p>
<p>lock-free和wait-free必须处理更多更复杂的race condition和ABA problem，完成相同目的的代码比用锁更复杂。代码越多，耗时就越长。<br>使用mutex的算法变相带“后退”效果。后退(backoff)指出现竞争时尝试另一个途径以临时避免竞争，mutex出现竞争时会使调用者睡眠，使拿到锁的那个线程可以很快地独占完成一系列流程，总体吞吐可能反而高了。</p>
<p>mutex导致低性能往往是因为临界区过大（限制了并发度），或竞争过于激烈（上下文切换开销变得突出）。</p>
<p>lock-free/wait-free算法的价值在于其保证了一个或所有线程始终在做有用的事，而不是绝对的高性能。</p>
<p>但在一种情况下lock-free和wait-free算法的性能多半更高：就是算法本身可以用少量原子指令实现。实现锁也是要用原子指令的，当算法本身用一两条指令就能完成的时候，相比额外用锁肯定是更快了。</p>
</blockquote>
<p>就是说其实CAS如果使用不当，并不比同步加锁来的性能更高。</p>
<p>但是<code>wait-free</code>则是很有必要的。</p>
<h2 id="雪崩"><a href="#雪崩" class="headerlink" title="雪崩"></a>雪崩</h2><blockquote>
<p>“雪崩”指的是访问服务集群时绝大部分请求都超时，且在流量减少时仍无法恢复的现象。</p>
</blockquote>
<p><br></p>
<blockquote>
<p>当流量超出服务的最大qps时，服务将无法正常服务；当流量恢复正常时（小于服务的处理能力），积压的请求会被处理，虽然其中很大一部分可能会因为处理的不及时而超时，但服务本身一般还是会恢复正常的。这就相当于一个水池有一个入水口和一个出水口，如果入水量大于出水量，水池子终将盛满，多出的水会溢出来。但如果入水量降到出水量之下，一段时间后水池总会排空。雪崩并不是单一服务能产生的。</p>
</blockquote>
<p><br></p>
<blockquote>
<p>如果一个请求经过两个服务，情况就有所不同了。比如请求访问A服务，A服务又访问了B服务。当B被打满时，A处的client会大量超时，如果A处的client在等待B返回时也阻塞了A的服务线程（常见），且使用了固定个数的线程池（常见），那么A处的最大qps就从<strong>线程数 / 平均延时</strong>，降到了<strong>线程数 / 超时</strong>。由于超时往往是平均延时的3~4倍，A处的最大qps会相应地下降3~4倍，从而产生比B处更激烈的拥塞。如果A还有类似的上游，拥塞会继续传递上去。但这个过程还是可恢复的。B处的流量终究由最前端的流量触发，只要最前端的流量回归正常，B处的流量总会慢慢降下来直到能正常回复大多数请求，从而让A恢复正常。</p>
</blockquote>
<p><br></p>
<blockquote>
<p>但有两个例外：</p>
<ol>
<li>A可能对B发起了过于频繁的基于超时的重试。这不仅会让A的最大qps降到<strong>线程数 / 超时</strong>，还会让B处的qps翻<strong>重试次数</strong>倍。这就可能陷入恶性循环了：只要<strong>线程数 / 超时 * 重试次数</strong>大于B的最大qps<strong>，</strong>B就无法恢复 -&gt; A处的client会继续超时 -&gt; A继续重试 -&gt; B继续无法恢复。</li>
<li>A或B没有限制某个缓冲或队列的长度，或限制过于宽松。拥塞请求会大量地积压在那里，要恢复就得全部处理完，时间可能长得无法接受。由于有限长的缓冲或队列需要在填满时解决等待、唤醒等问题，有时为了简单，代码可能会假定缓冲或队列不会满，这就埋下了种子。即使队列是有限长的，恢复时间也可能很长，因为清空队列的过程是个追赶问题，排空的时间取决于<strong>积压的请求数 / (最大qps - 当前qps)</strong>，如果当前qps和最大qps差的不多，积压的请求又比较多，那排空时间就遥遥无期了。</li>
</ol>
</blockquote>
<p>然后我们知道，处理雪崩问题，需要正确的处理超时重试和服务的等待队列问题。</p>
<blockquote>
<p>了解这些因素后可以更好的理解brpc中相关的设计。</p>
<ol>
<li>拥塞时A服务最大qps的跳变是因为线程个数是<strong>硬限</strong>，单个请求的处理时间很大程度上决定了最大qps。而brpc server端默认在bthread中处理请求，个数是软限，单个请求超时只是阻塞所在的bthread，并不会影响为新请求建立新的bthread。brpc也提供了完整的异步接口，让用户可以进一步提高io-bound服务的并发度，降低服务被打满的可能性。</li>
<li>brpc中<a href="client.md#重试">重试</a>默认只在连接出错时发起，避免了流量放大，这是比较有效率的重试方式。如果需要基于超时重试，可以设置<a href="client.md#重试">backup request</a>，这类重试最多只有一次，放大程度降到了最低。brpc中的RPC超时是deadline，超过后RPC一定会结束，这让用户对服务的行为有更好的预判。在之前的一些实现中，RPC超时是单次超时*重试次数，在实践中容易误判。</li>
<li>brpc server端的<a href="server.md#限制最大并发">max_concurrency选项</a>控制了server的最大并发：当同时处理的请求数超过max_concurrency时，server会回复client错误，而不是继续积压。这一方面在服务开始的源头控制住了积压的请求数，尽量避免延生到用户缓冲或队列中，另一方面也让client尽快地去重试其他server，对集群来说是个更好的策略。</li>
</ol>
</blockquote>
<p><br></p>
<blockquote>
<p>对于brpc的用户来说，要防止雪崩，主要注意两点：</p>
<ol>
<li>评估server的最大并发，设置合理的max_concurrency值。这个默认是不设的，也就是不限制。无论程序是同步还是异步，用户都可以通过 <strong>最大qps * 非拥塞时的延时</strong>（秒）来评估最大并发，原理见<a href="https://en.wikipedia.org/wiki/Little%27s_law" target="_blank" rel="noopener">little’s law</a>，这两个量都可以在brpc中的内置服务中看到。max_concurrency与最大并发相等或大一些就行了。</li>
<li>注意考察重试发生时的行为，特别是在定制RetryPolicy时。如果你只是用默认的brpc重试，一般是安全的。但用户程序也常会自己做重试，比如通过一个Channel访问失败后，去访问另外一个Channel，这种情况下要想清楚重试发生时最差情况下请求量会放大几倍，服务是否可承受。</li>
</ol>
</blockquote>
<p><br><br></p>
<h2 id="hash表"><a href="#hash表" class="headerlink" title="hash表"></a>hash表</h2><p>解决冲突的方法除了常见的开地址和线性探测及变种，还提供了其他的一些。</p>
<blockquote>
<p>混合开链和闭链：一般是把桶数组中的一部分拿出来作为容纳冲突元素的空间，典型如<a href="http://en.wikipedia.org/wiki/Coalesced_hashing" target="_blank" rel="noopener">Coalesced hashing</a>，但这种结构没有解决开链的内存跳转问题，结构又比闭链复杂很多，工程效果并不好。</p>
</blockquote>
<p><br></p>
<blockquote>
<p>多次哈希：一般用多个哈希表代替一个哈希表，当发生冲突时（用另一个哈希值）尝试另一个哈希表。典型如<a href="http://en.wikipedia.org/wiki/Cuckoo_hashing" target="_blank" rel="noopener">Cuckoo hashing</a>，这个结构也没有解决内存跳转。</p>
</blockquote>
<p><br><br></p>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><blockquote>
<p>一般有三种操作IO的方式：</p>
<ul>
<li>blocking IO: 发起IO操作后阻塞当前线程直到IO结束，标准的同步IO，如默认行为的posix <a href="http://linux.die.net/man/2/read" target="_blank" rel="noopener">read</a>和<a href="http://linux.die.net/man/2/write" target="_blank" rel="noopener">write</a>。</li>
<li>non-blocking IO: 发起IO操作后不阻塞，用户可阻塞等待多个IO操作同时结束。non-blocking也是一种同步IO：“批量的同步”。如linux下的<a href="http://linux.die.net/man/2/poll" target="_blank" rel="noopener">poll</a>,<a href="http://linux.die.net/man/2/select" target="_blank" rel="noopener">select</a>, <a href="http://linux.die.net/man/4/epoll" target="_blank" rel="noopener">epoll</a>，BSD下的<a href="https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;sektion=2" target="_blank" rel="noopener">kqueue</a>。</li>
<li>asynchronous IO: 发起IO操作后不阻塞，用户得递一个回调待IO结束后被调用。如windows下的<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms684342(v=vs.85" target="_blank" rel="noopener">OVERLAPPED</a>.aspx) + <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365198(v=vs.85" target="_blank" rel="noopener">IOCP</a>.aspx)。linux的native AIO只对文件有效</li>
</ul>
</blockquote>
<p>这个<em>批量的同步</em>真的用的厉害，佩服。</p>
<blockquote>
<p>linux一般使用non-blocking IO提高IO并发度。</p>
<p>当IO并发度很低时，non-blocking IO不一定比blocking IO更高效，因为后者完全由内核负责，而read/write这类系统调用已高度优化，效率显然高于一般得多个线程协作的non-blocking IO。</p>
<p>不过non-blocking IO也有自己的问题，</p>
<p>它需要调用更多系统调用，比如<a href="http://man7.org/linux/man-pages/man2/epoll_ctl.2.html" target="_blank" rel="noopener">epoll_ctl</a>，由于epoll实现为一棵红黑树，epoll_ctl并不是一个很快的操作，特别在多核环境下，依赖epoll_ctl的实现往往会面临棘手的扩展性问题。non-blocking需要更大的缓冲，否则就会触发更多的事件而影响效率。</p>
<p>non-blocking还得解决不少多线程问题，代码比blocking复杂很多。</p>
<p>IO线程的问题在于一个线程同时只能读一个fd，当多个繁忙的fd聚集在一个IO线程中时，一些读取就被延迟了。</p>
<p>多租户、复杂分流算法，<a href="streaming_rpc.md">Streaming RPC</a>等功能会加重这个问题。高负载下常见的某次读取卡顿会拖慢一个IO线程中所有fd的读取，对可用性的影响幅度较大。</p>
</blockquote>
<p><br><br></p>
<h2 id="超时回调的设计。"><a href="#超时回调的设计。" class="headerlink" title="超时回调的设计。"></a>超时回调的设计。</h2><p>这个问题在设计http server的时候也遇到过。</p>
<p>因为是事件驱动，一个连接一个fd，放进epoll中等事件发生。</p>
<p>但是如果用户关闭连接我们自然就要把fd从epoll中拿出来丢掉，不然一直堆积在epoll中不好。</p>
<p>那么问题来了，用户的关闭其实是封装在read事件中，这个还好解决，如果我们read不到数据大概就是关闭了。</p>
<p>但是用户断电了，突然关闭了，那么是无感知的，也不会产生事件，那么这个fd其实是没用的，但是还是会存在我们的epoll中。</p>
<p>这时候就需要引入超时。</p>
<p>在libevent中提供了一个超时事件，可以传入一个callback，然后丢到事件管理器中。</p>
<p>libevent是基于最小堆实现的，也就是说</p>
<p>把所有的超时事件构造成一个堆，事件最短的放在最上面。</p>
<p>当触发的时候，先一个一个检查，把已经过了时间的事件移出去。</p>
<p>这样其实我们就知道这个超时是有延迟的，并不是到点就执行，但是延迟的时间应该不会太长。</p>
<blockquote>
<p>一般是以<a href="https://en.wikipedia.org/wiki/Heap_(data_structure" target="_blank" rel="noopener">小顶堆</a>)记录触发时间。<a href="http://man7.org/linux/man-pages/man2/epoll_wait.2.html" target="_blank" rel="noopener">epoll_wait</a>前以堆顶的时间计算出参数timeout的值，如果在该时间内没有其他事件，epoll_wait也会醒来，从堆中弹出已超时的元素，调用相应的回调函数。</p>
</blockquote>
<p>但是这是单线程的情况，在多线程中应该怎么设计呢。</p>
<p>看brpc文档</p>
<blockquote>
<p>在多线程框架中，任何线程都可能被用户逻辑阻塞较长的时间，我们需要独立的线程实现timer，这种线程我们叫它TimerThread。一个非常自然的做法，就是使用用锁保护的小顶堆。当一个线程需要创建timer时，它先获得锁，然后把对应的时间插入堆，如果插入的元素成为了最早的，唤醒TimerThread。TimerThread中的逻辑和单线程类似，就是等着堆顶的元素超时，如果在等待过程中有更早的时间插入了，自己会被插入线程唤醒，而不会睡过头。这个方法的问题在于每个timer都需要竞争一把全局锁，操作一个全局小顶堆，就像在其他文章中反复谈到的那样，这会触发cache bouncing。同样数量的timer操作比单线程下的慢10倍是非常正常的，尴尬的是这些timer基本不触发。</p>
</blockquote>
<p><code>cache bouncing</code>好像和多线程自旋锁有关，暂时也没太看明白</p>
<p><a href="https://www.quora.com/What-is-cache-line-bouncing-How-may-a-spinlock-trigger-this-frequently" target="_blank" rel="noopener">cacheline bouncing</a></p>
<blockquote>
<p>一个惯例思路是把timer的需求散列到多个TimerThread，但这对TimerThread效果不好。注意我们上面提及到了那个“制约因素”：一旦插入的元素是最早的，要唤醒TimerThread。假设TimerThread足够多，以至于每个timer都散列到独立的TimerThread，那么每次它都要唤醒那个TimerThread。 “唤醒”意味着触发linux的调度函数，触发上下文切换。在非常流畅的系统中，这个开销大约是3-5微秒，这可比抢锁和同步cache还慢。这个因素是提高TimerThread扩展性的一个难点。多个TimerThread减少了对单个小顶堆的竞争压力，但同时也引入了更多唤醒。</p>
<p>另一个难点是删除。一般用id指代一个Timer。通过这个id删除Timer有两种方式：1.抢锁，通过一个map查到对应timer在小顶堆中的位置，定点删除，这个map要和堆同步维护。2.通过id找到Timer的内存结构，做个标记，留待TimerThread自行发现和删除。第一种方法让插入逻辑更复杂了，删除也要抢锁，线程竞争更激烈。第二种方法在小顶堆内留了一大堆已删除的元素，让堆明显变大，插入和删除都变慢。</p>
</blockquote>
<p>这个，还有删除操作。。。</p>
<p>这个之前真没考虑到，最小堆得删除的话，可能要另外一个数据结构去删除，然后可能只有遍历去找了。</p>
<p>文档中说使用一个<code>HashMap</code>。但是维护起来成本太高了。</p>
<blockquote>
<p>第三个难点是TimerThread不应该经常醒。一个极端是TimerThread永远醒着或以较高频率醒过来（比如每1ms醒一次），这样插入timer的线程就不用负责唤醒了，然后我们把插入请求散列到多个堆降低竞争，问题看似解决了。但事实上这个方案提供的timer精度较差，一般高于2ms。</p>
<p>你得想这个TimerThread怎么写逻辑，它是没法按堆顶元素的时间等待的，由于插入线程不唤醒，一旦有更早的元素插入，TimerThread就会睡过头。它唯一能做的是睡眠固定的时间，但这和现代OS scheduler的假设冲突：频繁sleep的线程的优先级最低。在linux下的结果就是，即使只sleep很短的时间，最终醒过来也可能超过2ms，因为在OS看来，这个线程不重要。一个高精度的TimerThread有唤醒机制，而不是定期醒。</p>
</blockquote>
<p>这个延迟的问题，我不是很有概念到底可接受的范围是多大。</p>
<p>文档里说高于2ms就算是差的了。</p>
<p>照这个频率的话，那么如果是高频率的醒来的话，那么间隔肯定在2ms内。。。</p>
<p>那还不如一直醒着</p>
<blockquote>
<p>另外，更并发的数据结构也难以奏效，感兴趣的同学可以去搜索”concurrent priority queue”或”concurrent skip list”，这些数据结构一般假设插入的数值较为散开，所以可以同时修改结构内的不同部分。但这在RPC场景中也不成立，相互竞争的线程设定的时间往往聚集在同一个区域，因为程序的超时大都是一个值，加上当前时间后都差不多。</p>
</blockquote>
<p>这就是说，ConcurrentHashMap的效率其实也没有那么恐怖。</p>
<blockquote>
<p>那新TimerThread是如何做到的？</p>
<ul>
<li>一个TimerThread而不是多个。</li>
<li>创建的timer散列到多个Bucket以降低线程间的竞争，默认12个Bucket。</li>
<li>Bucket内不使用小顶堆管理时间，而是链表 + nearest_run_time字段，当插入的时间早于nearest_run_time时覆盖这个字段，之后去和全局nearest_run_time（和Bucket的nearest_run_time不同）比较，如果也早于这个时间，修改并唤醒TimerThread。链表节点在锁外使用<a href="memory_management.md">ResourcePool</a>分配。</li>
<li>删除时通过id直接定位到timer内存结构，修改一个标志，timer结构总是由TimerThread释放。</li>
<li>TimerThread被唤醒后首先把全局nearest_run_time设置为几乎无限大(max of int64)，然后取出所有Bucket内的链表，并把Bucket的nearest_run_time设置为几乎无限大(max of int64)。TimerThread把未删除的timer插入小顶堆中维护，这个堆就它一个线程用。在每次运行回调或准备睡眠前都会检查全局nearest_run_time， 如果全局更早，说明有更早的时间加入了，重复这个过程。</li>
</ul>
</blockquote>
<p>删除时直接通过id定位到timer内存结构，修改一个标志位。</p>
<p>唤醒的过程还没看懂。。。</p>
<p>还是c++强啊，这个在Java里就没法实现了。</p>
<blockquote>
<p>这个方法之所以有效：</p>
<ul>
<li>Bucket锁内的操作是O(1)的，就是插入一个链表节点，临界区很小。节点本身的内存分配是在锁外的。</li>
<li>由于大部分插入的时间是递增的，早于Bucket::nearest_run_time而参与全局竞争的timer很少。</li>
<li>参与全局竞争的timer也就是和全局nearest_run_time比一下，临界区很小。</li>
<li>和Bucket内类似，极少数Timer会早于全局nearest_run_time并去唤醒TimerThread。唤醒也在全局锁外。</li>
<li>删除不参与全局竞争。</li>
<li>TimerThread自己维护小顶堆，没有任何cache bouncing，效率很高。 </li>
<li>TimerThread醒来的频率大约是RPC超时的倒数，比如超时=100ms，TimerThread一秒内大约醒10次，已经最优。</li>
</ul>
</blockquote>
<p>干货 !</p>
<blockquote>
<p>下面是一些和linux下时间管理相关的知识：</p>
<ul>
<li>epoll_wait的超时精度是毫秒，较差。pthread_cond_timedwait的超时使用timespec，精度到纳秒，一般是60微秒左右的延时。</li>
<li>出于性能考虑，TimerThread使用wall-time，而不是单调时间，可能受到系统时间调整的影响。具体来说，如果在测试中把系统时间往前或往后调一个小时，程序行为将完全undefined。未来可能会让用户选择单调时间。</li>
<li>在cpu支持nonstop_tsc和constant_tsc的机器上，brpc和bthread会优先使用基于rdtsc的cpuwide_time_us。那两个flag表示rdtsc可作为wall-time使用，不支持的机器上会转而使用较慢的内核时间。我们的机器（Intel Xeon系列）大都有那两个flag。rdtsc作为wall-time使用时是否会受到系统调整时间的影响，未测试不清楚。</li>
</ul>
</blockquote>
<h2 id="常见线程模型"><a href="#常见线程模型" class="headerlink" title="常见线程模型"></a>常见线程模型</h2><blockquote>
<h2 id="连接独占线程或进程"><a href="#连接独占线程或进程" class="headerlink" title="连接独占线程或进程"></a>连接独占线程或进程</h2><p>在这个模型中，线程/进程处理来自绑定连接的消息，在连接断开前不退也不做其他事情。当连接数逐渐增多时，线程/进程占用的资源和上下文切换成本会越来越大，性能很差，这就是<a href="http://en.wikipedia.org/wiki/C10k_problem" target="_blank" rel="noopener">C10K问题</a>的来源。这种方法常见于早期的web server，现在很少使用。</p>
</blockquote>
<p>C10k问题还是挺经典的。</p>
<blockquote>
<h2 id="单线程reactor"><a href="#单线程reactor" class="headerlink" title="单线程reactor"></a>单线程<a href="http://en.wikipedia.org/wiki/Reactor_pattern" target="_blank" rel="noopener">reactor</a></h2><p>以<a href="http://libevent.org/" target="_blank" rel="noopener">libevent</a>, <a href="http://software.schmorp.de/pkg/libev.html" target="_blank" rel="noopener">libev</a>等event-loop库为典型。这个模型一般由一个event dispatcher等待各类事件，待事件发生后<strong>原地</strong>调用对应的event handler，全部调用完后等待更多事件，故为”loop”。这个模型的实质是把多段逻辑按事件触发顺序交织在一个系统线程中。一个event-loop只能使用一个核，故此类程序要么是IO-bound，要么是每个handler有确定的较短的运行时间（比如http server)，否则一个耗时漫长的回调就会卡住整个程序，产生高延时。在实践中这类程序不适合多开发者参与，一个人写了阻塞代码可能就会拖慢其他代码的响应。由于event handler不会同时运行，不太会产生复杂的race condition，一些代码不需要锁。此类程序主要靠部署更多进程增加扩展性。</p>
</blockquote>
<p>主要问题不在IO上其实，因为这种模型无锁，不可控的问题在用户的代码中。</p>
<p>多线程Reactor，比如Netty，其实也有这个问题。</p>
<blockquote>
<h2 id="N-1线程库"><a href="#N-1线程库" class="headerlink" title="N:1线程库"></a>N:1线程库</h2><p>又称为<a href="http://en.wikipedia.org/wiki/Fiber_(computer_science" target="_blank" rel="noopener">Fiber</a>)，以<a href="http://www.gnu.org/software/pth/pth-manual.html" target="_blank" rel="noopener">GNU Pth</a>, <a href="http://state-threads.sourceforge.net/index.html" target="_blank" rel="noopener">StateThreads</a>等为典型，一般是把N个用户线程映射入一个系统线程。同时只运行一个用户线程，调用阻塞函数时才会切换至其他用户线程。N:1线程库与单线程reactor在能力上等价，但事件回调被替换为了上下文(栈,寄存器,signals)，运行回调变成了跳转至上下文。和event loop库一样，单个N:1线程库无法充分发挥多核性能，只适合一些特定的程序。只有一个系统线程对CPU cache较为友好，加上舍弃对signal mask的支持的话，用户线程间的上下文切换可以很快(100~200ns)。N:1线程库的性能一般和event loop库差不多，扩展性也主要靠多进程。</p>
<h2 id="多线程reactor"><a href="#多线程reactor" class="headerlink" title="多线程reactor"></a>多线程reactor</h2><p>以<a href="http://www.boost.org/doc/libs/1_56_0/doc/html/boost_asio.html" target="_blank" rel="noopener">boost::asio</a>为典型。一般由一个或多个线程分别运行event dispatcher，待事件发生后把event handler交给一个worker线程执行。 这个模型是单线程reactor的自然扩展，可以利用多核。由于共用地址空间使得线程间交互变得廉价，worker thread间一般会更及时地均衡负载，而多进程一般依赖更前端的服务来分割流量，一个设计良好的多线程reactor程序往往能比同一台机器上的多个单线程reactor进程更均匀地使用不同核心。不过由于<a href="atomic_instructions.md#cacheline">cache一致性</a>的限制，多线程reactor并不能获得线性于核心数的性能，在特定的场景中，粗糙的多线程reactor实现跑在24核上甚至没有精致的单线程reactor实现跑在1个核上快。由于多线程reactor包含多个worker线程，单个event handler阻塞未必会延缓其他handler，所以event handler未必得非阻塞，除非所有的worker线程都被阻塞才会影响到整体进展。事实上，大部分RPC框架都使用了这个模型，且回调中常有阻塞部分，比如同步等待访问下游的RPC返回。</p>
</blockquote>
<p>那么netty有没有这个问题呢。。。。</p>
<p>感觉考虑了好多关于缓存一致性的问题</p>
<blockquote>
<h2 id="M-N线程库"><a href="#M-N线程库" class="headerlink" title="M:N线程库"></a>M:N线程库</h2><p>即把M个用户线程映射入N个系统线程。M:N线程库可以决定一段代码何时开始在哪运行，并何时结束，相比多线程reactor在调度上具备更多的灵活度。但实现全功能的M:N线程库是困难的，它一直是个活跃的研究话题。我们这里说的M:N线程库特别针对编写网络服务，在这一前提下一些需求可以简化，比如没有时间片抢占，没有(完备的)优先级等。M:N线程库可以在用户态也可以在内核中实现，用户态的实现以新语言为主，比如GHC threads和goroutine，这些语言可以围绕线程库设计全新的关键字并拦截所有相关的API。而在现有语言中的实现往往得修改内核，比如<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd627187(v=vs.85" target="_blank" rel="noopener">Windows UMS</a>.aspx)和google SwicthTo(虽然是1:1，但基于它可以实现M:N的效果)。相比N:1线程库，M:N线程库在使用上更类似于系统线程，需要用锁或消息传递保证代码的线程安全。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h2 id="多核扩展性"><a href="#多核扩展性" class="headerlink" title="多核扩展性"></a>多核扩展性</h2><p>理论上代码都写成事件驱动型能最大化reactor模型的能力，但实际由于编码难度和可维护性，用户的使用方式大都是混合的：回调中往往会发起同步操作，阻塞住worker线程使其无法处理其他请求。一个请求往往要经过几十个服务，线程把大量时间花在了等待下游请求上，用户得开几百个线程以维持足够的吞吐，这造成了高强度的调度开销，并降低了TLS相关代码的效率。任务的分发大都是使用全局mutex + condition保护的队列，当所有线程都在争抢时，效率显然好不到哪去。更好的办法也许是使用更多的任务队列，并调整调度算法以减少全局竞争。比如每个系统线程有独立的runqueue，由一个或多个scheduler把用户线程分发到不同的runqueue，每个系统线程优先运行自己runqueue中的用户线程，然后再考虑其他线程的runqueue。这当然更复杂，但比全局mutex + condition有更好的扩展性。这种结构也更容易支持NUMA。</p>
<p>当event dispatcher把任务递给worker线程时，用户逻辑很可能从一个核心跳到另一个核心，并等待相应的cacheline同步过来，并不很快。如果worker的逻辑能直接运行于event dispatcher所在的核心上就好了，因为大部分时候尽快运行worker的优先级高于获取新事件。类似的是收到response后最好在当前核心唤醒正在同步等待RPC的线程。</p>
</blockquote>
<p>回调中往往发起的是同步操作。</p>
<p>非阻塞read也算吗？</p>
<blockquote>
<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><p>异步编程中的流程控制对于专家也充满了陷阱。任何挂起操作，如sleep一会儿或等待某事完成，都意味着用户需要显式地保存状态，并在回调函数中恢复状态。异步代码往往得写成状态机的形式。当挂起较少时，这有点麻烦，但还是可把握的。问题在于一旦挂起发生在条件判断、循环、子函数中，写出这样的状态机并能被很多人理解和维护，几乎是不可能的，而这在分布式系统中又很常见，因为一个节点往往要与多个节点同时交互。另外如果唤醒可由多种事件触发（比如fd有数据或超时了），挂起和恢复的过程容易出现race condition，对多线程编码能力要求很高。语法糖(比如lambda)可以让编码不那么“麻烦”，但无法降低难度。</p>
<p>共享指针在异步变成中很普遍，这看似方便，但也使内存的ownership变得难以捉摸，如果内存泄漏了，很难定位哪里没有释放；如果segment fault了，也不知道哪里多释放了一下。大量使用引用计数的用户代码很难控制代码质量，容易长期在内存问题上耗费时间。如果引用计数还需要手动维护，保持质量就更难了，维护者也不会愿意改进。没有上下文会使得<a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization" target="_blank" rel="noopener">RAII</a>无法充分发挥作用, 有时需要在callback之外lock，callback之内unlock，实践中很容易出错。</p>
</blockquote>
<p>讲了这么多线程模型，好像都有缺点。</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><blockquote>
<p>最常见的分流算法是round robin和随机。这两个方法的前提是下游的机器和网络都是类似的，但在目前的线上环境下，特别是混部的产品线中，已经很难成立，因为：</p>
<ul>
<li>每台机器运行着不同的程序组合，并伴随着一些离线任务，机器的可用资源在持续动态地变化着。</li>
<li>机器配置不同。</li>
<li>网络延时不同。</li>
</ul>
</blockquote>
<p>干货！</p>
<blockquote>
<p>这些问题其实一直有，但往往被OP辛勤的机器监控和替换给隐藏了。框架层面也有过一些努力，比如UB中的<a href="https://svn.baidu.com/public/trunk/ub/ub_client/ubclient_weightstrategy.h" target="_blank" rel="noopener">WeightedStrategy</a>是根据下游的cpu占用率来进行分流，但明显地它解决不了延时相关的问题，甚至cpu的问题也解决不了：因为它被实现为定期reload一个权值列表，可想而知更新频率高不了，等到负载均衡反应过来，一大堆请求可能都超时了。并且这儿有个数学问题：怎么把cpu占用率转为权值。假设下游差异仅仅由同机运行的其他程序导致，机器配置和网络完全相同，两台机器权值之比是cpu idle之比吗？假如是的，当我们以这个比例给两台机器分流之后，它们的cpu idle应该会更接近对吧？而这会导致我们的分流比例也变得接近，从而使两台机器的cpu idle又出现差距。你注意到这个悖论了吗？这些因素使得这类算法的实际效果和那两个基本算法没什么差距，甚至更差，用者甚少。</p>
<p>我们需要一个能自适应下游负载、规避慢节点的通用分流算法。</p>
</blockquote>
<p><code>Pigeon</code>也是进行了<code>weight</code></p>
<p>但是问题也提出来了，就是更新频率高不了，导致会有一些超时问题只能，你懂得。。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Network/">Network</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-vim技巧" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/04/01/vim技巧/" class="article-date">
      <time datetime="2018-03-31T16:00:00.000Z" itemprop="datePublished">2018-04-01</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/01/vim技巧/">Vim技巧</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>其实我们不一定所有配置都要写在.vimrc里面的<br>偶尔在vim的命令行里执行一些小程序也是很方便的</p>
<h3 id="改tab为space"><a href="#改tab为space" class="headerlink" title="改tab为space"></a>改tab为space</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:<span class="built_in">set</span> expandtab</span><br><span class="line">:%retab</span><br></pre></td></tr></table></figure>
<h3 id="翻半页"><a href="#翻半页" class="headerlink" title="翻半页"></a>翻半页</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下半页</span></span><br><span class="line">&lt;C<span class="_">-d</span>&gt;</span><br><span class="line"><span class="comment"># 上半页</span></span><br><span class="line">&lt;C-u&gt;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vim/">Vim</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-在ubuntu16.04上搭建hadoop环境" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/04/01/在ubuntu16.04上搭建hadoop环境/" class="article-date">
      <time datetime="2018-03-31T16:00:00.000Z" itemprop="datePublished">2018-04-01</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/01/在ubuntu16.04上搭建hadoop环境/">在ubunut16.04上搭建hadoop环境</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>首先我们需要安装几个常用的软件<br>这里的shell我选的是zsh，因为这个语法兼容bash</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立一个hadoop用户</span></span><br><span class="line">useradd -d /home/zhuyichen -m -s /bin/zsh hadoop</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 安装git</span></span><br><span class="line">apt install git -y</span><br><span class="line"><span class="comment"># 安装wget </span></span><br><span class="line">apt install wget -y</span><br><span class="line"><span class="comment"># 安装htop</span></span><br><span class="line">apt install htop -y</span><br><span class="line"><span class="comment"># 安装openjdk8</span></span><br><span class="line">apt install openjdk-8-jdk -y</span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 切换为hadoop用户</span></span><br><span class="line">su</span><br><span class="line"><span class="comment"># 下载hadoop-2.9.1</span></span><br><span class="line">wget http://www-us.apache.org/dist/hadoop/common/hadoop-2.9.1/hadoop-2.9.1.tar.gz</span><br><span class="line"><span class="comment"># 解压文件</span></span><br><span class="line">tar -xvf hadoop-2.9.1.tar.gz</span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 配置一下PATH环境变量，打开.zshrc后添加</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:~hadoop/hadoop-2.9.1/bin</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:~hadoop/hadoop-2.9.1/sbin</span><br><span class="line"><span class="built_in">export</span> HADOOP_HOME=~hadoop/hadoop-2.9.1</span><br><span class="line">    </span><br><span class="line"><span class="comment"># hadoop-env.sh配置中还要单独配置一下JAVA_HOME</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64'</span> &gt;&gt; ~hadoop/hadoop-2.9.1/etc/hadoop/hadoop-env.sh</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 配置ssh</span></span><br><span class="line">ssh_keygen</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 把自己的key加到authorized_keys文件中</span></span><br><span class="line">cat .ssh/id_rsa.pub &gt;&gt; .ssh/authorized_keys</span><br></pre></td></tr></table></figure>
<p>下面开始分布式环境的配置<br>因为分布式需要多态机器<br>可以把上面这个克隆一下，这样就避免了很多的重复配置</p>
<p>我现在有两台虚拟机<br>ip分别为<code>[ip:1]</code>和<code>[ip:2]</code><br>(<code>[ip:1]</code>和<code>[ip:2]</code>替换为真实ip，如192.168.168.3)</p>
<p>把<code>[ip:1]</code>作为<code>master</code>，<code>[ip:2]</code>作为<code>slave1</code></p>
<p>首先修改<code>/etc/hostname</code>文件<br><code>[ip:1]</code>的机器改为<code>master</code>, <code>[ip:2]</code>的机器改为<code>slave1</code></p>
<p>再在<code>/etc/hosts</code>中添加ip映射<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ip:1] master</span><br><span class="line">[ip:2] slave1</span><br></pre></td></tr></table></figure></p>
<p>然后<code>master</code>的机器需要可以<code>ssh</code>进<code>slave</code>机器，所以还需要把<code>master</code>的<code>.ssh/id_rsa.pub</code>的内容加进<code>slave1</code>的<code>.ssh/authorized_keys</code>中。</p>
<p>下面进行配置文件的修改</p>
<p>在<code>hadoop</code>的<code>etc</code>的文件夹下配置一下文件<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- core-site.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://master:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">&lt;!-- hdfs-site.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/data/namenode<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/data/datanode<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- mapred-site.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!-- yarn-site.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>master<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>同时还需要建立<code>/usr/local/hadoop</code>目录</p>
<p>如果机器是<code>master</code>的话，还需要手动指定<code>slaves</code><br>在<code>$HADOOP_HOME/etc/hadoop/slaves</code>文件中加上<code>slave1</code></p>
<p>下面就可以启动了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hdfs namenode -format</span><br><span class="line">start-dfs.sh</span><br><span class="line">start-yarn.sh</span><br></pre></td></tr></table></figure></p>
<p>如果成功的话，<code>jps</code>命令在<code>master</code>上应该除了<code>jps</code>本身外还显示3个进程<br>分别为<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NameNode</span><br><span class="line">SecondaryNameNode</span><br><span class="line">ResourceManager</span><br></pre></td></tr></table></figure></p>
<p>在slave上应该还额外显示2两进程<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DataNode</span><br><span class="line">NodeManager</span><br></pre></td></tr></table></figure></p>
<p>下面如果我们需要自己写一些<code>java</code>文件进行练手的话<br>我推荐的模式是利用<code>idea</code>的远程文件的功能在本地编辑，然后上传到服务器<br>运行一个脚本<br>这样的话我们就可以利用强大的idea写程序同时又可以在服务器很方便的跑了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">javac -classpath /home/hadoop/hadoop-2.9.1/etc/hadoop:/home/hadoop/hadoop-2.9.1/share/hadoop/common/lib/*:/home/hadoop/hadoop-2.9.1/share/hadoop/common/*:/home/hadoop/hadoop-2.9.1/share/hadoop/hdfs:/home/hadoop/hadoop-2.9.1/share/hadoop/hdfs/lib/*:/home/hadoop/hadoop-2.9.1/share/hadoop/hdfs/*:/home/hadoop/hadoop-2.9.1/share/hadoop/yarn:/home/hadoop/hadoop-2.9.1/share/hadoop/yarn/lib/*:/home/hadoop/hadoop-2.9.1/share/hadoop/yarn/*:/home/hadoop/hadoop-2.9.1/share/hadoop/mapreduce/lib/*:/home/hadoop/hadoop-2.9.1/share/hadoop/mapreduce/*:/home/hadoop/hadoop-2.9.1/contrib/capacity-scheduler/*.jar Main.java</span><br><span class="line">jar cvf main.jar Main.class</span><br><span class="line">hadoop jar main.jar Main $*</span><br></pre></td></tr></table></figure>
<p>这样我们在idea本地编辑好<code>Main.java</code>文件，然后上传到服务器，在服务器执行<code>./start.sh</code>就可以执行了。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hadoop/">Hadoop</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-spi和破坏双亲委派" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/03/03/spi和破坏双亲委派/" class="article-date">
      <time datetime="2018-03-02T16:00:00.000Z" itemprop="datePublished">2018-03-03</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/03/spi和破坏双亲委派/">spi和破坏双亲委派</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="Java-SPI"><a href="#Java-SPI" class="headerlink" title="Java SPI"></a>Java SPI</h1><p>Java的spi约定是在源代码目录下的<code>META-INF/services</code>中，新建一个文件，文件名是接口的全限定名，内容是我们想要进行动态Loader的类的全限定名。</p>
<p>比如我们有一个NameLog的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc.lovezhy.spi;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NameLog</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们设定了两个实现<code>FirstNameLog</code>和<code>SecondNameLog</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc.lovezhy.spi;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstNameLog</span> <span class="keyword">implements</span> <span class="title">NameLog</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"here is First"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc.lovezhy.spi;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondNameLog</span> <span class="keyword">implements</span> <span class="title">NameLog</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"here is second"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在源码的目录下新建<code>META-INF/services</code>目录<br>再新建一个名字为<code>cc.lovezhy.spi.NameLog</code>的文件<br>在里面写上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc.lovezhy.spi.FirstNameLog</span><br></pre></td></tr></table></figure></p>
<p>测试程序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServiceLoader&lt;NameLog&gt; services = ServiceLoader.load(NameLog.class);</span><br><span class="line">        <span class="keyword">for</span> (NameLog nameLog : services) &#123;</span><br><span class="line">            nameLog.printName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果：<br><code>here is First</code></p>
<p>一样的，如果我们改成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc.lovezhy.spi.SecondNameLog</span><br></pre></td></tr></table></figure></p>
<p>那么就是打印出<br><code>here is second</code></p>
<p>我们也可以同时写上<br>就会两个都拿到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">here is First</span><br><span class="line">here is second</span><br></pre></td></tr></table></figure></p>
<p>我一开始想的是运行时的实现，后来发现不是，运行时改了时候似乎并没有重新Load</p>
<p>在最近看的pigeon的源代码中其实也看到了很多这样的用法。<br><img src="/images/spi.png" alt=""></p>
<p>经典用法莫过于经常提到的<code>jdbc</code>驱动了，我们只要引入了数据库的jar包，就可以自动找到数据库驱动。</p>
<h1 id="破坏双亲委派"><a href="#破坏双亲委派" class="headerlink" title="破坏双亲委派"></a>破坏双亲委派</h1><p>这也是意外在某个文章里看到的，之前看Java虚拟机书的时候也看到了，但是没太注意。</p>
<h3 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h3><p>jvm的类加载机制，最经典的就是双亲委派机制。<br>jvm类加载器，系统中一般有三个</p>
<ul>
<li>BootstrapClassloader<br>这个是虚拟机层次的，对用户是不可见的，lang包中的类一般是由这个加载器加载。如果我们输出<code>String.class.getClassLoader()</code>会得到null。    </li>
<li>ExtClassloader 一般是<code>JAVA_HOME/jre/lib/ext/</code>目录下的</li>
<li>AppClassloader 一般我们自定义的类都是由这个加载器加载。</li>
</ul>
<p>JVM中类确认需要两个条件</p>
<ul>
<li>加载它的类加载器</li>
<li>它的全路径名<br>也就是说，及时两个类类名一样，但是加载它们的类加载器不同，那么还是两个类。</li>
</ul>
<p>双亲委派就是一个加载器加载一个类的时候，会先让父类加载，如果父类加载不了，才自己加载。<br>这样就可以保证这个类在虚拟机中不被重复加载，还有唯一性。</p>
<p>还有一个规则，如果一个类引用了另外一个类，那么这两个类的类加载器就必须是一样的。</p>
<p>那么问题就来了，<code>BootStrapClassLoader</code>并不能认识我们的实现的第三方代码。那怎么办呢？</p>
<p>如果我们看ClassLoader的类加载器，会发现它是null的，也就是它是由<code>BootstrapClassloader</code>加载的。<br>但是再去看我们那些实现类的类加载器，会发现它们是由<code>AppClassloader</code>加载的。</p>
<p>这是怎么做到的呢，这里需要引入线程上下文加载器。<br>我们可以通过这样得到线程上下文类加载器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(thread.getContextClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果为<br><code>sun.misc.Launcher$AppClassLoader@6b482747</code></p>
<p>由此可见，虽然<code>Thread</code>的类加载器为<code>BootstrapClassloader</code>加载的，但是它的上下文类加载器却是<code>AppClassLoader</code>。</p>
<p>从<code>ServiceLoader</code>源码中也可以看到<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">    ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            ClassLoader loader)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServiceLoader&lt;&gt;(service, loader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-AQS和ReentrantLock" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/24/AQS和ReentrantLock/" class="article-date">
      <time datetime="2018-02-23T16:00:00.000Z" itemprop="datePublished">2018-02-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/24/AQS和ReentrantLock/">AQS和ReentrantLock</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="AQS子类"><a href="#AQS子类" class="headerlink" title="AQS子类"></a>AQS子类</h2><p>继承于AQS的子类。<br><img src="/images/AQS/AQS1.png" alt="AQS"></p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>在ReentrantLock中的lock方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就是对Sync类的调用。</p>
<h3 id="锁的获取"><a href="#锁的获取" class="headerlink" title="锁的获取"></a>锁的获取</h3><p>大体的思路，就是先尝试获取一个锁，如果失败，说明锁正在被人占着，这时候需要把当前线程放到一个容器里，然后挂起。<br>下面看看具体的实现是啥。</p>
<p>如果是非公平锁<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在AQS类中有个state状态，用cas去改变他， 0代表空闲，1代表正在被占用。这个就相当于一个锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure></p>
<p>如果state=0的话，代表当前锁没有被任何线程锁起来。<br>所以首先尝试获取这个锁，如果成功了，那么把当前的独占线程设为当前线程。</p>
<p>不然，调用acquire方法，加1。为什么加1呢，因为ReentantLock是可重入锁，同一个线程每一次获取都是加1，每一次释放就减1。下面我们会看到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>acquire方法在AQS中。<br>但是tryAcquire是交给子类去实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为是非公平锁，所以调用nonfairTryAcquire。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在nonfairTryAcquire中，先再次尝试获取一下state。<br>如果失败，再判断下当前的独占线程是不是自己，如果是自己，就把acquire加上去。<br>这里就是可重入的逻辑。</p>
<p>如果获取失败，而且当前独占线程也不是自己，那么返回false。<br>再返回到AQS中的acquire逻辑，if中第一个条件失败了，那么执行第二个条件acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，就是把当前线程丢到一个等待锁的容器中并挂起。</p>
<p>Node的mode有下面这几种<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//独占</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//这个线程取消获取锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//这个线程在等待某个条件</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"><span class="comment">//节点唤醒需要向下传播，和读写锁有关</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br></pre></td></tr></table></figure></p>
<p>上面调用的是独占的EXCLUSIVE。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到node应该可以猜到这个放等待线程的容器是链表。<br>先cas尝试一下把当前线程包装的node放到末尾。<br>如果失败进入enq()中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>enq的逻辑就是不断自旋，cas加到末尾。其中也包含了head未初始化的情况。</p>
<p>好，现在成功加到末尾，调用acquireQueued方法。在这里进行挂起之类的操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>node.predecessor得到的是节点的prev节点。<br>这里假设当前节点前面有很多节点，那么第一个条件肯定不满足，进入到第二个if中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//表示前一个线程已经取消获取锁</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果状态为0或者为PROPAGATE</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>判断前一个节点的waitStatus。<br>如果是SIGNAL，返回true<br>如果大于0，那就是cancelled了，那就跳过<br>不然就是cas把当前的pred的node的waitStatus设为SIGNAL</p>
<p>如果成功<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么parkAndCheckInterrupt就把当前线程挂起。</p>
<h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><p>在unLock中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>tryRelease方法，就是把state减掉，然后把当前的独占线程置空。<br>在回到release方法，那个unparkSuccessor调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里就是唤醒了下一个node节点中的等待线程。</p>
<p>那么ReentrantLock的公平和非公平体现在哪里呢。<br>我一开始以为的是head节点会唤醒所有的后缀节点，结果不是。<br>已经排队的节点还是按照排队顺序来唤醒。<br>不过在头节点唤醒时，可以有其他的线程来插队。<br>再回到lock方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在获取失败，加到队列的过程中，也尝试了两次插队，最后都失败了，才加入到队列中。</p>
<p>另外，AQS的等待队列只是FIFO的，也就是说不支持优先权。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>AQS为独占和共享提供了基本的接口，需要我们自己去实现tryAcquire等方法。</p>
<h3 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h3><p>正常来说，如果tryAcquire失败，那么AQS就会把当前线程包在Node中，加到等待队列中。<br>等待队列是一个FIFO的双向链表。<br>如果是独占的锁，那么就很简单，ReentrantLock就是借助一个int的变量表明被占用还是空闲。<br>如果是共享锁，这就要看具体的情况了，在CountDownLatch中，就是看当前的钥匙是不是0，如果不是0，说明还是有线程没有countdown，那就加到等待队列去。<br>在读写锁中，如果当前有读锁或者写锁，那就失败。</p>
<h3 id="释放锁-1"><a href="#释放锁-1" class="headerlink" title="释放锁"></a>释放锁</h3><p>然后每次head节点在临界区执行完成，就会选择唤醒下一个节点。<br>如果是独占的，就唤醒下一个，如果是共享的，那么就唤醒下一波所有的要获取共享锁的线程。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-LongAdder解析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/23/LongAdder解析/" class="article-date">
      <time datetime="2018-02-22T16:00:00.000Z" itemprop="datePublished">2018-02-23</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/23/LongAdder解析/">LongAdder解析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongAdder</span> <span class="keyword">extends</span> <span class="title">Striped64</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Striped64</span> <span class="keyword">extends</span> <span class="title">Number</span> </span>&#123; </span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要思路就先cas那个base变量，如果<code>race condition</code>不严重的话，那么就成功返回。</p>
<p>但是如果<code>race condition</code>比较严重，那么就新建很多的<code>cell</code>，在<code>cell</code>里增加<code>value</code>，这样就降低了很多的并发阻塞。</p>
<p>最后汇总的时候，除了<code>base</code>，还需要把每个<code>cell</code>中的<code>value</code>也加上去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">            longAccumulate(x, <span class="keyword">null</span>, uncontended);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个if，表示如果cells还是为空，并且cas增加到base中失败，那么就进行第二个if中的操作。<br>第二个if中，如果as为空，或者as未完全初始化</p>
<p>getProbe() &amp; m相当于一次hash找到对应的cell，如果cell为空，<br>或者cell不为空，但是cell自身的cas加值还是失败，那么最终会调用longAccumulate方法。</p>
<p>longAccumulate方法在Striped64类中，其中我们由add中传入的参数是</p>
<ul>
<li>要增加的x</li>
<li>null</li>
<li>false</li>
</ul>
<p>下面的方法就是对引入的cell就行操作，包括增加，扩容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;    </span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">longAccumulate</span><span class="params">(<span class="keyword">long</span> x, LongBinaryOperator fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">//得到与线程相关的hashCode。</span></span><br><span class="line">    <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.current(); <span class="comment">// force initialization</span></span><br><span class="line">        h = getProbe();</span><br><span class="line">        wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Cell[] as; Cell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">        <span class="comment">//如果cell已经不为null，完成初始化。</span></span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//找到与当前线程有关的cell，和HashMap有点像</span></span><br><span class="line">            <span class="comment">//如果当前cell为空，那么就进行初始化</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//cellsBusy相当于一个锁，用volatile修饰，== 0时表示可以对cells进行操作。</span></span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;       <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                    Cell r = <span class="keyword">new</span> Cell(x);   <span class="comment">// Optimistically create</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                        <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                            Cell[] rs; <span class="keyword">int</span> m, j;</span><br><span class="line">                            <span class="keyword">if</span> ((rs = cells) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                created = <span class="keyword">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            cellsBusy = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (created)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//检查是否发生了一次cas失败，如果是那就标为true，进行下一次循环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">            <span class="comment">//调用cell本身的cas</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                         fn.applyAsLong(v, x))))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                collide = <span class="keyword">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                collide = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//对cells进行扩充</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cells == as) &#123;      <span class="comment">// Expand table unless stale</span></span><br><span class="line">                        Cell[] rs = <span class="keyword">new</span> Cell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        cells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">            &#125;</span><br><span class="line">            h = advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果cell还是为空，那么就进行自旋，如果得到锁，那么就进行初始化</span></span><br><span class="line">        <span class="comment">//初始化为2个的cell，finally释放自旋锁</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                    Cell[] rs = <span class="keyword">new</span> Cell[<span class="number">2</span>];</span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> Cell(x);</span><br><span class="line">                    cells = rs;</span><br><span class="line">                    init = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后还是尝试加在base上，如果失败，那就再来一次for循环。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                    fn.applyAsLong(v, x))))</span><br><span class="line">            <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一段代码的for循环中可以分为三部分。</p>
<p>第一个部分，如果cells已经完成初始化。</p>
<ul>
<li>如果cell还是空，那么就自旋，把新的cell插到cells中。</li>
<li>如果已经发生了一次cas失败，那么就标为true，以便下一次cas</li>
<li>如果cell不为空，那么调用cell的cas</li>
<li>如果各种方法都试了，那么没办法了，尝试扩充cells</li>
</ul>
<p>第二个部分，因为cell还未完成初始化，那么就拿到自旋锁进行初始化。</p>
<p>第三个部分，如果已经被别的线程在进行初始化，那么就再次尝试调用加在base上。<br>如果失败，那么就再来一次for循环。</p>
<p>可以看到每次尝试失败，那么就调用代价更高的方法再进行尝试。<br>所有方法用尽了，那没办法，再重新试一次吧。</p>
<p>可以看到LongAdder和AtomicLong比起来，都是cas的运用。<br>AtomicLong如果cas失败，那么就进行while循环进行cas。<br>但是LongAdder把cas的压力分散到很多个cell中，最后加的时候把每个cell中的value都加上去。<br>高并发效率上，肯定是LongAdder更高一点，但是LongAdder相应的也更费空间。</p>
<p>另外，在ConcurrentHashMap中就是运用了LongAdder的思想。</p>
<p>参考：<br><a href="https://coolshell.cn/articles/11454.html" target="_blank" rel="noopener">https://coolshell.cn/articles/11454.html</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-pigeon的服务注册与发现" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/18/pigeon的服务注册与发现/" class="article-date">
      <time datetime="2018-02-17T16:00:00.000Z" itemprop="datePublished">2018-02-18</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/18/pigeon的服务注册与发现/">pigeon的服务注册与发现</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>pigeon</code>是大众点评内部一直在使用的<code>rpc</code>框架，同时带有服务治理的功能。<br>组件是使用<code>zookeeper</code> + <code>netty</code> + <code>jetty</code>完成。<br>现在也已经开源</p>
<p><a href="https://github.com/dianping/pigeon" target="_blank" rel="noopener">pigeon</a></p>
<p>但是开源似乎做的不用心，可能也是看<code>dubbo</code>很火热，<code>pigeon</code>没人用<br>而且<code>pigeon</code>和点评内部的一点闭源的框架联系紧密，所以用的人并不多(反正我是一个没看到)。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><h3 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h3><p><code>pigeon</code>是与<code>spring</code>进行了很重的耦合的，如果要使用<code>pigeon</code>，那么必须使用<code>spring</code>框架。</p>
<p>如果要暴露我们的服务<br>比如创建一个简单的<code>UserService</code>接口和实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getNameById</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNameById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"id + name"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>pigeon</code>的服务注册和发现是依赖<code>zookeeper</code>的，我们还需要装载一个<code>zookeeper</code><br>在resources文件夹下创建<code>config</code>文件夹，在<code>config</code>文件夹下创建<code>pigeon.properties</code>文件<br>在其中写上zookeeper的ip和端口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pigeon.registry.address=localhost:<span class="number">2181</span></span><br></pre></td></tr></table></figure></p>
<p>同时为了区分服务，需要给我们的服务起一个名字<br>在<code>sources</code>的<code>META-INF</code>文件夹的<code>app.properties</code>里写上<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pigeon.registry.address=localhost:<span class="number">2181</span></span><br></pre></td></tr></table></figure></p>
<p>如果使用<code>typical</code>的方法声明服务的话，我们创建一个<code>spring</code>的配置文件，假设就叫<code>spring.xml</code><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userServiceImpl"</span> <span class="attr">class</span>=<span class="string">"cc.lovezhy.service.UserServiceImpl"</span>/&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.dianping.pigeon.remoting.provider.config.spring.ServiceBean"</span> <span class="attr">init-method</span>=<span class="string">"init"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"services"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">entry</span></span></span><br><span class="line"><span class="tag">        <span class="attr">key</span>=<span class="string">"cc.lovezhy.service.UserService"</span> <span class="attr">value-ref</span>=<span class="string">"userServiceImpl"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这时候，就可以直接用Main方法启动了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SpringContainer container = <span class="keyword">new</span> SpringContainer(<span class="string">"classpath*:/META-INF/spring.xml"</span>);</span><br><span class="line">        container.start();</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然如果你想要部署到<code>tomcat</code>中也是可以的。</p>
<p>同时默认在<code>localhost:4080/services</code>上我们可以看到当前我们暴露出去的服务<br>并且可以调用。</p>
<p><img src="/images/pigeon的服务注册与发现/pigeon.png" alt="4080/services"></p>
<h3 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h3><p><code>client</code>端只需要包含服务的接口就行了。<br>所以<code>service</code>端的代码编写都是分模块写的，一个模块专门提供<code>DTO</code>和<code>service</code>接口<br>打包成<code>maven</code>供其他人使用。<br>然后具体的实现我们再在另外一个模块里写。</p>
<p><code>resources</code>和<code>META-INF</code>的内容和服务端一样的。<br>就是在<code>bean</code>的声明的时候，我们需要这样<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.dianping.pigeon.remoting.invoker.config.spring.ReferenceBean"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">init-method</span>=<span class="string">"init"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interfaceName"</span> <span class="attr">value</span>=<span class="string">"cc.lovezhy.service.UserService"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后我们就可以在<code>Main</code>方法中引用了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath*:spring.xml"</span>);</span><br><span class="line">        UserService userService = applicationContext.getBean(UserService.class);</span><br><span class="line">        System.out.println(userService.getNameById());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="配置客户端调用模式"><a href="#配置客户端调用模式" class="headerlink" title="配置客户端调用模式"></a>配置客户端调用模式</h1><p>在<code>pigeon</code>内部，客户端调用远程服务有4种模式</p>
<ul>
<li><code>sync</code>同步</li>
<li><code>future</code>异步</li>
<li><code>callback</code>也是异步，只是通过回调的方式来处理结果</li>
<li><code>oneway</code>不需要回复</li>
</ul>
<p>例如<code>spring</code>编程方式下只需要配置<code>callType</code>属性：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"babyAccountService"</span> <span class="attr">class</span>=<span class="string">"com.dianping.pigeon.remoting.invoker.config.spring.ReferenceBean"</span> <span class="attr">init-method</span>=<span class="string">"init"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interfaceName"</span> <span class="attr">value</span>=<span class="string">"com.dianping.babytech.casecenter.api.BabyAccountService"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serialize"</span> <span class="attr">value</span>=<span class="string">"hessian"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"callType"</span> <span class="attr">value</span>=<span class="string">"sync"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeout"</span> <span class="attr">value</span>=<span class="string">"5000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>官方文档解释的很清楚了所有的选项。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"echoService"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"com.dianping.pigeon.remoting.invoker.config.spring.ReferenceBean"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">init-method</span>=<span class="string">"init"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 服务全局唯一的标识url，默认是服务接口类名，必须设置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"http://service.dianping.com/demoService/echoService_1.0.0"</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 接口名称，必须设置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interfaceName"</span> <span class="attr">value</span>=<span class="string">"com.dianping.pigeon.demo.EchoService"</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 超时时间，毫秒，默认5000，建议自己设置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeout"</span> <span class="attr">value</span>=<span class="string">"2000"</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 序列化，hessian/fst/protostuff，默认hessian，可不设置--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serialize"</span> <span class="attr">value</span>=<span class="string">"hessian"</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 调用方式，sync/future/callback/oneway，默认sync，可不设置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"callType"</span> <span class="attr">value</span>=<span class="string">"sync"</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 失败策略，快速失败failfast/失败转移failover/失败忽略failsafe/并发取最快返回forking，默认failfast，可不设置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cluster"</span> <span class="attr">value</span>=<span class="string">"failfast"</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 是否超时重试，默认false，可不设置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeoutRetry"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 重试次数，默认1，可不设置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"retries"</span> <span class="attr">value</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="ReferenceBean的获取，init方法"><a href="#ReferenceBean的获取，init方法" class="headerlink" title="ReferenceBean的获取，init方法"></a>ReferenceBean的获取，init方法</h1><p>这个我也画了一个简单的图，不过省略了很多细节部分，在<code>InvokerBootStrap</code>部分和<code>Serializer.proxyRequest</code>部分省略了很多。</p>
<p><img src="/images/pigeon的服务注册与发现/服务发现.svg" alt=""></p>
<p>下面具体看代码。</p>
<p>在我们声明<code>bean</code>的时候还带有一个<code>init-method</code>参数<br><code>init-method=&quot;init&quot;</code><br>意思是在这个<code>bean</code>创建的时候还会调用一下<code>ReferenceBean</code>的<code>init</code>方法。</p>
<p>在<code>init</code>方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.objType = ClassUtils.loadClass(<span class="keyword">this</span>.classLoader, <span class="keyword">this</span>.interfaceName.trim());</span><br><span class="line">    <span class="comment">//这里直接就创建了，其实如果配置简单的话，很多的参数都是空的。</span></span><br><span class="line">    InvokerConfig&lt;?&gt; invokerConfig = <span class="keyword">new</span> InvokerConfig(<span class="keyword">this</span>.objType, <span class="keyword">this</span>.url, <span class="keyword">this</span>.timeout, <span class="keyword">this</span>.callType,</span><br><span class="line">            <span class="keyword">this</span>.serialize, <span class="keyword">this</span>.callback, <span class="keyword">this</span>.group, <span class="keyword">this</span>.writeBufferLimit, <span class="keyword">this</span>.loadBalance, <span class="keyword">this</span>.cluster,</span><br><span class="line">            <span class="keyword">this</span>.retries, <span class="keyword">this</span>.timeoutRetry, <span class="keyword">this</span>.vip, <span class="keyword">this</span>.version, <span class="keyword">this</span>.protocol);</span><br><span class="line">    invokerConfig.setClassLoader(classLoader);</span><br><span class="line">    invokerConfig.setSecret(secret);</span><br><span class="line">    invokerConfig.setRegionPolicy(regionPolicy);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(methods)) &#123;</span><br><span class="line">        Map&lt;String, InvokerMethodConfig&gt; methodMap = <span class="keyword">new</span> HashMap&lt;String, InvokerMethodConfig&gt;();</span><br><span class="line">        invokerConfig.setMethods(methodMap);</span><br><span class="line">        <span class="keyword">for</span> (InvokerMethodConfig method : methods) &#123;</span><br><span class="line">            methodMap.put(method.getName(), method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//降级配置检查</span></span><br><span class="line">    checkMock(); </span><br><span class="line">    invokerConfig.setMock(mock);</span><br><span class="line">    checkRemoteAppkey();</span><br><span class="line">    invokerConfig.setRemoteAppKey(remoteAppKey);</span><br><span class="line">    <span class="comment">//这里就得到了service的代理实例。</span></span><br><span class="line">    <span class="keyword">this</span>.obj = ServiceFactory.getService(invokerConfig);</span><br><span class="line">    configLoadBalance(invokerConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InvokerConfig&lt;?&gt; invokerConfig = <span class="keyword">new</span> InvokerConfig(<span class="keyword">this</span>.objType, <span class="keyword">this</span>.url, <span class="keyword">this</span>.timeout, <span class="keyword">this</span>.callType,</span><br><span class="line">                <span class="keyword">this</span>.serialize, <span class="keyword">this</span>.callback, <span class="keyword">this</span>.suffix, <span class="keyword">this</span>.writeBufferLimit, <span class="keyword">this</span>.loadBalance, <span class="keyword">this</span>.cluster,</span><br><span class="line">                <span class="keyword">this</span>.retries, <span class="keyword">this</span>.timeoutRetry, <span class="keyword">this</span>.vip, <span class="keyword">this</span>.version, <span class="keyword">this</span>.protocol);</span><br></pre></td></tr></table></figure>
<p><code>InvokerConfig</code>参数</p>
<ul>
<li><code>Class&lt;T&gt; serviceInterface</code>                     接口的Class类</li>
<li><code>String url</code>                                  服务全局唯一的标识url，感觉有了<code>serviceInterface</code>就够了</li>
<li><code>String version</code>                                 版本？ </li>
<li><code>byte callMethod</code>                             就是call的方式，sync还是future之类，但是是byte类型的，1代表sync等</li>
<li><code>String callType</code>                              callType就是callMethod的String</li>
<li><code>byte serialize</code>                                 序列化方式，默认是hessian</li>
<li><code>int timeout</code>                                 超时时间</li>
<li><code>InvocationCallback callback</code>                 设置了callback模式才有</li>
<li><code>String suffix</code>  </li>
<li><code>String loadbalance</code>                             负载均衡的策略设置</li>
<li><code>String routePolicy</code>                             路由的规则</li>
<li><code>RoutePolicy routePolicyObj</code> </li>
<li><code>boolean timeoutRetry</code></li>
<li><code>String cluster</code>                             </li>
<li><code>int retries</code>                                 失败了重试的次数</li>
<li><code>String vip</code></li>
<li><code>int maxRequests</code></li>
<li><code>String protocol</code></li>
<li><code>Map&lt;String, InvokerMethodConfig&gt; methods</code></li>
<li><code>ClassLoader classLoader</code></li>
<li><code>String secret</code></li>
<li><code>String remoteAppKey</code></li>
<li><code>Object mock</code></li>
</ul>
<p>上面还提到一个服务降级的问题，这个我们之后再说。</p>
<p>从上面看到，得到的<code>service</code>是从<code>ServiceFactory</code>这个类直接得到的。</p>
<p>在<code>getService</code>的时候直接<code>get</code>了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ServiceFactory这个类，主要就是管理service的加载，发布和获取的。</span></span><br><span class="line"><span class="comment">//它的很多方法，从名字就可以看出来，发布service，取消service，获得service，给service设置权重之类。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ServiceProxy serviceProxy = ServiceProxyLoader.getServiceProxy();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> PublishPolicy publishPolicy = PublishPolicyLoader.getPublishPolicy();</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//这个类，从名字上就可以看到和Provider相关的，进行了一些东西的初始化</span></span><br><span class="line">			ProviderBootStrap.init();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">			logger.error(<span class="string">"error while initializing service factory:"</span>, t);</span><br><span class="line">			System.exit(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getService</span><span class="params">(InvokerConfig&lt;T&gt; invokerConfig)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> serviceProxy.getProxy(invokerConfig);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认的话是建一个<code>DefaultServiceProxy</code><br>它的调用是调用了父类的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultServiceProxy</span> <span class="keyword">extends</span> <span class="title">AbstractServiceProxy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(InvokerConfig&lt;T&gt; invokerConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getProxy(invokerConfig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>AbstractServiceProxy</code>中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个其实是个缓存的map，看下面的get过程中有个加锁的过程</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> Map&lt;InvokerConfig&lt;?&gt;, Object&gt; services = <span class="keyword">new</span> ConcurrentHashMap&lt;InvokerConfig&lt;?&gt;, Object&gt;();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(InvokerConfig&lt;T&gt; invokerConfig)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...省略好多好多</span></span><br><span class="line">    Object service = <span class="keyword">null</span>;</span><br><span class="line">    service = services.get(invokerConfig);</span><br><span class="line">    <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//这个锁，好像用的guava中一个东西，提供和String.intern相同的作用但是不会占用老年代空间？</span></span><br><span class="line">        <span class="comment">//有时间再研究研究</span></span><br><span class="line">        <span class="keyword">synchronized</span> (interner.intern(invokerConfig)) &#123;</span><br><span class="line">            service = services.get(invokerConfig);</span><br><span class="line">            <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//参见另外一篇文章</span></span><br><span class="line">                    InvokerBootStrap.startup();</span><br><span class="line">  </span><br><span class="line">                    <span class="comment">//下面这句就调用AbstractSerializer中的proxyRequest动态生成一个代理类</span></span><br><span class="line">                    service = SerializerFactory.getSerializer(invokerConfig.getSerialize()).proxyRequest(invokerConfig);</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isNotBlank(invokerConfig.getLoadbalance())) &#123;</span><br><span class="line">                        LoadBalanceManager.register(invokerConfig.getUrl(), invokerConfig.getSuffix(), invokerConfig.getLoadbalance());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"error while trying to get service:"</span> + invokerConfig, t);</span><br><span class="line">                &#125;</span><br><span class="line">  </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//配置地域策略，默认的是autoSwitch</span></span><br><span class="line">                    routePolicyManager.register(invokerConfig.getUrl(), invokerConfig.getSuffix(),</span><br><span class="line">                    invokerConfig.getRoutePolicy());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RouteException(<span class="string">"error while setup region route policy: "</span> + invokerConfig, t);</span><br><span class="line">                &#125; </span><br><span class="line">  </span><br><span class="line">                <span class="comment">// watch service config</span></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   serviceConfigManager.register(invokerConfig.getUrl());</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> ConfigException(<span class="string">"error while trying to watch service config: "</span> + invokerConfig, t);</span><br><span class="line">               &#125;</span><br><span class="line">  </span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                  ClientManager.getInstance().registerClients(invokerConfig);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                   logger.warn(<span class="string">"error while trying to setup service client:"</span> + invokerConfig, t);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//加到Map缓存里</span></span><br><span class="line">               services.put(invokerConfig, service);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>InvokerBootStrap.startup()</code>中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有很多的init方法，说明都是和invoke相关的一些配件。</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//这是处理调用超时问题的，把一个InvocationTimeoutListener跑在一个线程中</span></span><br><span class="line">ServiceInvocationRepository.getInstance().init();</span><br><span class="line">  </span><br><span class="line"><span class="comment">//初始化那个proxy的handle，下面会提到</span></span><br><span class="line">InvokerProcessHandlerFactory.init();</span><br><span class="line">  </span><br><span class="line"><span class="comment">//序列化工厂的初始化，默认支持很多序列化方式</span></span><br><span class="line">SerializerFactory.init();</span><br><span class="line">  </span><br><span class="line"><span class="comment">//负载均衡调度的初始化，默认支持四种</span></span><br><span class="line">LoadBalanceManager.init();</span><br><span class="line">  </span><br><span class="line"><span class="comment">//Region策略，就是分地域的策略，如果是北京上海都有服务，那么调用哪一边的问题。</span></span><br><span class="line">RegionPolicyManager.INSTANCE.init();</span><br><span class="line">Monitor monitor = MonitorLoader.getMonitor();</span><br><span class="line"><span class="keyword">if</span> (monitor != <span class="keyword">null</span>) &#123;</span><br><span class="line">	monitor.init();</span><br><span class="line">&#125;</span><br><span class="line">isStartup = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure></p>
<p>得到服务的唯一标志，如果不指定url的话，默认就是接口的全称。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ServiceFactory.getServiceUrl(invokerConfig);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">String <span class="title">getServiceUrl</span><span class="params">(InvokerConfig&lt;T&gt; invokerConfig)</span> </span>&#123;</span><br><span class="line">	String url = invokerConfig.getServiceInterface().getCanonicalName();</span><br><span class="line">	<span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>service代理对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//proxyRequest得到一个proxy的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSerializer</span> <span class="keyword">implements</span> <span class="title">Serializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">proxyRequest</span><span class="params">(InvokerConfig&lt;?&gt; invokerConfig)</span> <span class="keyword">throws</span> SerializationException </span>&#123;</span><br><span class="line">        <span class="comment">//第一个参数是ClassLoader，第二个参数是interface的数组，第三个参数是Proxy类</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(ClassUtils.getCurrentClassLoader(invokerConfig.getClassLoader()),</span><br><span class="line">            <span class="keyword">new</span> Class[] &#123; invokerConfig.getServiceInterface() &#125;, <span class="keyword">new</span> ServiceInvocationProxy(invokerConfig,</span><br><span class="line">                InvokerProcessHandlerFactory.selectInvocationHandler(invokerConfig)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的handler是连接远程调用的桥梁</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceInvocationProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceInvocationProxy</span><span class="params">(InvokerConfig&lt;?&gt; invokerConfig, ServiceInvocationHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.invokerConfig = invokerConfig;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">        <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(handler, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"toString"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> handler.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"hashCode"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> handler.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"equals"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> handler.equals(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> extractResult(handler.handle(<span class="keyword">new</span> DefaultInvokerContext(invokerConfig, methodName, parameterTypes, args)),</span><br><span class="line">            method.getReturnType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们调用其他的方法时，其实是在<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handler.handle(<span class="keyword">new</span> DefaultInvokerContext(invokerConfig, methodName, parameterTypes, args)</span><br></pre></td></tr></table></figure></p>
<p>这里面进行处理的。</p>
<p>这里的handle是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ServiceInvocationHandler handler;</span><br></pre></td></tr></table></figure></p>
<p>在<code>InvokerProcessHandlerFactory</code>中得到一个实例<br>//这里应该是最重要的部分了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokerProcessHandlerFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;InvocationInvokeFilter&gt; bizProcessFilters = <span class="keyword">new</span> LinkedList&lt;InvocationInvokeFilter&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ServiceInvocationHandler bizInvocationHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isInitialized = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//这里进行了一个责任链的处理，类似于netty的那种</span></span><br><span class="line">    <span class="comment">//在调用前进行日志，权限之类的分析。</span></span><br><span class="line">    <span class="comment">//最后的RemoteCallInvokeFilter才是真正调用我们想要的方法</span></span><br><span class="line">    <span class="comment">//初始化在之前就进行了，见上</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isInitialized) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Constants.MONITOR_ENABLE) &#123;</span><br><span class="line">                registerBizProcessFilter(<span class="keyword">new</span> RemoteCallMonitorInvokeFilter());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//trace 监控信息</span></span><br><span class="line">            registerBizProcessFilter(<span class="keyword">new</span> TraceFilter());</span><br><span class="line">            <span class="comment">//服务降级</span></span><br><span class="line">            registerBizProcessFilter(<span class="keyword">new</span> DegradationFilter());</span><br><span class="line">  </span><br><span class="line">            registerBizProcessFilter(<span class="keyword">new</span> ClusterInvokeFilter());</span><br><span class="line">            <span class="comment">//网关，统计流量啥的</span></span><br><span class="line">            registerBizProcessFilter(<span class="keyword">new</span> GatewayInvokeFilter());</span><br><span class="line">            registerBizProcessFilter(<span class="keyword">new</span> ContextPrepareInvokeFilter());</span><br><span class="line">            <span class="comment">//安全验证</span></span><br><span class="line">            registerBizProcessFilter(<span class="keyword">new</span> SecurityFilter());</span><br><span class="line">            <span class="comment">//通过Netty调用</span></span><br><span class="line">            registerBizProcessFilter(<span class="keyword">new</span> RemoteCallInvokeFilter());</span><br><span class="line">            bizInvocationHandler = createInvocationHandler(bizProcessFilters);</span><br><span class="line">            isInitialized = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ServiceInvocationHandler <span class="title">selectInvocationHandler</span><span class="params">(InvokerConfig&lt;?&gt; invokerConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bizInvocationHandler;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123; <span class="string">"rawtypes"</span> &#125;)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;V extends ServiceInvocationFilter&gt; <span class="function">ServiceInvocationHandler <span class="title">createInvocationHandler</span><span class="params">( List&lt;V&gt; internalFilters)</span> </span>&#123;</span><br><span class="line">        ServiceInvocationHandler last = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;V&gt; filterList = <span class="keyword">new</span> ArrayList&lt;V&gt;();</span><br><span class="line">        filterList.addAll(internalFilters);</span><br><span class="line">        <span class="comment">//创建一个调用链</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = filterList.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">final</span> V filter = filterList.get(i);</span><br><span class="line">            <span class="keyword">final</span> ServiceInvocationHandler next = last;</span><br><span class="line">            last = <span class="keyword">new</span> ServiceInvocationHandler() &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> InvocationResponse <span class="title">handle</span><span class="params">(InvocationContext invocationContext)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    InvocationResponse resp = filter.invoke(next, invocationContext);</span><br><span class="line">                    <span class="keyword">return</span> resp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBizProcessFilter</span><span class="params">(InvocationInvokeFilter filter)</span> </span>&#123;</span><br><span class="line">        bizProcessFilters.add(filter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>RemoteCallInvokeFilter</code>中invoke方法中，<br>调用的是<code>InvokerUtils</code>的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response = InvokerUtils.sendRequest(client, invocationContext.getRequest(), future);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InvocationResponse <span class="title">sendRequest</span><span class="params">(Client client, InvocationRequest request, Callback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (request.getCallType() == Constants.CALLTYPE_REPLY) &#123;</span><br><span class="line">        RemoteInvocationBean invocationBean = <span class="keyword">new</span> RemoteInvocationBean();</span><br><span class="line">        invocationBean.request = request;</span><br><span class="line">        invocationBean.callback = callback;</span><br><span class="line">        callback.setRequest(request);</span><br><span class="line">        callback.setClient(client);</span><br><span class="line">        invocationRepository.put(request.getSequence(), invocationBean);</span><br><span class="line">    &#125;</span><br><span class="line">    InvocationResponse response = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//发送的请求在这儿发送的</span></span><br><span class="line">        response = client.write(request);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NetworkException e) &#123;</span><br><span class="line">        invocationRepository.remove(request.getSequence());</span><br><span class="line">        logger.warn(<span class="string">"network exception ocurred:"</span> + request, e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">        invocationRepository.remove(request.getSequence());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>client</code>的实现有两种，一个是<code>Tcp</code>的还有一个是<code>Http</code>的，<code>pigeon</code>两种都支持。<br>好像一般的调用是调用的<code>tcp</code>的方案，然后在<code>4080/services</code>查看和调用的是<code>http</code>的协议。</p>
<p><img src="/images/pigeon的服务注册与发现/Client.jpg" alt="Client实现"></p>
<p>在<code>Netty</code>的实现中的<code>doWrite</code>方法，其实就是调用了<code>channel</code>的<code>write0</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InvocationResponse <span class="title">doWrite</span><span class="params">(InvocationRequest request)</span> <span class="keyword">throws</span> NetworkException </span>&#123;</span><br><span class="line">    NettyChannel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel = channelPool.selectChannel();</span><br><span class="line">        ChannelFuture future = channel.write0(request);</span><br><span class="line">        afterWrite(request, channel);</span><br><span class="line">        <span class="keyword">if</span> (request.getMessageType() == Constants.MESSAGE_TYPE_SERVICE</span><br><span class="line">            || request.getMessageType() == Constants.MESSAGE_TYPE_HEART) &#123;</span><br><span class="line">            future.addListener(<span class="keyword">new</span> MessageWriteListener(request, channel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NetworkException(<span class="string">"[doRequest] remote call failed:"</span> + request, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，代理<code>bean</code>的创建和<code>invoke</code>的流程大概就理清楚了。</p>
<p>但是其实它是怎么和<code>zookeeper</code>沟通拿到<code>service</code>的呢。</p>
<p>我猜想肯定是从那条责任链的某个地方中取得的，于是进行了一番苦苦查找。</p>
<p>在<code>ClusterFactory</code>的<code>select</code>中，默认是返回<code>FailfastCluster</code>，在它的<code>invoke</code>方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Client remoteClient = clientManager.getClient(invokerConfig, request, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>有这句话。</p>
<p>这个<code>Client</code>默认是<code>NettyClient</code>。</p>
<p>如果我们在仔细看一下<code>ClientManager</code>的构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ClientManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.providerAvailableListener = <span class="keyword">new</span> ProviderAvailableListener();</span><br><span class="line">    <span class="keyword">this</span>.clusterListener = <span class="keyword">new</span> DefaultClusterListener(providerAvailableListener);</span><br><span class="line">    <span class="keyword">this</span>.clusterListenerManager.addListener(<span class="keyword">this</span>.clusterListener);</span><br><span class="line">    providerAvailableThreadPool.execute(<span class="keyword">this</span>.providerAvailableListener);</span><br><span class="line">    RegistryEventListener.addListener(providerChangeListener);</span><br><span class="line">    RegistryEventListener.addListener(registryConnectionListener);</span><br><span class="line">    RegistryEventListener.addListener(groupChangeListener);</span><br><span class="line">    registerThreadPool.getExecutor().allowCoreThreadTimeOut(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里其实启动了一个<code>ProviderAvailableListener</code>。</p>
<p>这个类和<code>RegisterManager</code>关系密切，而<code>RegisterManager</code>则是掌管和<code>zookeeper</code>沟通的，由此不难看出，这里的<code>service</code>就是从这儿得到的。</p>
<h2 id="服务端集群策略"><a href="#服务端集群策略" class="headerlink" title="服务端集群策略"></a>服务端集群策略</h2><p>在<code>ClusterInvokeFilter</code>中进行的配置</p>
<ul>
<li><code>failfast</code> - 调用服务的一个节点失败后抛出异常返回，可以同时配置重试timeoutRetry和retries属性  </li>
<li><code>failover</code> - 调用服务的一个节点失败后会尝试调用另外的一个节点，可以同时配置重试  timeoutRetry和retries属性  </li>
<li><code>failsafe</code> - 调用服务的一个节点失败后不会抛出异常，返回null，后续版本会考虑按配置默认值返回  </li>
<li><code>forking</code> - 同时调用服务的所有可用节点，返回调用最快的节点结果数据。<br>可以通过配置forkingSize，指定最多调用的节点数（pigeon2.10.3及以上版本通过xml配置forkingSize，其余版本可以通过lion配置{appkey}.pigeon.invoker.forking.size）  </li>
<li><code>hedged</code> - 发出第一个请求后，如果<code>hedgedDelay</code>时间内没有返回，会向其他节点发送第二个请求，返回最先返回的结果数据  </li>
</ul>
<h1 id="ServiceBean的注册"><a href="#ServiceBean的注册" class="headerlink" title="ServiceBean的注册"></a>ServiceBean的注册</h1><p><img src="/images/pigeon的服务注册与发现/服务注册.svg" alt=""><br>（画了我好久的图）<br>具体的流程和<code>ReferenceBean</code>的获取其实差不了太多。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pigeon/">pigeon</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-pigeon中的核心类和作用" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/18/pigeon中的核心类和作用/" class="article-date">
      <time datetime="2018-02-17T16:00:00.000Z" itemprop="datePublished">2018-02-18</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/18/pigeon中的核心类和作用/">pigeon中的核心类和作用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="ServiceFactory"><a href="#ServiceFactory" class="headerlink" title="ServiceFactory"></a>ServiceFactory</h1><p>这个类的作用就是服务的注册发布和get的最外层接口</p>
<p>内部有两个主要的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ServiceProxy serviceProxy = ServiceProxyLoader.getServiceProxy();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> PublishPolicy publishPolicy = PublishPolicyLoader.getPublishPolicy();</span><br></pre></td></tr></table></figure>
<p><code>ServiceProxy</code>用来获取<code>service</code>的，就是包一层<code>proxy</code>吧。</p>
<p><code>PublishPolicy</code>简单说就是发布<code>service</code>的，但是内部还是借助于<code>ServicePublisher</code>进行操作的。</p>
<h1 id="RegistryManager"><a href="#RegistryManager" class="headerlink" title="RegistryManager"></a>RegistryManager</h1><p>这个类的作用其实是为<code>ServicePublisher</code>的<code>addService</code>到<code>zookeeper</code>中和<code>unpublish</code>指定的<code>service</code>提供API支持的。</p>
<p>更通俗点就是为<code>invoker</code>和<code>provider</code>提供了<code>zookeeper</code>的交流的。</p>
<p>但是内部还是使用的<code>registry</code>类进行和<code>zookeeper</code>调用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Registry</span> </span>&#123;</span><br><span class="line">    <span class="comment">//删除了好多，可以自己去看源码</span></span><br><span class="line">    <span class="comment">// for invoker</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSupportNewProtocol</span><span class="params">(String serviceAddress, String serviceName)</span> <span class="keyword">throws</span> RegistryException</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// for provider</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setSupportNewProtocol</span><span class="params">(String serviceAddress, String serviceName, <span class="keyword">boolean</span> support)</span> <span class="keyword">throws</span> RegistryException</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// for invoker/provider</span></span><br><span class="line">    <span class="function">RegistryConfig <span class="title">getRegistryConfig</span><span class="params">(String ip)</span> <span class="keyword">throws</span> RegistryException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="InvokerBootStrap"><a href="#InvokerBootStrap" class="headerlink" title="InvokerBootStrap"></a>InvokerBootStrap</h1><p>这个类看名字也知道是为了<code>invoker</code>提供方便的。</p>
<p>看调用也是<code>AbstractServiceProxy</code>这个类调用的最多</p>
<p>主要有两个方法，<code>startup</code>和<code>shutdown</code>，也没什么重要的成员变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isStartup) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (InvokerBootStrap.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isStartup) &#123;</span><br><span class="line">                ServiceInvocationRepository.getInstance().init();</span><br><span class="line">                InvokerProcessHandlerFactory.init();</span><br><span class="line">                SerializerFactory.init();</span><br><span class="line">                LoadBalanceManager.init();</span><br><span class="line">                RegionPolicyManager.INSTANCE.init();</span><br><span class="line">                Monitor monitor = MonitorLoader.getMonitor();</span><br><span class="line">                <span class="keyword">if</span> (monitor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    monitor.init();</span><br><span class="line">                &#125;</span><br><span class="line">                isStartup = <span class="keyword">true</span>;</span><br><span class="line">                logger.warn(<span class="string">"pigeon client[version:"</span> + VersionUtils.VERSION + <span class="string">"] has been started"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>ServiceInvocationRepository</code>的<code>init</code>方法主要是启动了一个<code>InvocationTimeoutListener</code>线程，看样子是用来检测调用超时问题。</p>
<p>在<code>InvokerProcessHandlerFactory</code>的<code>init</code>方法中，就是在<code>service</code>的<code>proxy</code>中，加入了一条责任链。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">registerBizProcessFilter(<span class="keyword">new</span> TraceFilter());</span><br><span class="line">registerBizProcessFilter(<span class="keyword">new</span> DegradationFilter());</span><br><span class="line">registerBizProcessFilter(<span class="keyword">new</span> ClusterInvokeFilter());</span><br><span class="line">registerBizProcessFilter(<span class="keyword">new</span> GatewayInvokeFilter());</span><br><span class="line">registerBizProcessFilter(<span class="keyword">new</span> ContextPrepareInvokeFilter());</span><br><span class="line">registerBizProcessFilter(<span class="keyword">new</span> SecurityFilter());</span><br><span class="line">registerBizProcessFilter(<span class="keyword">new</span> RemoteCallInvokeFilter());</span><br></pre></td></tr></table></figure>
<p><code>SerializerFactory</code>见下</p>
<p><code>LoadBalanceManager</code>的<code>init</code>方法，初始化了<code>pigeon</code>支持的四种负载均衡的算法。</p>
<ul>
<li><code>RandomLoadBalance</code></li>
<li><code>AutoawareLoadBalance</code></li>
<li><code>RoundRobinLoadBalance</code></li>
<li><code>WeightedAutoawareLoadBalance</code></li>
</ul>
<p>在<code>RegionPolicyManager</code>的<code>init</code>方法中，就是对<code>Region</code>的选择算法进行了初始化。</p>
<p>那个<code>monitor</code>的方法，我看好像还没写好。。。。</p>
<h1 id="ProviderBootStrap"><a href="#ProviderBootStrap" class="headerlink" title="ProviderBootStrap"></a>ProviderBootStrap</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>包含了<code>SerializerFactory</code>和<code>ProviderProcessHandlerFactory</code>的初始化。</p>
<p>同时对<code>jetty server</code>和<code>netty server</code>两个<code>server</code>进行了初始化和启动。</p>
<p>同时启动了一个监听服务器的线程<code>ShutdownHookListener</code></p>
<p>如果服务器关闭，那么就会调用一些类的关闭方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从zookeeper上unpublish掉所有的服务</span></span><br><span class="line">ServiceFactory.unpublishAllServices();</span><br><span class="line">InvokerBootStrap.shutdown();</span><br><span class="line">ProviderBootStrap.shutdown();</span><br></pre></td></tr></table></figure>
<h2 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Server server : serversMap.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.info(<span class="string">"start to stop "</span> + server);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                unregisterConsoleServer(server.getServerConfig());</span><br><span class="line">                server.stop();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(server + <span class="string">" has been shutdown"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ProviderProcessHandlerFactory.destroy();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把<code>server</code>从<code>zookeeper</code>上下掉，这个过程调用了<code>RegistryManager</code>的方法。</p>
<p>然后调用了<code>ProviderProcessHandlerFactory</code>的<code>destroy</code>方法。</p>
<h1 id="SerializerFactory"><a href="#SerializerFactory" class="headerlink" title="SerializerFactory"></a>SerializerFactory</h1><p>对框架支持的序列化方法进行了注册。</p>
<p>内部维护了两个map</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String, Byte&gt; serializerTypes;</span><br><span class="line">ConcurrentHashMap&lt;Byte, Serializer&gt; serializers</span><br></pre></td></tr></table></figure>
<p>这个Serializer类有啥用呢，这个其实还值得我们去研究研究。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Object <span class="title">deserializeRequest</span><span class="params">(InputStream is)</span> <span class="keyword">throws</span> SerializationException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">serializeRequest</span><span class="params">(OutputStream os, Object obj)</span> <span class="keyword">throws</span> SerializationException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Object <span class="title">deserializeResponse</span><span class="params">(InputStream is)</span> <span class="keyword">throws</span> SerializationException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">serializeResponse</span><span class="params">(OutputStream os, Object obj)</span> <span class="keyword">throws</span> SerializationException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Object <span class="title">proxyRequest</span><span class="params">(InvokerConfig&lt;?&gt; invokerConfig)</span> <span class="keyword">throws</span> SerializationException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">InvocationResponse <span class="title">newResponse</span><span class="params">()</span> <span class="keyword">throws</span> SerializationException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">InvocationRequest <span class="title">newRequest</span><span class="params">(InvokerContext invokerContext)</span> <span class="keyword">throws</span> SerializationException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Serializer</code>接口中有七个方法，都是和序列化有关，其中<code>proxyRequest</code>方法请看pigeon的服务注册与发布.</p>
<p>我们进行方法调用，发送请求，获取调用结果。这中间的过程都是需要进行序列化的。</p>
<p><code>pigeon</code>支持11种序列化方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SerializerType &#123;</span><br><span class="line">  </span><br><span class="line">    INTERNAL_THRIFT((<span class="keyword">byte</span>) <span class="number">1</span>, <span class="string">"internalThrift"</span>),</span><br><span class="line">  </span><br><span class="line">    HESSIAN((<span class="keyword">byte</span>) <span class="number">2</span>, <span class="string">"hessian"</span>),</span><br><span class="line">  </span><br><span class="line">    JAVA((<span class="keyword">byte</span>) <span class="number">3</span>, <span class="string">"java"</span>),</span><br><span class="line">  </span><br><span class="line">    PROTO((<span class="keyword">byte</span>) <span class="number">5</span>, <span class="string">"proto"</span>),</span><br><span class="line">  </span><br><span class="line">    HESSIAN1((<span class="keyword">byte</span>) <span class="number">6</span>, <span class="string">"hessian1"</span>),</span><br><span class="line">  </span><br><span class="line">    JSON((<span class="keyword">byte</span>) <span class="number">7</span>, <span class="string">"json"</span>),</span><br><span class="line">  </span><br><span class="line">    FST((<span class="keyword">byte</span>) <span class="number">8</span>, <span class="string">"fst"</span>),</span><br><span class="line">  </span><br><span class="line">    PROTOBUF((<span class="keyword">byte</span>) <span class="number">9</span>, <span class="string">"protobuf"</span>),</span><br><span class="line">  </span><br><span class="line">    THRIFT((<span class="keyword">byte</span>) <span class="number">10</span>, <span class="string">"thrift"</span>),</span><br><span class="line">  </span><br><span class="line">    PROTOBUF3((<span class="keyword">byte</span>) <span class="number">11</span>, <span class="string">"protobuf3"</span>);</span><br></pre></td></tr></table></figure>
<p>同时有八个进行序列化操作的实体类。</p>
<p><img src="/images/pigeon中的核心类和作用/1.png" alt=""></p>
<h1 id="ProviderProcessHandlerFactory"><a href="#ProviderProcessHandlerFactory" class="headerlink" title="ProviderProcessHandlerFactory"></a>ProviderProcessHandlerFactory</h1><p>我们知道在<code>InvokerProcessHandlerFactory</code>中，给<code>invoke</code>的过程加上了一天责任链。</p>
<p>那么这个的<code>init</code>方法就是给<code>Provide</code>的时候，也加上一条责任链。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">registerBizProcessFilter(<span class="keyword">new</span> TraceFilter());</span><br><span class="line"><span class="keyword">if</span> (Constants.MONITOR_ENABLE) &#123;</span><br><span class="line">    registerBizProcessFilter(<span class="keyword">new</span> MonitorProcessFilter());</span><br><span class="line">&#125;</span><br><span class="line">registerBizProcessFilter(<span class="keyword">new</span> WriteResponseProcessFilter());</span><br><span class="line">registerBizProcessFilter(<span class="keyword">new</span> ContextTransferProcessFilter());</span><br><span class="line">registerBizProcessFilter(<span class="keyword">new</span> ExceptionProcessFilter());</span><br><span class="line">registerBizProcessFilter(<span class="keyword">new</span> SecurityFilter());</span><br><span class="line">registerBizProcessFilter(<span class="keyword">new</span> GatewayProcessFilter());</span><br><span class="line">registerBizProcessFilter(<span class="keyword">new</span> BusinessProcessFilter());</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pigeon/">pigeon</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-fat-jar" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/10/fat-jar/" class="article-date">
      <time datetime="2018-02-09T16:00:00.000Z" itemprop="datePublished">2018-02-10</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/10/fat-jar/">fat-jar配置</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>maven打包的时候，默认只是把你的源文件打包起来<br>如果你的项目中还依赖了其他的项目，那是不打包进去的。</p>
<p>这样我们在启动的时候，配置起来可能就会很麻烦。</p>
<p>于是fat-jar的方式诞生了。</p>
<p>比如最熟悉的spring-boot项目，我们在package时候，在target目录的jar文件<br>我们可以直接java -jar 运行。不需要手动管理依赖。</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>有好几个maven插件支持fat-jar的方式。<br>介绍一下spring-boot的插件。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>&#123;version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>&#123;MainClass&#125;<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">layout</span>&gt;</span>JAR<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>同时，需要进行java-version的一些配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>运行的话，可以直接运行或者打包好后运行<br><code>mvn spring-boot:run</code></p>
<p><code>mvn package</code><br>在target目录会生成一个大的jar文件<br><code>java -jar XXXX.jar</code><br>就可以启动了</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-log4j和slf4j配置" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/07/log4j和slf4j配置/" class="article-date">
      <time datetime="2018-02-06T16:00:00.000Z" itemprop="datePublished">2018-02-07</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/07/log4j和slf4j配置/">log4j和slf4j配置</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前自己写的时候哪管什么log不log的，遇到啥都是直接sout。<br>后来在写自己的框架的时候，发现不行啊，我要做一个log出来，像<code>spring</code>启动那样。<br>来了美团，这里的log更加的严谨了，除了要运行的时候打印出log，还要把log分类分时间打到本地的文件里，</p>
<p>当然这还不够，美团有个cat框架，还需要我们把log通过网络，打到专门管理log的服务器上去。</p>
<p>大的系统log是很有必要的，这样出了问了log能给我们很大的启示。</p>
<h1 id="Log框架"><a href="#Log框架" class="headerlink" title="Log框架"></a>Log框架</h1><p>Java的Log框架是比较乱的，之前一直没搞懂，不知道依赖关系。</p>
<p>主要的有</p>
<ul>
<li><code>apache</code> 的<code>log4j</code></li>
<li>升级版的<code>log4j2</code></li>
<li><code>apache</code>的<code>common logging</code></li>
<li><code>java.util.Logging</code></li>
<li><code>slf4j</code></li>
<li><code>LogBack</code></li>
</ul>
<p>不自己去了解一下其实是很乱的，光<code>apache</code>的log就有好几套。</p>
<p>不过主流的还是<code>log4j</code>和<code>LogBack</code>，但是为了避免框架的Log和用户的Log不一样。<br>总不能一个系统里就有几套不同的Log吧。<br>于是<code>slf4j</code>出现了，这个框架，不提供实现，只提供接口。<br>幸运的是<code>Log4j</code>和<code>LogBack</code>都实现了这个框架的接口。<br>所以现在大多数还是直接调用<code>slf4j</code>的接口。实现的话，我们选一个去<code>import</code>一下就行。</p>
<h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-slf4j-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以<code>log4j</code>为例，首先我们得引入<code>slf4j</code>的规定的接口包，然后再引入<code>log4j</code>的实现包就行了。</p>
<p>再加上log的配置文件。（见下）</p>
<p>在代码中就直接写<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(Main.class);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"dddddddd"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就可以了。</p>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>log4j的配置文件其实也不难。<br>在<code>resources</code>目录下建立<code>log4j2.xml</code>文件。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"log-path"</span>&gt;</span>/Users/zhuyichen/log/testLogs.txt<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">File</span> <span class="attr">name</span>=<span class="string">"file"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;log-path&#125;"</span> <span class="attr">append</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"rollingFile"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;log-path&#125;"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">filePattern</span>=<span class="string">"$&#123;sys:user.home&#125;/log/$$&#123;date:yyyy-MM&#125;/info-%d&#123;yyyy-MM-dd&#125;-%i.log"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">append</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"info"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"100MB"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">"20"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">        <span class="tag">&lt;<span class="name">Logger</span> <span class="attr">name</span>=<span class="string">"Main"</span> <span class="attr">level</span>=<span class="string">"error, info"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Logger</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">"all"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"file"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>首先<code>Properties</code>的条目是随便写的，只是方便我们下面引用的时候方便管理而已。<br>比如我们把我的log目录文件路径放进去了。<br>下面就可以用<code>${log-path}</code>来引用</p>
<h2 id="Appenders"><a href="#Appenders" class="headerlink" title="Appenders"></a>Appenders</h2><p>下面就是<code>Appenders</code>，这里相当于我们设定几个log模式。</p>
<p><code>Console</code>是<code>console</code>直接打印的模式。<br><code>PatternLayout</code>是打印出来的样式。</p>
<p>File就是打印到文件的模式。</p>
<ul>
<li><code>name</code> 名字，由下面的Logger引用用</li>
<li><code>fileName</code> Log文件的路径</li>
<li><code>append</code> 每次启动，log是加到文件里，还是清空文件。</li>
</ul>
<p><code>RollingFile</code>就是轮转的<code>Log</code>，可以指定策略创建新的，删除旧的。<br>叫滚动日志</p>
<ul>
<li><code>name</code> <code>Appenders</code>的名字</li>
<li><code>fileName</code>文件的名字</li>
<li><code>filePattern</code>就是指定创建新的log文件的格式</li>
<li><code>Policies</code> 指定滚动日志的策略<ul>
<li><code>TimeBasedTriggeringPolicy</code> 基于时间的滚动策略</li>
<li><code>SizeBasedTriggeringPolicy</code> 基于指定文件大小的滚动策略，size属性用来定义每个日志文件的大小</li>
<li><code>DefaultRolloverStrategy</code> 用来指定同一个文件夹下最多有几个日志文件时开始删除最旧的</li>
</ul>
</li>
</ul>
<h2 id="Loggers"><a href="#Loggers" class="headerlink" title="Loggers"></a>Loggers</h2><p><code>Loggers</code>才是真正控制我们<code>Log</code>的地方。</p>
<p>一般有两种节点，一个是<code>Logger</code>，一个是<code>Root</code>。</p>
<p>level:日志输出级别，共有8个级别，按照从低到高为：<code>All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF</code>。</p>
<p>按这个级别排序呢，就是说如果是all，那么大于等于它的级别的都会输出。</p>
<p><code>Logger</code>一般单独指认某个类或者某个的输出日志。</p>
<ul>
<li><code>name</code> 指某个类所在全程或者某个包的全程</li>
<li><code>level</code> 输出的日记级别</li>
<li><code>additivity</code> 如果设为<code>false</code>，那么就不会在下面的<code>Root</code>节点再输出了。</li>
</ul>
<p><code>Root</code>是个特殊的条目，就是剩下来的所有<br>相比较<code>Logger</code>配置只有一个<code>level</code></p>
<p>在每个配置中具体日志打到哪儿，需要引用我们上面定义的<code>Appender</code>了。<br>你需要这个Log打印到哪儿，就在里面增加一个<code>AppenderRef</code>条目。</p>
<p>比如我的<code>Root</code>节点需要全部既打印到终端，又打印到文件，我就把两个都引用进去。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/hafiz/p/6170702.html" target="_blank" rel="noopener">https://www.cnblogs.com/hafiz/p/6170702.html</a><br><a href="https://logging.apache.org/log4j/2.x/manual/index.html" target="_blank" rel="noopener">官方文档</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2018 zhy
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
    </div>
</footer>
    </div>
    
    <script src="/js/GithubRepoWidget.js"></script>

<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
             github: ".github-widget a", 
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>