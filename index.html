<!DOCTYPE html>
<html >
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="zhy" />


    
    


<meta property="og:type" content="website">
<meta property="og:title" content="LoveZhy">
<meta property="og:url" content="http://zhyzhyzhy.github.io/index.html">
<meta property="og:site_name" content="LoveZhy">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LoveZhy">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="LoveZhy" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>LoveZhy</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: undefined
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">zhy</a></h1>
        </hgroup>

        

        


        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:zhuyichen1017@gmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/zhyzhyzhy" title="GitHub"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                
                

                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">江湖里卧虎，人心里藏龙</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">zhy</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">zhy</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:zhuyichen1017@gmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/zhyzhyzhy" title="GitHub"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-Presto源码-ExchangeClient和OutputBuffer详解" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/20/Presto源码-ExchangeClient和OutputBuffer详解/" class="article-date">
      <time datetime="2018-07-19T16:00:00.000Z" itemprop="datePublished">2018-07-20</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/20/Presto源码-ExchangeClient和OutputBuffer详解/">Presto源码-ExchangeClient和OutputBuffer详解</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Presto在数据进行shuffle的时候，并不是PPT中经常看到的Push模式，而是Pull模式。<br>在两端负责分发和交换数据的类分别是ExchangClient和OutputBuffer。</p>
<p>比如：<br>Source Stage把数据从Connector中拉取出来，这时候需要给下一个FixedStage进行处理。<br>他会先把数据放在OutputBuffer中，等待上游把数据请求过去，而上游请求数据的类就是ExchangeClient。</p>
<h2 id="ExchangeClient"><a href="#ExchangeClient" class="headerlink" title="ExchangeClient"></a>ExchangeClient</h2><p><img src="../images/presto-exchangeclient/ExchangeClient.png" alt=""><br>大体的过程是这样，但是一些细节还是没发画出来，尽力了。<br>下面详细解释下。</p>
<h3 id="ExchangOperator"><a href="#ExchangOperator" class="headerlink" title="ExchangOperator"></a>ExchangOperator</h3><p>一般来说负责拉数据有个专门的Operator是ExchangeOperator。<br>在创建ExchangeOperator的时候，会加上一个ExchangClient。<br>所以和图中不同的是，这个ExchangeClient其实是在ExchangeOperator里面。</p>
<p>在PipeLine的下一个Operator和ExchangeClient拉数据的时候，会调用上一个的getOutput()<br>在ExchangeOperator的getOutput()方法中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Page <span class="title">getOutput</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SerializedPage page = exchangeClient.pollPage();</span><br><span class="line">        <span class="keyword">if</span> (page == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> operatorContext.recordGeneratedInput(page.getSizeInBytes(), page.getPositionCount());</span><br><span class="line">        <span class="keyword">return</span> serde.deserialize(page);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>就是调用的exchangeClient的pollPage()方法得到一个Page。</p>
<h3 id="RemoteSplit"><a href="#RemoteSplit" class="headerlink" title="RemoteSplit"></a>RemoteSplit</h3><p>RemoteSplit是Source Stage的Task在生成的时候，会添加给FixedStage的。<br>成员变量特别简单，就是一个标记数据位置的URL。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteSplit</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ConnectorSplit</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URI location;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="HttpPageBufferClient"><a href="#HttpPageBufferClient" class="headerlink" title="HttpPageBufferClient"></a>HttpPageBufferClient</h3><p>在进行addSplit到ExchangOperator的时候，会把每个URL封装成一个HttpPageBufferClient，同时传递进去的还有</p>
<ul>
<li>httpClient 整个Task共享的一个。</li>
<li>maxResponseSize 一次相应最多的数据量大小，默认是1M</li>
<li>minErrorDuration</li>
<li>maxErrorDuration</li>
<li>new ExchangeClientCallback() 当拿到数据后的回调，把Page加到ExchangeClient的队列中</li>
<li>executor 所有的http请求都是通过这个线程池发送</li>
</ul>
<h3 id="流控"><a href="#流控" class="headerlink" title="流控"></a>流控</h3><p>如果上游的数据来不及消费会怎么样。<br>那么，上游来不及消费的信号是什么呢？<br>整个buffer肯定有个阈值的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangeClientConfig</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DataSize maxBufferSize = <span class="keyword">new</span> DataSize(<span class="number">32</span>, Unit.MEGABYTE);</span><br></pre></td></tr></table></figure></p>
<p>这个阈值就是最大的bufferSize，默认是32M。</p>
<p>在ExchangClient中，有一个long bufferBytes;用来标记当前的buffer中有多少buffer。<br>在scheduleRequestIfNecessary()方法中，会把bufferBytes和maxBufferSize进行比较，如果已经满足了，那么就不会请求HttpPageBufferClient去请求数据。</p>
<p>同时HttpPageBufferClient不是划了个定时任务去做拉数据的，整个拉取入口函数都是scheduleRequestIfNecessary()中，需要进行手动调用的。</p>
<p>那么是在什么时候会进行手动调用呢，查看了一些，在下面情况下会发生：</p>
<ul>
<li>在新增URL的时候</li>
<li>在所有的RemoteSplit分配借书的时候</li>
<li>在ExchangeOperator进行pollPage时</li>
</ul>
<h2 id="OutputBuffer"><a href="#OutputBuffer" class="headerlink" title="OutputBuffer"></a>OutputBuffer</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Presto/">Presto</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Presto源码解析-Slice实现" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/19/Presto源码解析-Slice实现/" class="article-date">
      <time datetime="2018-07-18T16:00:00.000Z" itemprop="datePublished">2018-07-19</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/19/Presto源码解析-Slice实现/">Presto源码解析 - Slice实现</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Presto的Slice并不在Presto包中，是在一个独立的包<code>org.airlift.slice</code>中<br><code>org.airlift</code>是个工具类，作者也是Presto的主要开发者，主要是服务于Presto的，但是我们也可以单独取出来用。</p>
<h2 id="ClassLayout和Unsafe"><a href="#ClassLayout和Unsafe" class="headerlink" title="ClassLayout和Unsafe"></a>ClassLayout和Unsafe</h2><p>在Java中一般是无法取得类的大小的，需要通过一些特殊的手段，例如Unsafe包中的方法。<br><code>org.openjdk.jol</code>包封装了很多Unsafe的方法。<br>我们可以通过<code>ClassLayout</code>类来或者我们创建的Java对象在内存中的大小。</p>
<p>通过Unsafe我们可以对对象的内存直接进行操作。<br>假设我们创建一个int类型的数组，每个元素的值是他Index的位置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        nums[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这种写法是常规的写法。<br>我们也可以用Unsafe。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用反射获得Unsafe实例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Field field = Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) field.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>  i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            unsafe.putInt(nums, (<span class="keyword">long</span>) i * Unsafe.ARRAY_INT_INDEX_SCALE + Unsafe.ARRAY_INT_BASE_OFFSET, i);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>Unsafe实例我们需要通过反射获得，直接获得会抛出异常。<br>ARRAY_INT_BASE_OFFSET表示数组对象的第一个元素在内存中的位置。<br>ARRAY_INT_INDEX_SCALE表示每一个真正的元素的数据中的占据空间。<br>这些变量都在Unsafe中，还有许多，对应byte数组，long数组等。</p>
<p>同样的，只要能获得对象的地址，那么我们就可以对任意的对象进行写入。<br>我们尝试在Object对象中写入两个Long元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用反射获得Unsafe实例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Field field = Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) field.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line">        System.out.println(object);</span><br><span class="line">        <span class="keyword">int</span> size  = ClassLayout.parseClass(Object.class).instanceSize();</span><br><span class="line">        System.out.println(<span class="string">"size: "</span> + size); <span class="comment">// 16</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 把Object写为两个long</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        unsafe.putLong(object, <span class="number">0L</span>, <span class="number">13L</span>);</span><br><span class="line">        unsafe.putLong(object, (<span class="keyword">long</span>) SizeOf.SIZE_OF_LONG, <span class="number">19L</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(unsafe.getLong(object, <span class="number">0L</span>)); <span class="comment">// 13</span></span><br><span class="line">        System.out.println(unsafe.getLong(object, (<span class="keyword">long</span>)SizeOf.SIZE_OF_LONG)); <span class="comment">// 19</span></span><br><span class="line"></span><br><span class="line">        System.out.println(object); <span class="comment">// upe</span></span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，这样Object对象就是<strong>不可用</strong>了。<br>如果我们强行输出的话，会抛出空指针异常。</p>
<p>同样的，我们可以对对象进行设值，这个时候我们可以借助ClassLayout封装好的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get set...</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"Person&#123;"</span>);</span><br><span class="line">            sb.append(<span class="string">"name='"</span>).append(name).append(<span class="string">'\''</span>);</span><br><span class="line">            sb.append(<span class="string">", age="</span>).append(age);</span><br><span class="line">            sb.append(<span class="string">'&#125;'</span>);</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        ClassLayout personClassLayout = ClassLayout.parseClass(Person.class);</span><br><span class="line">        <span class="keyword">int</span> size = personClassLayout.instanceSize();</span><br><span class="line">        System.out.println(<span class="string">"size: "</span> + size);</span><br><span class="line">        System.out.println(<span class="string">"header size: "</span> + personClassLayout.headerSize());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 得到所有的field的信息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        SortedSet&lt;FieldLayout&gt; fields = personClassLayout.fields();</span><br><span class="line">        <span class="keyword">for</span> (FieldLayout layout : fields) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (layout.name()) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"name"</span>:</span><br><span class="line">                    unsafe.putObject(person, ((<span class="keyword">long</span>) layout.offset()), <span class="string">"Zhu"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"age"</span>:</span><br><span class="line">                    unsafe.putInt(person, ((<span class="keyword">long</span>) layout.offset()), <span class="number">20</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(person); <span class="comment">// Person&#123;name='Zhu', age=20&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>总之，这就给了一个类似于利用大对象的内存配合Unsafe直接操作内存的方法做一个内存池的思路</strong></p>
<h2 id="Slices"><a href="#Slices" class="headerlink" title="Slices"></a>Slices</h2><p>我们无法直接创建Slice类，可以通过Slices类提供的很多的静态方法来进行创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Slice <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>; </span><br><span class="line"><span class="comment">//利用这个方法我们可以直接创建一个容量为capacity的Slice，底层就是创建了一个byte[capacity]的数组，不过这个对象是在堆内的</span></span><br><span class="line"><span class="function">Slice <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>;</span><br><span class="line"><span class="comment">//利用这个方法我们可以在堆外创建一块内存，底层是使用的nio的ByteBuffer.allocateDirect</span></span><br></pre></td></tr></table></figure>
<p>创建了Slice之后，就可以往里面添加元素了。<br>在Presto中最重要的两个用法就是FixedWidthBlock和VariableWidthBlock了。<br>创建者两种Block运用他的Builder类FixedWidthBlockBuilder和VariableWidthBlockBuilder类。</p>
<h3 id="FixedWidthBlockBuilder"><a href="#FixedWidthBlockBuilder" class="headerlink" title="FixedWidthBlockBuilder"></a>FixedWidthBlockBuilder</h3><p><img src="/images/presto-slice/FixedBlock.png" alt=""></p>
<p>定长的Block，所以会固定一个FixedSize，然后底层就是一个byte数组。<br>不管我们往里面写什么，只要一个entry的长度是FixedSize就行。<br>同时这个不提供自动扩展内存的功能，当超出大小时，会抛出异常。</p>
<h3 id="VariableWidthBlockBuilder"><a href="#VariableWidthBlockBuilder" class="headerlink" title="VariableWidthBlockBuilder"></a>VariableWidthBlockBuilder</h3><p><img src="/images/presto-slice/varBlock.png" alt=""><br>变长的Block，没有固定的大小，所以需要一个额外的数组记录指定entry的位置<br>同时在每次增加之前会确保内存空间足够，如果不够会进行自动扩容。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Presto/">Presto</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Guava库学习之Collections" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/15/Guava库学习之Collections/" class="article-date">
      <time datetime="2018-07-15T08:30:29.000Z" itemprop="datePublished">2018-07-15</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/15/Guava库学习之Collections/">Guava库学习之Collections</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Collections应该是最最常用的了</p>
<h2 id="MultiMap"><a href="#MultiMap" class="headerlink" title="MultiMap"></a>MultiMap</h2><p>MultiMap是一个接口，形象的用JDK中的形式解释就是<code>Map&lt;K, Collection&lt;V&gt;&gt;</code></p>
<p>MultiMap有很多的实现类  </p>
<h3 id="HashMultiMap"><a href="#HashMultiMap" class="headerlink" title="HashMultiMap"></a>HashMultiMap</h3><p>需要注意的是，HashMultimap每个key对应的value的集合是一个Set<br>所以下面这个输出是</p>
<blockquote>
<p>{World=[2], Hello=[1, 3]}</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Multimap&lt;String, Integer&gt; multimap = HashMultimap.create();</span><br><span class="line">multimap.put(<span class="string">"Hello"</span>, <span class="number">1</span>);</span><br><span class="line">multimap.put(<span class="string">"World"</span>, <span class="number">2</span>);</span><br><span class="line">multimap.put(<span class="string">"Hello"</span>, <span class="number">3</span>);</span><br><span class="line">multimap.put(<span class="string">"Hello"</span>, <span class="number">3</span>);</span><br><span class="line">System.out.println(multimap);</span><br></pre></td></tr></table></figure>
<h3 id="LinkedListMultimap"><a href="#LinkedListMultimap" class="headerlink" title="LinkedListMultimap"></a>LinkedListMultimap</h3><p>上面的value是个Set集合，但是如果我们需要是个List集合呢<br>就可以使用LinkedListMultimap这个方法<br>输出</p>
<blockquote>
<p>{Hello=[1, 3, 3], World=[2]}</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Multimap&lt;String, Integer&gt; multimap = LinkedListMultimap.create();</span><br><span class="line">multimap.put(<span class="string">"Hello"</span>, <span class="number">1</span>);</span><br><span class="line">multimap.put(<span class="string">"World"</span>, <span class="number">2</span>);</span><br><span class="line">multimap.put(<span class="string">"Hello"</span>, <span class="number">3</span>);</span><br><span class="line">multimap.put(<span class="string">"Hello"</span>, <span class="number">3</span>);</span><br><span class="line">System.out.println(multimap);</span><br></pre></td></tr></table></figure>
<h2 id="Immutable-Collections"><a href="#Immutable-Collections" class="headerlink" title="Immutable Collections"></a>Immutable Collections</h2><p>在原生的JDK中，似乎并没有想严格的区分可变集合和不可变集合。<br>但是如果你阅读过Effective Java的话，里面在<strong>第十五条</strong>有提到不可变的对象的好处</p>
<ul>
<li>不可变的类比可变类更加易于设计、实现和使用</li>
<li>不可变对象本质上是线程安全的，它们不要求同步<ul>
<li>首先作为Map的key等这种场景，肯定是适用的</li>
<li>因为无法修改，所以在多线程下的迭代不会抛出异常</li>
</ul>
</li>
</ul>
<p>就像String推荐作为Map的key一样，String天生是不可变类，易用且不会出现什么问题。</p>
<p>那么怎么理解不可变集合类的用法呢<br>个人觉得就像<code>StringBuilder</code>和<code>String</code>的用法一样</p>
<h3 id="ImmutableList"><a href="#ImmutableList" class="headerlink" title="ImmutableList"></a>ImmutableList</h3><p>创建不可变的<code>List</code><br>同时这个类的声明中还带有<code>RandomAccess</code>接口<br>所以底层是使用了Array来存储元素</p>
<p>如果不清楚我们需要多少元素，可以先创建一个builder<br><strong>builder()</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">arrayList.add(<span class="string">"Hello"</span>);</span><br><span class="line">arrayList.add(<span class="string">"World"</span>);</span><br><span class="line">arrayList.add(<span class="string">"Java"</span>);</span><br><span class="line"></span><br><span class="line">ImmutableList.Builder&lt;String&gt; stringBuilder = ImmutableList.&lt;String&gt;builder()</span><br><span class="line">    .add(<span class="string">"Hello"</span>)</span><br><span class="line">    .add(<span class="string">"world"</span>);</span><br><span class="line">    .addAll(arrayList);</span><br><span class="line">stringBuilder.add(<span class="string">"Java"</span>);</span><br><span class="line">ImmutableList&lt;String&gt; strings = stringBuilder.build();</span><br></pre></td></tr></table></figure></p>
<p><strong>of()</strong><br>或者我们可以直接调用<code>of</code>方法如果我们知道已经知道成员变量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImmutableList&lt;String&gt; list = ImmutableList.of(<span class="string">"Hello"</span>, <span class="string">"World"</span>, <span class="string">"Java"</span>);</span><br></pre></td></tr></table></figure></p>
<p>因为ImmutableList是实现了List接口，所以我们这样也行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = ImmutableList.of(<span class="string">"Hello"</span>, <span class="string">"World"</span>, <span class="string">"Java"</span>);</span><br></pre></td></tr></table></figure></p>
<p>如果我们拿到的是List方法，那么他的企图修改List的方法已经被标记为<code>@Deprecated</code><br>并且如果强行调用会抛出<strong><code>UnsupportedOperationException</code></strong></p>
<p><strong>copyOf()</strong><br>如果我们已经有了一个List，想要根据他来创建一个不可变的List<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">arrayList.add(<span class="string">"Hello"</span>);</span><br><span class="line">arrayList.add(<span class="string">"World"</span>);</span><br><span class="line">arrayList.add(<span class="string">"Java"</span>);</span><br><span class="line">ImmutableList&lt;String&gt; immutableList = ImmutableList.copyOf(arrayList);</span><br></pre></td></tr></table></figure></p>
<p><strong>sortedCopyOf()</strong><br>之前的<code>List</code>是可以进行<code>Collections.sort()</code>方法进行修改的<br>但是<code>ImmutableList</code>是不可变的，所以不可以进行<code>sort</code>，或者说在<code>build</code>完成之前是不可以进行<code>sort</code>的<br>那么我们可以调用<code>sortedCopyOf()</code>方法进行构建<br>那么如果我使用的是<code>Builder</code>方法进行构建，可不可以在<code>build()</code>之前对里面的元素进行排序呢？<br>似乎没看到方法。</p>
<h3 id="ImmutableSet"><a href="#ImmutableSet" class="headerlink" title="ImmutableSet"></a>ImmutableSet</h3><p>其实和上面的ImmutableList差不是很多</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Guava/">Guava</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-数据库Join算法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/15/数据库Join算法/" class="article-date">
      <time datetime="2018-07-14T16:00:00.000Z" itemprop="datePublished">2018-07-15</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/15/数据库Join算法/">数据库Join算法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h2 id="NestedLoop-Join"><a href="#NestedLoop-Join" class="headerlink" title="NestedLoop Join"></a>NestedLoop Join</h2><h2 id="Hash-Join"><a href="#Hash-Join" class="headerlink" title="Hash Join"></a>Hash Join</h2><h2 id="Merge-Join"><a href="#Merge-Join" class="headerlink" title="Merge Join"></a>Merge Join</h2><h2 id="Index-Join"><a href="#Index-Join" class="headerlink" title="Index Join"></a>Index Join</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-presto执行流程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/10/presto执行流程/" class="article-date">
      <time datetime="2018-07-09T16:00:00.000Z" itemprop="datePublished">2018-07-10</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/10/presto执行流程/">Presto执行流程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="整体概念"><a href="#整体概念" class="headerlink" title="整体概念"></a>整体概念</h2><h3 id="statement"><a href="#statement" class="headerlink" title="statement"></a>statement</h3><p>statement语句就是我们输入的sql语句  </p>
<h3 id="query"><a href="#query" class="headerlink" title="query"></a>query</h3><p>查询执行，和statement的区别可以理解为一个是抽象的，一个是具体的。<br>presto接收到一个statement，会进行解析，然后生成具体的查询计划。<br>一个查询是有多个worker之间的stages组成的</p>
<h3 id="Stage"><a href="#Stage" class="headerlink" title="Stage"></a>Stage</h3><p>查询的执行阶段  </p>
<ul>
<li>Source Stage 从数据源读取数据</li>
<li>Fixed Stage 中间阶段的Stage，从上游读取数据，执行计算，然后发送给下游</li>
<li>Single Stage 也称Root Stage，汇总最终的数据，发送给Coodinator</li>
<li>Coordiantor_Only 用于执行DDL或者DML语句中的表结构更改之类  </li>
</ul>
<h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><ul>
<li>Stage是抽象的查询计划，由Coordinator进行划分</li>
<li>Task则是进行了具象划分，当需要传递到Worker上时，就封装为Task请求过去</li>
<li>一个Stage可以被分解为多个Task在不同的节点并发执行，每个Task的功能是一样的</li>
</ul>
<h3 id="exchange"><a href="#exchange" class="headerlink" title="exchange"></a>exchange</h3><p>stage之间的数据交换</p>
<ul>
<li>OutPutbuffer  生产数据的通过OutPutbuffer发送给下游</li>
<li>Exchange Client 接收上游数据</li>
</ul>
<h3 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h3><ul>
<li>Task的划分，一个Task可分为多个Driver并行执行  </li>
<li>Driver通过Pipeline串联多个Operator</li>
</ul>
<h3 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h3><ul>
<li>代表对数据的一种具体操作  </li>
<li>以page为最小的处理单位  <ul>
<li>LimitOperator</li>
<li>OrderByOperator</li>
</ul>
</li>
</ul>
<h3 id="Split"><a href="#Split" class="headerlink" title="Split"></a>Split</h3><ul>
<li>大的数据集中的一个小的子集 </li>
<li>分配给Task的数据单位</li>
<li>当Presto执行一个查询的时候，首先会从Coordinator得到一个表对应的所有的Split，</li>
<li>然后Presto就会根据查询执行计划，选择合适的节点运行相应的Task处理Split  </li>
</ul>
<h3 id="page"><a href="#page" class="headerlink" title="page"></a>page</h3><p>最小的处理单元<br>一个page对象包含多个block对象，而每个block对象是一个字节数组，存储一个字段的若干行  </p>
<h2 id="presto-cli"><a href="#presto-cli" class="headerlink" title="presto-cli"></a>presto-cli</h2><p>presto-cli和server之间使用restful接口传递信息  </p>
<p><code>--server localhost:8080 --catalog mysql --schema mv</code><br>这个localhost:8080就是coodinator暴露出去的rest接口。  </p>
<p>其中cli使用的io.airline库用来进行cli参数的传递之类的工作<br>整个presto的依赖注入使用了guice库。</p>
<p>整个客户端的参数在com.facebook.presto.cli中  </p>
<p>首先进行了参数的解析生成了一个com.facebook.presto.cli.Console对象之后。<br>调用run方法<br>判断执行方式是–execute还是file还是console，执行不同的策略。   </p>
<p>如果是console，则继续进入到runConsole方法中。<br>在<code>String line = reader.readLine(commandPrompt);</code>中等待我们的输入  </p>
<p>假设我们输入了<code>show tables</code><br>则进入<code>process(queryRunner, split.statement(), outputFormat, tableNameCompleter::populateCache, true);</code>中  </p>
<p>首先进行了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">finalSql = preprocessQuery(</span><br><span class="line">		Optional.ofNullable(queryRunner.getSession().getCatalog()),</span><br><span class="line">        Optional.ofNullable(queryRunner.getSession().getSchema()),</span><br><span class="line">        sql);</span><br></pre></td></tr></table></figure></p>
<p>得到一个finalSql。<br>// 这个finalSql就是加上了Catalog和Schema。<br>不准确，不知道做了啥，好像是把catalog和schema设置到了什么环境变量里。</p>
<p>下面就是开始执行sql<br><code>Query query = queryRunner.startQuery(finalSql)</code><br>然后就会通过http发请求发送给coordinator获取结果<br><code>boolean success = query.renderOutput(System.out, outputFormat, interactive);</code><br>其中结果的获取是循环的，并不是一次性的<br>参见<code>StatementClientV1.advance()</code>方法  这个方法就是循环的发送查询结果的请求，等待数据的到来。</p>
<p>请求是通过okhttp发送给coodinator。<br>接口的话是statement。<br><code>return newStatementClient(client, session, query);</code><br>在<code>StatementClientV1</code>这个class中<br>构造函数<br><code>StatementClientV1(OkHttpClient httpClient, ClientSession session, String query)</code><br>其中的query，就是<code>show tables; select * from table_name;</code>这种。</p>
<p>路由是<br><code>url = url.newBuilder().encodedPath(&quot;/v1/statement&quot;).build();</code><br>方法是POST</p>
<p>提交是在<br><code>JsonResponse.execute(QUERY_RESULTS_CODEC, httpClient, request);</code>中；</p>
<p><code>/v1/statement</code>的路由在<code>coordinator</code>的<br><code>com.facebook.presto.server.protocol.StatementResource</code>中</p>
<p>server把这个query请求放在一个Map中<br><code>queries.put(query.getQueryId(), query);</code><br>然后进行toResponse的时候，把queryId发送给cli，cli要获取下面的信息就要使用这个queryId。<br>@Path(“{queryId}/{token}”)<br>这个路由就是用来进行下面结果的get的<br>queryId就是提交请求的时候返回的。<br>token貌似是记录当前数据传输到那个阶段的意思。<br>因为这儿有这么一段<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (token &lt; resultId.get()) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> WebApplicationException(Response.Status.GONE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>小于的话，大概是表示这段数据已经传输过的意思。</p>
<p>在new Query的时候，<br><code>submissionFuture = new QuerySubmissionFuture(queryId, query, sessionContext, queryManager);</code>   </p>
<p>这个<code>QuerySubmissionFuture</code>有个<code>submitQuery</code>方法。<br>在<code>submitQuery</code>方法中，执行了<br><code>querySubmissionFuture = queryManager.createQuery(queryId, sessionContext, this.query);</code><br>这个<code>queryManager</code>是一个<code>com.facebook.presto.execution.SqlQueryManager</code>的实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListenableFuture&lt;?&gt; createQuery(QueryId queryId, SessionContext sessionContext, String query)</span><br><span class="line">   &#123;</span><br><span class="line">       QueryCreationFuture queryCreationFuture = <span class="keyword">new</span> QueryCreationFuture();</span><br><span class="line">       queryExecutor.submit(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               createQueryInternal(queryId, sessionContext, query);</span><br><span class="line">               queryCreationFuture.set(<span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">               queryCreationFuture.setException(e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">return</span> queryCreationFuture;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>进入到createQueryInternal方法中  </p>
<p>进行了一系列的判断之后<br>执行<br><code>queryExecution = queryExecutionFactory.createQueryExecution(queryId, query, session, statement, parameters);</code>方法  </p>
<p><code>SqlQueryExecution类中</code><br>最后<br><code>// start the query in the background
        resourceGroupManager.submit(statement, queryExecution, selectionContext, queryExecutor);</code></p>
<p><code>InternalResourceGroup.run</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (canRun) &#123;</span><br><span class="line">     startInBackground(query);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startInBackground</span><span class="params">(QueryExecution query)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        checkState(Thread.holdsLock(root), <span class="string">"Must hold lock to start a query"</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (root) &#123;</span><br><span class="line">            runningQueries.add(query);</span><br><span class="line">            InternalResourceGroup group = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">while</span> (group.parent.isPresent()) &#123;</span><br><span class="line">                group.parent.get().descendantRunningQueries++;</span><br><span class="line">                group.parent.get().dirtySubGroups.add(group);</span><br><span class="line">                group = group.parent.get();</span><br><span class="line">            &#125;</span><br><span class="line">            updateEligibility();</span><br><span class="line">            executor.execute(query::start);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>然后执行SqlQueryExecution的start方法<br>SqlQueryExecution表示一次查询执行，用于启动，停止与管理一个查询以及统计这个查询的相关信息<br>SqlQueryQueueManager.submit用于提交SqlQueryExecution到匹配的队列中</p>
<p>先构建plan<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> (SetThreadName ignored = <span class="keyword">new</span> SetThreadName(<span class="string">"Query-%s"</span>, stateMachine.getQueryId())) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// transition to planning</span></span><br><span class="line">               <span class="keyword">if</span> (!stateMachine.transitionToPlanning()) &#123;</span><br><span class="line">                   <span class="comment">// query already started or finished</span></span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// analyze query</span></span><br><span class="line">               PlanRoot plan = analyzeQuery();</span><br><span class="line"></span><br><span class="line">               metadata.beginQuery(getSession(), plan.getConnectors());</span><br><span class="line"></span><br><span class="line">               <span class="comment">// plan distribution of query</span></span><br><span class="line">               planDistribution(plan);</span><br><span class="line"></span><br><span class="line">               <span class="comment">// transition to starting</span></span><br><span class="line">               <span class="keyword">if</span> (!stateMachine.transitionToStarting()) &#123;</span><br><span class="line">                   <span class="comment">// query already started or finished</span></span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// if query is not finished, start the scheduler, otherwise cancel it</span></span><br><span class="line">               SqlQueryScheduler scheduler = queryScheduler.get();</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (!stateMachine.isDone()) &#123;</span><br><span class="line">                   scheduler.start();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">               fail(e);</span><br><span class="line">               throwIfInstanceOf(e, Error.class);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>这其中会进行metadata APi的调用</p>
<p>LogicalPlanner类会根据针对sql语句分析得出的结果，生成逻辑执行计划<br>执行计划是一个数  </p>
<ul>
<li>AggregationNode用于聚合操作的节点</li>
<li>DeleteNode 用于delete操作的节点</li>
<li>ExchangeNode 用于在执行计划中不同的stage之间交换数据的节点，出现在逻辑执行计划中 </li>
<li>FilterNode 过滤节点</li>
<li>IndexJoinNode</li>
<li>。。。</li>
</ul>
<p>生成完plan后，进行<code>metadata.beginQuery(getSession(), plan.getConnectors());</code>操作<br>//TODO</p>
<p>还要进行执行计划的分段<br><code>SubPlan fragmentedPlan = PlanFragmenter.createSubPlans(stateMachine.getSession(), metadata, nodePartitioningManager, plan, false);</code><br>分为以下几个阶段</p>
<ul>
<li>source 就是从数据源读数据，一般分为TableScanNode和ProjectNode</li>
<li>Fixed 包括聚合join等</li>
<li>Single 在单个节点上执行，汇总所有的处理结果  </li>
</ul>
<p>SqlQueryScheduler就是用管理stage的<br>最终执行的<code>SqlQueryScheduler.schedule</code>方法<br>调用了SqlStageExecution.beginbeginScheduling方法。</p>
<p>SqlTaskExecution</p>
<p>java.util.OptionalLong<br>java.util.OptionalInt<br>这几个optional的封装类，可以看看</p>
<p>查询调度<br>每个stage的调度过程是基于split分配Worker Node的过程<br>不同的stage有不同的调度策略  </p>
<p>对于每一个stage，presto都会生成一个对应的SqlStageExecution<br>SqlQueryExecution -&gt; subplan -&gt; StageExecutionPlan -&gt; SqlStageExecution<br>过程详细：</p>
<p>查询调度过程</p>
<p>SqlStageExecution内部组成  </p>
<ul>
<li>NodeScheduler，把task分配给node的核心模块，包含<ul>
<li>NodeManager，获取存活的节点列表 保存在NodeMap中，并且定时更新列表中的内容，缓存时长为5s</li>
<li>NodeMap 存储Presto的节点信息</li>
<li>NodeSchedulerConfig 配置了调度的相关参数</li>
<li>NodeSelector 提供了各个Stage中task分配节点的算法</li>
</ul>
</li>
<li>NodeTaskMap  保存了当前Stage分配的task和节点的映射列表 NodeTasks维护了一个节点对应的task列表  </li>
<li>RemoteTaskFactory 生成RemoteTask的工厂类</li>
<li>StageStateMachine Stage状态的监听类  </li>
</ul>
<p>NodeManager<br>presto调度task时要确保候选node都在可工作状态，NodeManager定义了统一的获取节点入口<br>在CoordinatorModule类中  </p>
<p>NodeSelector<br>NodeScheduler.createNodeSelector方法<br>byHostAndPort和byHost两个集合的目的是为了在Source stage分配split时，实现数据本地性而设置的<br>single和FixedStage节点都是随机选择<br>每个查询请求都会包含一个或者多个Source Stage，一个table会对应一个Source Stage Source stage节点的选择策略与single和fixed完全不同，选择节点的个数是根据组成table的split的个数决定的。 数据本地性不是必须的 需要开参数允许 不然就是随机  </p>
<p>整体查询流程</p>
<ul>
<li>客户端通过coordinator的restful服务发送请求</li>
<li>coordinator解析sql语句生成statement</li>
<li>coordinator根据statement对象生成相应的QueueExecution对象</li>
<li>coordinator把QueueExecution放到队列中并且调度执行</li>
<li>coordinator生成查询执行计划，依次调度各个stage并执行</li>
<li>根据stage的分类分别调度不同的worker阶段执行stage的task任务  </li>
<li>coordiantor向worker提供的restful服务发起请求，启动task，并执行计算  </li>
<li>worker：从上游读取数据并把产生的数据输出给下游task</li>
<li>worker：整个查询输出最终汇总到singe stage worker节点上的task</li>
<li>coordinator：exchangeclient获得single worker节点上的task的输出</li>
<li>coordinator-&gt;cli:周期性的输出结果  </li>
</ul>
<p>presto的查询<br>SqlQueryExecution -&gt; SqlStageEx.. -&gt; SqlTaskExe…<br>每个SqlTaskExe运行在一个worker上  d</p>
<p>看</p>
<p>source task -&gt; scheduleSourcePartitionedNodes()  node split的对应关系<br>            assignSplits</p>
<p>fixed task -&gt; scheduleFixedNodeCount join的hash分配</p>
<p>task的创建</p>
<ul>
<li>HttpRemoteTask</li>
<li><code>/v1/task</code></li>
</ul>
<p>​      </p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Presto的Join细节研究" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/10/Presto的Join细节研究/" class="article-date">
      <time datetime="2018-07-09T16:00:00.000Z" itemprop="datePublished">2018-07-10</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/10/Presto的Join细节研究/">Presto的Join的细节研究</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Presto的Join操作可以说是极为复杂的几个步骤之一<br>加上又无其文档和注释，所以想要了解其细节需要自己去耐心的阅读源码<br>笔者进行了一些研究后，进行了一些自己的理解的整理<br>总结出来，希望对你有用</p>
<h2 id="Partition和Broadcast"><a href="#Partition和Broadcast" class="headerlink" title="Partition和Broadcast"></a>Partition和Broadcast</h2><p>站在整个Presto的体系中，其实数据到底是Partition的分发还是Broadcast的分发在很多环节都有的。<br>那么对于Join而言，Partition肯定是有的。<br>想象对于下面一句话<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> video v <span class="keyword">join</span> <span class="keyword">user</span> u <span class="keyword">on</span> v.user_id = u.id</span><br></pre></td></tr></table></figure></p>
<p>那么对于整个分布式环境而言，完全可以把video和user表的数据根据join的key按照Hash的方式partition到不同的节点上去进行运算<br>这样提高整体的效率是极好的。  </p>
<p>那么Join需要Broadcast吗<br>想象下面一句话<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> video v <span class="keyword">left</span> <span class="keyword">join</span> <span class="keyword">user</span> u <span class="keyword">on</span> v.user_id = u.id</span><br></pre></td></tr></table></figure></p>
<p>那么对于这么一句话，两个表还可以根据key按照Hash的方法partition到不同的节点上去吗？<br>肯定是不行的</p>
<p>我们可以对左边的表进行partition到不同的节点上，但是对于右边的表，partition肯定是不行了，只有进行Broadcast才能保证数据Join出来是正确的结果  </p>
<h2 id="DistributionType"><a href="#DistributionType" class="headerlink" title="DistributionType"></a>DistributionType</h2><p>对应到源码级别的就是在JoinNode中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> DistributionType</span><br><span class="line">&#123;</span><br><span class="line">	PARTITIONED,</span><br><span class="line">	REPLICATED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个<code>DistributionType</code>的意思就是针对于右表而言的分发方式，那么是怎么进行判断的呢<br>在<code>DetermineJoinDistributionType</code>类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> JoinNode.<span class="function">DistributionType <span class="title">getTargetJoinDistributionType</span><span class="params">(JoinNode node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	JoinNode.Type type = node.getType();</span><br><span class="line">	<span class="keyword">if</span> (type == RIGHT || type == FULL || (isDistributedJoinEnabled(session) &amp;&amp; !mustBroadcastJoin(node))) &#123;</span><br><span class="line">		<span class="keyword">return</span> JoinNode.DistributionType.PARTITIONED;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> JoinNode.DistributionType.REPLICATED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">mustBroadcastJoin</span><span class="params">(JoinNode node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> isScalar(node.getRight()) || isCrossJoin(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCrossJoin</span><span class="params">(JoinNode node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> node.getType() == INNER &amp;&amp; node.getCriteria().isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>整体逻辑其实很挺好懂的<br>如果是right join或者是full join，那么右表肯定就是partition的了<br>因为如果是replicated的话，那么肯定就会多出数据来  </p>
<p>如果是cross join的话，那么也只能是replicated的方式了。<br>这个其实也不难理解，想象下面这句sql<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> video v <span class="keyword">join</span> <span class="keyword">user</span> u <span class="keyword">on</span> v.user_id &gt; u.id</span><br></pre></td></tr></table></figure></p>
<p>这种情况和下面这种情况是不同的<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> video v <span class="keyword">join</span> <span class="keyword">user</span> u <span class="keyword">on</span> v.user_id = u.id</span><br></pre></td></tr></table></figure></p>
<p>因为不是等于关系的Join，所以无法根据Hash(user.id) = Hash(u.id)进行partition分发着Join<br>最多只允许一个表去partition，另外一个表是replicated的。<br>那左边的表replicated还是右边的replicated，对于最终的结果是没有区别的。<br>但是在某些情况下并不等同，这个我们留到下面reorder再讲。</p>
<h2 id="Probe和Build"><a href="#Probe和Build" class="headerlink" title="Probe和Build"></a>Probe和Build</h2><p>对于Presto而言，其实只有一个Join模式。<br>那就是<br>pipeLine0: 读左表 -&gt; LookUpJoin<br>pipeLine1: 读右边 -&gt; HashBuilder</p>
<p>其中是pipeLine1的任务先行，把右表读出来，然后建立一个bucket为N的HashTable。<br>pipeLine0的任务是先读取左边的数据，然后等待HashTable的建立完成，然后进行Join操作。</p>
<p>其实更细节的话，在pipeLine0的读左表和建立HashTable是两个pipeLine的操作，中间还需要进行数据Hash到Bucket的操作和建立PageIndex的操作。</p>
<p>那么抽象就是左表是Probe表，然后右表是Build表。<br>永远是右表去Build一个东西，然后左表是Probe数据。</p>
<p>那你发现问题了吗？<br>如果是这种sql语句呢<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> video v <span class="keyword">right</span> <span class="keyword">join</span> <span class="keyword">user</span> u <span class="keyword">on</span> v.user_id = u.id</span><br></pre></td></tr></table></figure></p>
<p>对于right join而言，肯定是右表出的是全量的数据，它如果还是build的话，那肯定是不行的。<br>那么怎么解决呢? 那就是进行Reorder</p>
<h2 id="Merge-Join和NestLoopJoin"><a href="#Merge-Join和NestLoopJoin" class="headerlink" title="Merge Join和NestLoopJoin"></a>Merge Join和NestLoopJoin</h2><p>我们分析下可以发现Presto不管对于什么情况的Join，都是由HashBuilderOperator类去进行Build的。<br>这很容易让人理解为Presto中只有Hash Join。<br>但是理论上Hash Join并不是万能的，有些情况是不能解决的。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> video v <span class="keyword">join</span> <span class="keyword">user</span> u <span class="keyword">on</span> v.user_id &gt; u.is</span><br></pre></td></tr></table></figure></p>
<p>这种情况，肯定是不可能用HashBuilder去完成的，或者更准确点，不能用HashJoin去完成的。<br>那么肯定是需要NestedLoop Join和Merge Join的存在的。<br>这个其实蕴含在了Hash Join的具体的实现中了。<br>只不过是HashBuilderOperator算子的实现是相同的而已。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Presto/">Presto</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Presto的分段源码解析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/10/Presto的分段源码解析/" class="article-date">
      <time datetime="2018-07-09T16:00:00.000Z" itemprop="datePublished">2018-07-10</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/10/Presto的分段源码解析/">Presto的分段源码解析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="先行流程"><a href="#先行流程" class="headerlink" title="先行流程"></a>先行流程</h2><p>在进行分段之前，已经建立好计划数PlanNode，并且已经进行了所有的planOptimizers进行优化。<br>最后在SqlQueryExecution#doAnalyzeQuery()的PlanFragmenter中进行分段。</p>
<h2 id="Stage抽象"><a href="#Stage抽象" class="headerlink" title="Stage抽象"></a>Stage抽象</h2><blockquote>
<p>Stage：unit of work that does not require shuffling  </p>
</blockquote>
<p>这个定义是抄的某个PPT上面的，虽然有点抽象，但是也算是个通俗的原则。</p>
<h2 id="PlanFragmenter"><a href="#PlanFragmenter" class="headerlink" title="PlanFragmenter"></a>PlanFragmenter</h2><p>在进行分段的流程同样是Visit模式，这里的Visit类是PlanFragmenter的内部类Fragmenter。</p>
<p>每一段之间的分段标记符是RemoteSourceNode</p>
<p>在看Fragmenter源码时，我们会发现每遇到一个Remote的ExchangeNode，都会创建一个RemoteSourceNode。在其他的地方都不会创建。<br>所以核心在ExchangeNode上。</p>
<h2 id="AddExchanges"><a href="#AddExchanges" class="headerlink" title="AddExchanges"></a>AddExchanges</h2><p>既然是Remote的ExchangeNode决定了分段，那么这些ExchangeNode是什么时候添加进去的呢。</p>
<p>经过查找发现是在AddExchanges的Optimizer类中。</p>
<p>他在进行优化的时候，也是运用的Visit模式。</p>
<p><strong>聚合数据节点</strong><br>首先在OutputNode的时候，如果Child计划不是运行在一个Node上的，就会加上一个Remote的ExchangeNode，同时Type是GATHER，意思就是Child节点的数据远程传输集中到这个OutPutNode上来。</p>
<p>在SortNode上，如果底层的Child计划不是SingleNode运行的，那么就会加上Remote的ExchangeNode，同时Type是GATHER</p>
<p>在TopNNode上，同样的，如果是FINAL级别的TopN(因为TopN是可以先进行Partition的)，并且Child不是在一个节点上，那么就会创建一个Remote的ExchangeNode，同时Type是GATHER。</p>
<p>同时在LimitNode节点上也是如此。</p>
<p><strong>总结：</strong><br>在进行OutputNode，SortNode，TopNNode，或者是LimitNode这种需要聚合所有节点的数据来进行操作的，如果Child的执行计划是在多个节点上运行，那么就会加上RemoteExchangeNode来进行分段。</p>
<p><strong>Join节点</strong><br>和上面的聚合数据的节点不同，Join节点的处理方式较为复杂。<br><code>select * from video v join user u on v.user_id = u.user_id</code><br>想象这么一句话。<br>如果不考虑数据分布的情况，正常的处理就是</p>
<ul>
<li>随机选择Fixed阶段处理节点</li>
<li>从Source把数据读出</li>
<li>video的数据按照user_id的Hash进行shuffle到Fixed节点</li>
<li>user的数据按照user_id的Hash进行shuffle到Fixed节点</li>
</ul>
<p>但是如果video的原先数据分布就是按照user_id进行分布的呢。<br>那我们这时候，把user的数据按照user_id分到video的节点上。<br>是不是更好呢。</p>
<p>那么这样的话，原先是这样的结构。<br><img src="/images/presto-stage/JoinStage1.png" alt=""></p>
<p>那么就可以变成这样的结构<br><img src="/images/presto-stage/JoinStage2.png" alt=""><br>如果左表特别大的话，那么就省去了很多的shuffle时间。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Presto/">Presto</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Presto和Hive的区别" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/16/Presto和Hive的区别/" class="article-date">
      <time datetime="2018-06-15T16:00:00.000Z" itemprop="datePublished">2018-06-16</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/16/Presto和Hive的区别/">Presto和Hive的区别</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Presto/">Presto</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-行列存储的区别" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/05/行列存储的区别/" class="article-date">
      <time datetime="2018-06-04T16:00:00.000Z" itemprop="datePublished">2018-06-05</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/05/行列存储的区别/">行列存储的区别</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>行列存储的区别，上次在串讲的时候被问到了。<br>因为没有作为具体的分析，所以今天就来全方面的分析一下。</p>
<h2 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h2><p>假设我们拥有一张表，有两个字段为name和age</p>
<table>
<thead>
<tr>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>Zhao</td>
<td>19</td>
</tr>
<tr>
<td>Qian</td>
<td>20</td>
</tr>
<tr>
<td>Sun</td>
<td>21</td>
</tr>
<tr>
<td>Li</td>
<td>22</td>
</tr>
</tbody>
</table>
<p>我们知道磁盘的存储是以页为单位的，每一页的存储地址是连续的<br>下面看看两种不同的存储方式的区别</p>
<h3 id="行式"><a href="#行式" class="headerlink" title="行式"></a>行式</h3><p>那么假设我们以行来存储<br><img src="/images/行列存储/行式存储.png" alt=""><br>简单的看就是每一行的数据都是存在连续的一块地址中</p>
<h3 id="列式"><a href="#列式" class="headerlink" title="列式"></a>列式</h3><p>列式存储根据字段进行切割，把每一个字段的数据存在一起。<br><img src="/images/行列存储/列式存储.png" alt=""></p>
<h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><p>一般来说数据可以进行压缩，以减少存储的空间。<br>对于行式来说，很难进行压缩，因为每个表的字段的类型是不统一的，除非预先确认，否则无法动态的进行压缩。<br>但是列式的就不一样了，每一个字段的类型是确定的，占用大小也是确定的，所以很容易进行压缩。</p>
<p><strong>字典压缩：</strong><br>假设年龄字段基本就是在18到25之间，那么我们可以建立一个字典，如下<br><img src="/images/行列存储/字典压缩.png" alt=""><br>当数据量达到亿级或者千亿级，这样其实是可以省下大量的空间，提高了IO的效率</p>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>对于查询而言，针对不同的查询场景，行式和列式的区别较大。<br>还是以上面的表为例</p>
<p><strong>1.</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(age) <span class="keyword">from</span> <span class="keyword">table</span></span><br></pre></td></tr></table></figure></p>
<p>对于这句Query，如果是行式，我们需要</p>
<ul>
<li>读取<strong>所有</strong>的Page</li>
<li>在内存中<strong>跳着读</strong>所有的age字段的数据</li>
<li>进行计算</li>
</ul>
<p>而对于列式而言</p>
<ul>
<li>读取<strong>存储age字段</strong>的page</li>
<li>在内存中<strong>连续读</strong>取所有的age字段</li>
<li>进行计算</li>
</ul>
<p>显而易见的是肯定是列式的效率更高一点。<br>同时列式还可以更好的利用Cpu Cache的特性加快读取。</p>
<p><strong>Cpu Cache</strong><br>对于Cpu的缓存而言，一次的缓存大小是固定的，比如是64KB，叫做一个Cache Line。<br>那么我们在读age为19的地址的时候，由于那部分凑不齐64KB，那么cpu就是把读取地址附近的数据也读过去以补齐一个Cache Line。<br>那么可能读18的时候，把后面的19，20，21一起读到Cache中了。<br>下面在进行读的时候，就不用继续读取内存了，直接在缓存中拿就行了。</p>
<p><strong>2.</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> age = <span class="number">18</span></span><br></pre></td></tr></table></figure></p>
<p>对于这句Query，假设行式都有索引的情况下<br>行式</p>
<ul>
<li>读取Page1</li>
<li>连续读一块内存</li>
<li>进行计算</li>
</ul>
<p>列式</p>
<ul>
<li>读取Page1和Page2</li>
<li>跳着读出所有指定行的字段数据</li>
<li>计算输出</li>
</ul>
<p>显而易见是行式更好一点。<br>拥有更好的IO效率和更好的运用了Cpu Cache</p>
<p><strong>总结：</strong><br>对于只需要指定字段的查询，那么行式拥有更好的效率</p>
<h2 id="Insert和Update"><a href="#Insert和Update" class="headerlink" title="Insert和Update"></a>Insert和Update</h2><p>对于传统的数据库需求<br>插入和更新的语句较多的情况</p>
<p><strong>行式</strong><br>如果是行式的话，更新只需要找到指定的行的地址，进行修改就行了。<br>对于插入操作，只需要在将上一行的指向下一行的指针修改为插入的那一行的数据就行了。</p>
<p><strong>列式</strong><br>对于列式而言，如果没有开启压缩，那么对于更新操作而言其实和行式的差不多。<br>但是如果开启了压缩，那么还需要解压缩-&gt;修改-&gt;压缩的操作，消耗的时间更久。<br>同样的，对于插入操作，即使没有开启压缩，那么需要的时间也很久，因为指定行的数据是连续的放在一起，在其中插入一个，必然导致后面的会进行后移。</p>
<p><strong>总结：</strong><br>对于行式而言，频繁的插入和更新操作损耗较小<br>对于列式而言，频繁的插入和更新操作损耗较大</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>正常来说</p>
<blockquote>
<p>行式存储比较适合OLTP，列式存储比较适合OLTP</p>
</blockquote>
<p>因为对于OLTP而言</p>
<ul>
<li>查询需要全字段，只需要指定的几行的语句较多</li>
<li>插入，删除，更新操作较多</li>
</ul>
<p>对于OLAP而言</p>
<ul>
<li>插入，删除，更新操作较少</li>
<li>经常只需要相关的列</li>
</ul>
<p>而这恰恰是运用了行式和列式的优点和缺点。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Presto基本概念" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/03/Presto基本概念/" class="article-date">
      <time datetime="2018-06-02T16:00:00.000Z" itemprop="datePublished">2018-06-03</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/03/Presto基本概念/">Presto基本概念</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>Presto是FaceBook开源的一个分布式的Sql Engine。<br>对标的是Impala之类的Mpp引擎。<br>主打的是实时分析和多数据源支持。<br>更详细的介绍和同类框架的对于可以参见 </p>
<p><a href="http://www.ouyangchen.com/wp-content/uploads/2017/03/Meetup-Druid%E5%92%8CKylin%E5%9C%A8%E7%BE%8E%E5%9B%A2%E7%82%B9%E8%AF%84%E7%9A%84%E9%80%89%E5%9E%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5.pdf" target="_blank" rel="noopener">Druid和Kylin在美团点评的选型与实践</a></p>
<p>这个PPT总结的很好</p>
<h2 id="基本抽象"><a href="#基本抽象" class="headerlink" title="基本抽象"></a>基本抽象</h2><h3 id="Stage"><a href="#Stage" class="headerlink" title="Stage"></a>Stage</h3><blockquote>
<p>Stage: unit of work that does not require shuffling</p>
</blockquote>
<p>这是内部分享总结的，仔细品味一下还是很有道理的。<br>正常的讲，Stage就是查询的执行阶段。<br>一般分为四种Stage:</p>
<ul>
<li>Source Stage: 从数据源读取数据</li>
<li>Fixed Stage: 进行中间的运算</li>
<li>Single Stage: 也称为Root Stage，这个是必不可少的，用于最后把数据汇总给Coordinator</li>
<li>Coordinator_Only：用于执行DDL语句等不需要进行计算的语句</li>
</ul>
<h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><p>Task是Stage的具体分布式查询计划，由Coordinator进行划分<br>Task需要通过Http接口发送到具体的Node上去，然后生成对应的本地执行计划<br>一个Stage可以分解为多个<strong>同构</strong>的Task</p>
<h3 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h3><p>Task是发送到本地的执行计划<br>Task被分为<strong>多种</strong>Driver去并发的执行</p>
<h3 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h3><p>一个Driver内包含多个Operator<br>真正操作Page数据的是Operator<br>一个Operator代表一种操作，比如Scan-&gt;读取数据, Filter -&gt; 过滤数据</p>
<h3 id="Block和Page"><a href="#Block和Page" class="headerlink" title="Block和Page"></a>Block和Page</h3><p><img src="/images/presto-basic/page.png" alt=""><br>Block是一张表的一个字段对应的队列<br>Page由Block构成，一个Page包含多个Block，多个Block横切为一行。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Presto/">Presto</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2018 zhy
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
    </div>
</footer>
    </div>
    
    <script src="/js/GithubRepoWidget.js"></script>

<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
             github: ".github-widget a", 
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>