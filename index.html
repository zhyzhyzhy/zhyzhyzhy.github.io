<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="wE7ISC42t3QOT-S-gdbdy_XsP3NB23Xi3alKNWXd0dA">
  <meta name="baidu-site-verification" content="keFN8E7jd3">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Operator Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://blog.lovezhy.cc').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"right","display":"always","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="敌视现实">
<meta property="og:type" content="website">
<meta property="og:title" content="LoveZhy">
<meta property="og:url" content="https://blog.lovezhy.cc/index.html">
<meta property="og:site_name" content="LoveZhy">
<meta property="og:description" content="敌视现实">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LoveZhy">
<meta name="twitter:description" content="敌视现实">

<link rel="canonical" href="https://blog.lovezhy.cc/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>LoveZhy</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125642214-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-125642214-1');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?c1f963571cb3d8a4a5dc82346dc65842";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="LoveZhy" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LoveZhy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>Sitemap</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://blog.lovezhy.cc/2020/08/19/LevelDB源码解析（七）- Compact与Version/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhy">
      <meta itemprop="description" content="敌视现实">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LoveZhy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/19/LevelDB源码解析（七）- Compact与Version/" class="post-title-link" itemprop="url">LevelDB源码解析（七）- Compact与Version</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-19 00:00:00" itemprop="dateCreated datePublished" datetime="2020-08-19T00:00:00+08:00">2020-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-15 18:49:26" itemprop="dateModified" datetime="2020-08-15T18:49:26+08:00">2020-08-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/LevelDB/" itemprop="url" rel="index">
                    <span itemprop="name">LevelDB</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一-Version和VersionSet"><a href="#一-Version和VersionSet" class="headerlink" title="一. Version和VersionSet"></a>一. Version和VersionSet</h2><p>LevelDB算是实现了功能上的多版本控制。利用的是Version和VersionSet两个类。</p>
<p>当然这里的多版本控制肯定不是MVCC那么复杂，这里实现多版本的功能，我理解是为了解决两个操作的冲突：</p>
<ol>
<li>读取和迭代操作</li>
<li>后台异步Compact操作</li>
</ol>
<p>因为LevelDB的compact操作，其实是把多个文件合并成多个文件。</p>
<p>从SSTable那一章节，我们其实知道，一个SSTable就是对应一个文件。</p>
<p>如果我们直接修改文件，那么如果前台有线程正在迭代这个SSTable，就会出现不可预知的错误。</p>
<p>所以这就导致我们的Compact结果的文件需要重新生成，不能动以前的文件。</p>
<p>结果就是每个Level的SSTable集合是随着Compact操作会变化的。</p>
<p>迭代可能是个很长的操作，这中间不能保证不会发生Compact，所以干脆就搞个Version，把每次Compact后的SSTable集合存储起来。</p>
<p>这样迭代的时候，先拿到当前的Version。</p>
<p>DBImpl的Versions和CurrentVersion的初始化变量如下：</p>
<p><img src="/Users/zhuyichen/Documents/我的坚果云/one/积累/孵化成功/LevelDB/images/compact.png" alt="image-20200727162405941" style="zoom:50%;"></p>
<p>我们先来看Version类中存储的变量：</p>
<ol>
<li><p>存储每个Level的SSTable集合：</p>
<p>其中Level0比较特殊，是个单独的类，其他的Level是用了个List存储。</p>
</li>
<li><p>retained表示目前这个Version有没有被正在运行的迭代器使用</p>
</li>
<li><p>剩余的四个都是和Compact有关，下面再讲</p>
</li>
</ol>
<p>再来看看VersionSet中的存储的变量：</p>
<ol>
<li>全局的文件名变量：nextFileNumber，LevelDB创建文件时，根据文件类型和FileNumber就可以定位到具体的File。这里存储这个，类似于数据库中的主键生成器，这里是自增的文件名生成器。</li>
<li>ManifestFileNumber：Manifest文件可以理解为是存储的当前的Version的持久化信息</li>
<li>lastSequence：每个写入的Key，都有一个唯一的序号与之对应</li>
<li>Log模块的配置：logNumber和prevLogNumber，类似于数据库中的WAL模块</li>
<li>activeVersions：当前被使用的Version有哪些</li>
<li>compactPointers：进行Compact时，为了保证每个SSTable都有被Compact机会，这个类似于游标，对于同一个Level，每次新Compact时，选择下一批SSTable。</li>
</ol>
<h2 id="二-Compact"><a href="#二-Compact" class="headerlink" title="二. Compact"></a>二. Compact</h2><p>讲完了Version，还有好多坑没填，主要是因为Version和Compact的联系太紧密了，这里将Compact的流程顺便把Version的坑填了。</p>
<p>LevelDB的Compact的代码在DbImpl的<code>backgroundCompaction()</code>中。</p>
<p>具体的Compact其实分为两步：</p>
<ol>
<li>找出需要compact的SSTable集合</li>
<li>对这些SSTable进行compact</li>
</ol>
<p>其中第一步的代码主要是<code>VersionSet::pickCompaction</code>中，但是触发Compact的情况比较多，这里先不谈了。</p>
<p>直接先来看第二步，我们经过<code>pickCompaction</code>已经找到了需要Compact的SSTable，并且已经生成了<code>Compaction</code>对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Compaction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> level; <span class="comment">// 需要compact的Level</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;FileMetaData&gt; levelInputs; <span class="comment">//level对应的需要compact的SSTable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;FileMetaData&gt; levelUpInputs; <span class="comment">//下一层Level对应的需要compact的SSTable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;FileMetaData&gt; grandparents; <span class="comment">//再下一层level对应的需要compact的SSTable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到了这些文件之后，下一步就是对这么文件进行合并。</p>
<p>合并的过程其实就是多路归并的过程。</p>
<p><img src="/Users/zhuyichen/Documents/我的坚果云/one/积累/孵化成功/LevelDB/images/compact1.png" alt="image-20200727162405941" style="zoom:50%;"></p>
<p><strong>从iterator的视角来看，其实相同的UserKey已经按照seqNum的顺序从大到小排列好了。</strong></p>
<p>所以我们进行迭代的时候，看到的数据大致如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. UserKey = <span class="string">"foo123"</span>, seq = <span class="number">34</span>，Type=VALUE</span><br><span class="line"><span class="number">2</span>. UserKey = <span class="string">"foo123"</span>, seq = <span class="number">20</span>，Type=VALUE</span><br><span class="line"><span class="number">3</span>. UserKey = <span class="string">"foo123"</span>, seq = <span class="number">18</span>，Type=DELETE</span><br><span class="line"><span class="number">4</span>. UserKey = <span class="string">"foo123"</span>, seq = <span class="number">8</span>， Type=VALUE</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>. UserKey = <span class="string">"foo456"</span>, seq = <span class="number">213</span>,Type=DETELE</span><br><span class="line"><span class="number">6</span>. UserKey = <span class="string">"foo456"</span>, seq = <span class="number">200</span>,Type=VALUE</span><br><span class="line"><span class="number">7</span>. UserKey = <span class="string">"foo456"</span>, seq = <span class="number">93</span>, Type=VALUE</span><br></pre></td></tr></table></figure>
<p>这里我们根据UserKey把数据分为两段，第一段是1-4，UserKey都是”foo123”。</p>
<p>同时由于1的SEQ最大，剩余的都要被drop掉。</p>
<p>第二段是5-7，UserKey都是”foo456”。</p>
<p>这里由于5的seq最大，所以6-7需要被drop掉。</p>
<p>但是5能不能drop呢？</p>
<p>能不能drop需要查找下面所有的Level，是否是该UserKey了，如果没有了，那么可以drop，否则需要保留。</p>
<p>所以这里对迭代的每行数据而言，都需要判断是否能drop。</p>
<p>简略代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> hasCurrentUserKey = <span class="keyword">false</span>;</span><br><span class="line">Slice currentUserKey = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">long</span> lastSequenceForKey = MAX_SEQUENCE_NUMBER;</span><br><span class="line"><span class="keyword">while</span> () &#123;</span><br><span class="line">  <span class="keyword">boolean</span> drop = <span class="keyword">false</span>;</span><br><span class="line">  InternalKey key = iterator.peek().getKey();</span><br><span class="line">  <span class="keyword">if</span> (!hasCurrentUserKey || !equals(currentUserKey, key)) &#123;</span><br><span class="line">    <span class="comment">//这个key是第一次出现，类似于上述的1和5</span></span><br><span class="line">    currentUserKey = key.getUserKey();</span><br><span class="line">    hasCurrentUserKey = <span class="keyword">true</span>;</span><br><span class="line">    lastSequenceForKey = MAX_SEQUENCE_NUMBER;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//对特定UserKey的第一次循环不会进入，从第二次开始进入</span></span><br><span class="line">  <span class="comment">//目的也就是保留最早的Seq的记录</span></span><br><span class="line">  <span class="comment">//对于剩余的，一律都丢掉</span></span><br><span class="line">  <span class="keyword">if</span> (lastSequenceForKey &lt;= compactionState.smallestSnapshot) &#123;</span><br><span class="line">    <span class="comment">// Hidden by an newer entry for same user key</span></span><br><span class="line">    drop = <span class="keyword">true</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果 </span></span><br><span class="line">  <span class="comment">//1：这个记录是删除记录</span></span><br><span class="line">  <span class="comment">//2: 且key的seqNum小于compact时分配出去的最小seq（感觉这个永远为true）</span></span><br><span class="line">  <span class="comment">//3: 下面level中没有这个Key了</span></span><br><span class="line">  <span class="comment">//就可以drop，简单讲就是如果第一个就是DELETE记录，且下面的Level没有此UserKey了，那么第一个记录也就可以丢了</span></span><br><span class="line">  <span class="keyword">if</span> (key.getValueType() == DELETION</span><br><span class="line">     &amp;&amp; key.getSequenceNumber() &lt;= compactionState.smallestSnapshot</span><br><span class="line">     &amp;&amp; compactionState.compaction.isBaseLevelForKey(key.getUserKey())) &#123;</span><br><span class="line">    drop = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  lastSequenceForKey = key.getSequenceNumber();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>讲完了合并是，判断某个Key是否能丢，下面就是生成新SSTable的逻辑了。</p>
<p>对于一个KV，如果drop=false，那么建立一个Table，把它放进去就行了。</p>
<p>这里我们主要关注：</p>
<ol>
<li>新的SSTable在哪一层</li>
<li>Version是怎么链接到新的SSTable的</li>
</ol>
<p>顺着源码往下看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!drop) &#123;</span><br><span class="line">  <span class="keyword">if</span> (compactionState.builder == <span class="keyword">null</span>) &#123;</span><br><span class="line">    openCompactionOutputFile(compactionState); <span class="comment">// 1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (compactionState.builder.getEntryCount() == <span class="number">0</span>) &#123;</span><br><span class="line">    compactionState.currentSmallest = key;</span><br><span class="line">  &#125;</span><br><span class="line">  compactionState.currentLargest = key;</span><br><span class="line">  compactionState.builder.add(key.encode(), iterator.peek().getValue());</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (compactionState.builder.getFileSize() &gt;=</span><br><span class="line">      compactionState.compaction.getMaxOutputFileSize()) &#123;</span><br><span class="line">    finishCompactionOutputFile(compactionState); <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>这里的builder就是TableBuilder，如果TableBuilder为空，则新建一个TableBuilder。</p>
<p>openCompactionOutputFile这个方法属于DbIMPL。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openCompactionOutputFile</span><span class="params">(CompactionState compactionState)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">long</span> fileNumber = versions.getNextFileNumber();</span><br><span class="line">  </span><br><span class="line">   compactionState.currentFileNumber = fileNumber;</span><br><span class="line">   compactionState.currentFileSize = <span class="number">0</span>;</span><br><span class="line">   compactionState.currentSmallest = <span class="keyword">null</span>;</span><br><span class="line">   compactionState.currentLargest = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">   File file = <span class="keyword">new</span> File(databaseDir, Filename.tableFileName(fileNumber));</span><br><span class="line">   compactionState.outfile = <span class="keyword">new</span> FileOutputStream(file).getChannel();</span><br><span class="line">   compactionState.builder = <span class="keyword">new</span> TableBuilder(options, compactionState.outfile, <span class="keyword">new</span> InternalUserComparator(internalKeyComparator)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法中主要做了一件事：初始化新的SSTable的一些信息到compactionState中</p>
</li>
<li><p>当当前的SSTable的大小超过阈值时，结束往这个SSTable添加，准备重启一个SSTable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompactionOutputFile</span><span class="params">(CompactionState compactionState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> outputNumber = compactionState.currentFileNumber;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> currentEntries = compactionState.builder.getEntryCount();</span><br><span class="line">        compactionState.builder.finish();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> currentBytes = compactionState.builder.getFileSize();</span><br><span class="line">        compactionState.currentFileSize = currentBytes;</span><br><span class="line">        compactionState.totalBytes += currentBytes;</span><br><span class="line"></span><br><span class="line">        FileMetaData currentFileMetaData = <span class="keyword">new</span>           FileMetaData(compactionState.currentFileNumber,</span><br><span class="line">                compactionState.currentFileSize,</span><br><span class="line">                compactionState.currentSmallest,</span><br><span class="line">                compactionState.currentLargest);</span><br><span class="line">  </span><br><span class="line">        compactionState.outputs.add(currentFileMetaData); <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">        compactionState.builder = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        compactionState.outfile.force(<span class="keyword">true</span>);</span><br><span class="line">        compactionState.outfile.close();</span><br><span class="line">        compactionState.outfile = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentEntries &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            tableCache.newIterator(outputNumber);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法中，我们主要关注位置1的代码，在CompactionState中，有一个List，用来存储新生成的SSTable的信息。</p>
</li>
</ol>
<p>到这儿，合并过程结束了，我们生成了多个SSTable，在CompactionState的outputs中保存</p>
<p>然后进行最后一步：<code>installCompactionResults(compactionState);</code></p>
<p>说到这儿，你可能猜到了，下面就是与Version构建连接关系的过程了。</p>
<p>这里不得不插入一个很重要的类，就是VersionEdit。</p>
<p>我们知道后一个Version和前一个Version的主要区别就是SSTable会发生变化，而VersionEdit就是记录这个变化的。</p>
<p>我们可以理解为 <code>NewVersion = OldVersion + VersionEdit</code>;</p>
<p>而在VersionEdit中，也存有两个变量表示SSTable的增减。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VersionEdit</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Multimap&lt;Integer, FileMetaData&gt; newFiles;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Multimap&lt;Integer, Long&gt; deletedFiles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>installCompactionResults</code>中：主要就是构建VersionEdit。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installCompactionResults</span><span class="params">(CompactionState compact)</span> </span>&#123;</span><br><span class="line">    compact.compaction.addInputDeletions(compact.compaction.getEdit()); <span class="comment">// 1</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> level = compact.compaction.getLevel();</span><br><span class="line">    <span class="keyword">for</span> (FileMetaData output : compact.outputs) &#123;</span><br><span class="line">        compact.compaction.getEdit().addFile(level + <span class="number">1</span>, output); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        versions.logAndApply(compact.compaction.getEdit());</span><br><span class="line">        deleteObsoleteFiles();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>将之前的输入的SSTable放到<code>VersionEdit</code>的<code>deletedFiles</code>中</li>
<li>将新产生的SSTable放到<code>newFiles</code>中，这里可以看到，新生成的SSTable，放到了level+1层，也就是levelUp层，也就是下一层。</li>
</ol>
<p>下面就是进入<code>versions.logAndApply</code>方法了，这个方法属于VersionSet类。</p>
<p>在这个方法中，最重要的有几句话：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logAndApply</span><span class="params">(VersionEdit edit)</span> </span>&#123;</span><br><span class="line">    edit.setLogNumber(logNumber);</span><br><span class="line">    edit.setNextFileNumber(nextFileNumber.get());</span><br><span class="line">    edit.setLastSequenceNumber(lastSequence);</span><br><span class="line"></span><br><span class="line">    Version version = <span class="keyword">new</span> Version(<span class="keyword">this</span>);</span><br><span class="line">    Builder builder = <span class="keyword">new</span> Builder(<span class="keyword">this</span>, current);</span><br><span class="line">    builder.apply(edit);</span><br><span class="line">    builder.saveTo(version);</span><br><span class="line"></span><br><span class="line">    finalizeVersion(version);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> createdNewManifest = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (descriptorLog == <span class="keyword">null</span>) &#123;</span><br><span class="line">            edit.setNextFileNumber(nextFileNumber.get());</span><br><span class="line">            descriptorLog = Logs.createLogWriter(<span class="keyword">new</span> File(databaseDir, Filename.descriptorFileName(manifestFileNumber)), manifestFileNumber);</span><br><span class="line">            writeSnapshot(descriptorLog);</span><br><span class="line">            createdNewManifest = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        Slice record = edit.encode();</span><br><span class="line">        descriptorLog.addRecord(record, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (createdNewManifest) &#123;</span><br><span class="line">            Filename.setCurrentFile(databaseDir, descriptorLog.getFileNumber());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				<span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    appendVersion(version);</span><br><span class="line">    logNumber = edit.getLogNumber();</span><br><span class="line">    prevLogNumber = edit.getPreviousLogNumber();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendVersion</span><span class="params">(Version version)</span> </span>&#123;</span><br><span class="line">    Version previous = current;</span><br><span class="line">    current = version;</span><br><span class="line">    activeVersions.put(version, <span class="keyword">new</span> Object());</span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">        previous.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的逻辑之前已经分析过了，这里再过一遍整体的流程，主要就是2步：</p>
<ol>
<li>根据当前的Version和传入的VersionEdit，构造新的Version。并且在appendVersion方法中替换current。</li>
<li>把VersionEdit写入Manifest文件</li>
</ol>
<p>彩蛋：</p>
<p>前面的多路归并生成新的SSTable的流程，具体的某个SSTable结束Build逻辑其实就是判定新的SSTable的大小。</p>
<p>其实源代码中不然，还有一种情况也会触发SSTable生成结束。</p>
<p>不过这种场景，我想了很久都没想通，这里先抛出来：TODO</p>
<p>写到这里，Version，VersionSet和Compact的耦合流程已经理清楚了。</p>
<p>下面就是重点了，设计到策略方面的：如何选择需要合并的SSTable。</p>
<p>我们知道，LevelDB最多有7层Level，每个Level可能有很多SSTable，其中Level0的SSTable的KV是无序的。</p>
<p>如果我们每次都合并某个Level，或者我们每次都合并每个Level的前几个SSTable，必然会导致KV不均的情况。</p>
<p>同时我们还需要机制触发合并流程，不能是配死的规则。</p>
<p>1 针对Level0的searchMiss的情况</p>
<p>我们知道Level0的SSTable之间的Key并不是顺序的，互相之间可能overlap。那么在查找一个Key的时候，仅仅从最大key和最小key才判断，可能命中好几个SSTable。</p>
<p>比如如下场景的Level0：</p>
<p><img src="/Users/zhuyichen/Documents/我的坚果云/one/积累/孵化成功/LevelDB/images/compact2.png" alt="image-20200727162405941" style="zoom:50%;"></p>
<p>我们要查找19这个Key，会发现符合条件的有3个。</p>
<p>我们要查找22这个Key，会发现符合条件的有2个。</p>
<p>遇到超过一个SSTable需要查找的情况，我们认为情况不太好，但是只谈性质不谈次数就是耍流氓。</p>
<p>所以我们给每个SSTable维护一个计数器，指示SearchMiss的次数。</p>
<p>比如我们搜索20，最终在第二个SSTable中搜索到了，那么第一个SSTable就是SearchMiss了，计数器减一。</p>
<p>但是注意，每次搜索，只会将第一个SearchMiss的SSTable的计数器减一。</p>
<p>比如我们查找19这个Key，最终在第三个SSTable中搜索到了，或者3个都没搜索到，也只会将第一个SSTable的SearchMiss计数器减一。</p>
<p>来看源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Version::get(LookupKey key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LookupResult <span class="title">get</span><span class="params">(LookupKey key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ReadStats readStats = <span class="keyword">new</span> ReadStats(); <span class="comment">// 1</span></span><br><span class="line">        LookupResult lookupResult = level0.get(key, readStats); <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">if</span> (lookupResult == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Level level : levels) &#123;</span><br><span class="line">                lookupResult = level.get(key, readStats); <span class="comment">// 3</span></span><br><span class="line">                <span class="keyword">if</span> (lookupResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        updateStats(readStats.getSeekFileLevel(), readStats.getSeekFile()); <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">return</span> lookupResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateStats</span><span class="params">(<span class="keyword">int</span> seekFileLevel, FileMetaData seekFile)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (seekFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        seekFile.decrementAllowedSeeks(); <span class="comment">// 5</span></span><br><span class="line">        <span class="keyword">if</span> (seekFile.getAllowedSeeks() &lt;= <span class="number">0</span> &amp;&amp; fileToCompact == <span class="keyword">null</span>) &#123;</span><br><span class="line">            fileToCompact = seekFile;   </span><br><span class="line">            fileToCompactLevel = seekFileLevel; <span class="comment">// 6</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>这里的ReadStats保存的是第一个SearchMiss的SSTable。</li>
<li>搜索Level0</li>
<li>搜索Level1往下的，但是这里面因为SSTable都是有序的，所有不会出现SearchMiss的情况，也就是不会更新ReadStats</li>
<li>更新stats，传入的是SearchMiss的SSTable的Level和FileMetaData</li>
<li>在updateStats方法中，将SearchMiss的数值减一，这个值初始为1 &lt;&lt; 30，不是很小其实，这个阈值还是很难达到的，达到了表示有热点Key了。</li>
<li>fileToCompact和fileToCompactLevel是Version的成员变量，在下一个pickCompact时会考虑这两个值。</li>
</ol>
<p>2 根据每个Level的文件个数和字节大小</p>
<p>从Level0到Level7，作为LSM来看的话，越往下的Level的KV数应该是越多的。所以如果中间某个Level的KV数超过某个阈值，就要Compact到下一个Level。</p>
<p>同时Level0因为无序，对他而言，SSTable如果超过一定的个数，也要进行Compact。</p>
<p>总结一下就是，选择下一次的Compact的SSTable：</p>
<ol>
<li>Level0的SSTable个数</li>
<li>其他Level的KV个数，也就是等价于Bytes个数</li>
</ol>
<p>于是我们给每个Level打个分，分越高表示越需要尽快Compact。</p>
<p>在VersionSet的finalizeVersion方法中，就是给每个Level打分，选出下一个需要Compact的Level。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finalizeVersion</span><span class="params">(Version version)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bestLevel = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> bestScore = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; version.numberOfLevels() - <span class="number">1</span>; level++) &#123;</span><br><span class="line">        <span class="keyword">double</span> score;</span><br><span class="line">        <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//level0是根据文件数计算score</span></span><br><span class="line">            score = <span class="number">1.0</span> * version.numberOfFilesInLevel(level) / L0_COMPACTION_TRIGGER;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//其他的level是根据文件总大小计算score</span></span><br><span class="line">            <span class="keyword">long</span> levelBytes = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (FileMetaData fileMetaData : version.getFiles(level)) &#123;</span><br><span class="line">                levelBytes += fileMetaData.getFileSize();</span><br><span class="line">            &#125;</span><br><span class="line">            score = <span class="number">1.0</span> * levelBytes / maxBytesForLevel(level);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (score &gt; bestScore) &#123;</span><br><span class="line">            bestLevel = level;</span><br><span class="line">            bestScore = score;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    version.setCompactionLevel(bestLevel);</span><br><span class="line">    version.setCompactionScore(bestScore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假如我们选出了得分最高的，比如Level3，但是Level3中可能有100个SSTable，具体怎么选择呢？</p>
<p>是固定选择第一个SSTable，但是最后一个，还是中间1个？</p>
<p>或者选择其中的几个？随机几个吗？</p>
<p>LevelDB为为每个Level维护了一个Compact进度的游标，这个变量叫<code>compactPointers</code>，维护在VersionSet和VersionEdit中，因为维护在了VersionEdit中了，所以每次Compact完会写入Manifest文件中，重新启动的时候会恢复出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, InternalKey&gt; compactPointers = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>定义如上，Key是Level的值，Value是具体的InternalKey。</p>
<p>具体流程如下：</p>
<ol>
<li>根据finalizeVersion的结果，找个该Level。</li>
<li>遍历该Level下的所有文件，找到第一个LargestKey大于compactPointers中该Level的Value的SSTable</li>
<li>以这一个SSTable作为Base，寻找Level + 1 层有overlap的SSTable</li>
<li>更新compactPointers该Level的结果，Value更新为pick中的SSTable的LargestKey。下一次查找的时候就是顺位的下一个SSTable。</li>
<li>将这些SSTable进行Compact。</li>
</ol>
<p>这里为什么维护这种游标呢？是让每个SSTable都有机会进行Compact吗？</p>
<p>其实我理解是为了LevelDB中所有的Key的分布在每个Level都更均匀。</p>
<p>如果每次都Compact第一个SSTable，那么所有Key靠前的都会被优先Compact到下一层。</p>
<p>查询的时候很容易就找到了最后一个Level。</p>
<p>维护了这种游标之后，每个Level的Key分布都均匀的向下Compact。</p>
<p>综合上面的两种情况，我们最后可以来看pickCompact方法了，代码比较多，但是如果上面的都理解了，还是比较好懂的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Compaction <span class="title">pickCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span> sizeCompaction = (current.getCompactionScore() &gt;= <span class="number">1</span>); <span class="comment">// 对应上面的第二种触发Compact情况</span></span><br><span class="line">	<span class="keyword">boolean</span> seekCompaction = (current.getFileToCompact() != <span class="keyword">null</span>);<span class="comment">// 对应上面第一种触发情况</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> level;</span><br><span class="line">	List&lt;FileMetaData&gt; levelInputs;</span><br><span class="line">	<span class="keyword">if</span> (sizeCompaction) &#123; <span class="comment">//如果第二种情况满足条件</span></span><br><span class="line">		level = current.getCompactionLevel();</span><br><span class="line">		levelInputs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">		<span class="keyword">for</span> (FileMetaData fileMetaData : current.getFiles(level)) &#123;</span><br><span class="line">      <span class="comment">//下面就是compactPointer找到大于Value的第一个SSTable</span></span><br><span class="line">			<span class="keyword">if</span> (!compactPointers.containsKey(level) ||</span><br><span class="line">					internalKeyComparator.compare(fileMetaData.getLargest(), compactPointers.get(level)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				levelInputs.add(fileMetaData); </span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (levelInputs.isEmpty()) &#123;</span><br><span class="line">			levelInputs.add(current.getFiles(level).get(<span class="number">0</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (seekCompaction) &#123; <span class="comment">//如果第一种情况满足条件</span></span><br><span class="line">		level = current.getFileToCompactLevel();</span><br><span class="line">		levelInputs = ImmutableList.of(current.getFileToCompact());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//都不满足直接返回</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Level0的overlap情况要特殊处理</span></span><br><span class="line">	<span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">		Entry&lt;InternalKey, InternalKey&gt; range = getRange(levelInputs);</span><br><span class="line">		levelInputs = getOverlappingInputs(<span class="number">0</span>, range.getKey(), range.getValue());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Compaction compaction = setupOtherInputs(level, levelInputs);</span><br><span class="line">	<span class="keyword">return</span> compaction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个方法是找到level + 1 和level + 2的overlap的情况</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Compaction <span class="title">setupOtherInputs</span><span class="params">(<span class="keyword">int</span> level, List&lt;FileMetaData&gt; levelInputs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Entry&lt;InternalKey, InternalKey&gt; range = getRange(levelInputs);</span><br><span class="line">	InternalKey smallest = range.getKey();</span><br><span class="line">	InternalKey largest = range.getValue();</span><br><span class="line"></span><br><span class="line">	List&lt;FileMetaData&gt; levelUpInputs = getOverlappingInputs(level + <span class="number">1</span>, smallest, largest);</span><br><span class="line"></span><br><span class="line">	range = getRange(levelInputs, levelUpInputs);</span><br><span class="line">	InternalKey allStart = range.getKey();</span><br><span class="line">	InternalKey allLimit = range.getValue();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//expand，这里看看就好</span></span><br><span class="line">	<span class="keyword">if</span> (!levelUpInputs.isEmpty()) &#123;</span><br><span class="line">		List&lt;FileMetaData&gt; expanded0 = getOverlappingInputs(level, allStart, allLimit);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (expanded0.size() &gt; levelInputs.size()) &#123;</span><br><span class="line">			range = getRange(expanded0);</span><br><span class="line">			InternalKey newStart = range.getKey();</span><br><span class="line">			InternalKey newLimit = range.getValue();</span><br><span class="line"></span><br><span class="line">			List&lt;FileMetaData&gt; expanded1 = getOverlappingInputs(level + <span class="number">1</span>, newStart, newLimit);</span><br><span class="line">			<span class="keyword">if</span> (expanded1.size() == levelUpInputs.size()) &#123;</span><br><span class="line">				smallest = newStart;</span><br><span class="line">				largest = newLimit;</span><br><span class="line">				levelInputs = expanded0;</span><br><span class="line">				levelUpInputs = expanded1;</span><br><span class="line"></span><br><span class="line">				range = getRange(levelInputs, levelUpInputs);</span><br><span class="line">				allStart = range.getKey();</span><br><span class="line">				allLimit = range.getValue();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	List&lt;FileMetaData&gt; grandparents = ImmutableList.of();</span><br><span class="line">	<span class="keyword">if</span> (level + <span class="number">2</span> &lt; NUM_LEVELS) &#123;</span><br><span class="line">		grandparents = getOverlappingInputs(level + <span class="number">2</span>, allStart, allLimit);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Compaction compaction = <span class="keyword">new</span> Compaction(current, level, levelInputs, levelUpInputs, grandparents);</span><br><span class="line"></span><br><span class="line">	compactPointers.put(level, largest); <span class="comment">// 更新游标，重点</span></span><br><span class="line">	compaction.getEdit().setCompactPointer(level, largest);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> compaction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://blog.lovezhy.cc/2020/08/18/LevelDB源码解析（六）- WAL和Log文件/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhy">
      <meta itemprop="description" content="敌视现实">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LoveZhy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/18/LevelDB源码解析（六）- WAL和Log文件/" class="post-title-link" itemprop="url">LevelDB源码解析（六）- WAL和Log文件</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-18 00:00:00" itemprop="dateCreated datePublished" datetime="2020-08-18T00:00:00+08:00">2020-08-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-15 18:48:00" itemprop="dateModified" datetime="2020-08-15T18:48:00+08:00">2020-08-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/LevelDB/" itemprop="url" rel="index">
                    <span itemprop="name">LevelDB</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Log文件初始化：</p>
<p>在DbImpl的构造函数中，申请了一个新的FileNumber，然后对log对象进行了初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> logFileNumber = versions.getNextFileNumber();</span><br><span class="line"><span class="keyword">this</span>.log = Logs.createLogWriter(<span class="keyword">new</span> File(databaseDir, Filename.logFileName(logFileNumber)), logFileNumber);</span><br></pre></td></tr></table></figure>
<p>所以这个Log文件每次启动都会创建一个新的。</p>
<p>写入：</p>
<p>Log的写入也比较简单，每次进行put的时候，将KV序列化特定的格式，然后append进日志系统。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Snapshot <span class="title">writeInternal</span><span class="params">(WriteBatchImpl updates, WriteOptions options)</span> </span>&#123;</span><br><span class="line">  	 <span class="comment">//...</span></span><br><span class="line">     <span class="comment">// Log write</span></span><br><span class="line">     Slice record = writeWriteBatch(updates, sequenceBegin);</span><br><span class="line">     log.addRecord(record, options.sync());     </span><br><span class="line">     <span class="comment">//... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更迭：</p>
<p>在正常的运行中，Log日志会更迭吗？</p>
<p>因为如果不更迭的话，日志会越来越多，单文件可能会越来越多。</p>
<p>同时我们知道Log格式的文件仅仅支持从头开始遍历的，在Recover的时候，从头到尾遍历一个大文件也是个问题。</p>
<p>在<code>makeRoomForWrite</code>中，如果MemTable需要进行Compact的时候，就会强制关闭当前的Log，再创建一个新的Log。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeRoomForWrite</span><span class="params">(<span class="keyword">boolean</span> force)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    log.close();</span><br><span class="line">    <span class="keyword">long</span> logNumber = versions.getNextFileNumber();</span><br><span class="line">    <span class="keyword">this</span>.log = Logs.createLogWriter(<span class="keyword">new</span> File(databaseDir, Filename.logFileName(logNumber)), logNumber);        </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：makeRoomForWrite并不是每次调用都会走到这个逻辑的。</p>
<p>删除：</p>
<p>什么时候删除呢？</p>
<p>前面我们看到每次启动时，会新生成一个新的Log，每次CompactMemTable的时候，也会新生成一个新的，那么旧的什么时候删除呢？</p>
<p>答案在<code>deleteObsoleteFiles</code>方法中。</p>
<p>方法内容如名字，其实这个方法不止删除了旧的Log文件。</p>
<p>这个方法会遍历数据目录下的所有文件，如果是log文件，判断fileNumber是否小于当前的LogFileNumber，如果小于，就可以删除。</p>
<p>了解了内容，我们来想想这个方法会在什么时候调用呢？</p>
<p>前面提到过，每次Compact新的MemTable的时候，都会生成新的Log文件，也就是说，这个Log文件包含了当前MemTable中的内容，也就是未持久化的内容。</p>
<p>如果Compact后，持久化了，自然就不需要这个文件了。</p>
<p>所以在VersionSet::logAndApply后，都会清理旧的Log文件。</p>
<p>因为每次VersionEdit生成后，NewVersion的所有SSTable就已经确定了，新的KV记录则在新的Log日志中，也就不需要再知道旧的Log日志文件是啥了。</p>
<p>recover：</p>
<p>结合了WAL的性质，我们来了解下，recover的内容。</p>
<p>按照理解，Recover时，主要把有内容还是MemTable中，还没持久化到磁盘上，这个时候需要找到这个MemTable对于的Log文件，遍历这个文件内容，再Append一遍就行。</p>
<p>我们结合DbImpl的构造函数一起来看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DbImpl</span><span class="params">(Options options, File databaseDir)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  versions = <span class="keyword">new</span> VersionSet(databaseDir, tableCache, internalKeyComparator); </span><br><span class="line">  <span class="comment">// load  (and recover) current version</span></span><br><span class="line">  versions.recover(); <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">long</span> minLogNumber = versions.getLogNumber();</span><br><span class="line">  <span class="keyword">long</span> previousLogNumber = versions.getPrevLogNumber();</span><br><span class="line">  </span><br><span class="line">  List&lt;File&gt; filenames = Filename.listFiles(databaseDir);</span><br><span class="line">  List&lt;Long&gt; logs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (File filename : filenames) &#123;</span><br><span class="line">    FileInfo fileInfo = Filename.parseFileName(filename);</span><br><span class="line">    <span class="keyword">if</span> (fileInfo != <span class="keyword">null</span> &amp;&amp; fileInfo.getFileType() == FileType.LOG &amp;&amp; ((fileInfo.getFileNumber() &gt;= minLogNumber) || (fileInfo.getFileNumber() == previousLogNumber))) &#123;</span><br><span class="line">      logs.add(fileInfo.getFileNumber());  <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Recover in the order in which the logs were generated</span></span><br><span class="line">  VersionEdit edit = <span class="keyword">new</span> VersionEdit();</span><br><span class="line">  Collections.sort(logs);</span><br><span class="line">  <span class="keyword">for</span> (Long fileNumber : logs) &#123;</span><br><span class="line">    <span class="keyword">long</span> maxSequence = recoverLogFile(fileNumber, edit);  <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">if</span> (versions.getLastSequence() &lt; maxSequence) &#123;</span><br><span class="line">      versions.setLastSequence(maxSequence);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// open transaction log</span></span><br><span class="line">  <span class="keyword">long</span> logFileNumber = versions.getNextFileNumber(); </span><br><span class="line">  <span class="keyword">this</span>.log = Logs.createLogWriter(<span class="keyword">new</span> File(databaseDir, Filename.logFileName(logFileNumber)), logFileNumber);</span><br><span class="line">  edit.setLogNumber(log.getFileNumber());</span><br><span class="line">  <span class="comment">// apply recovered edits</span></span><br><span class="line">  versions.logAndApply(edit); <span class="comment">// 4</span></span><br><span class="line">  <span class="comment">// cleanup unused files</span></span><br><span class="line">  deleteObsoleteFiles(); <span class="comment">// 5 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>读取CURRENT文件执行的Manifest文件，恢复出最后的LogNumber。</li>
<li>这里我不理解为什么Logs是个数组，讲道理每次MemTable都是串行Compact的话，那么Manifest中最后一个VersionEdit中的LogNumber，就是最新的MemTable的内容，不会出现多个文件的情况。</li>
<li>这里的recoverLogFile方法，就是顺序遍历，然后Put进去，但是这里和正常的Put流程不一样，虽然会生成新的SSTable，但是并不会调用VersionSet的logAndApply方法。</li>
<li>这里对Edit进行了LogAndApply，提交到了Manifest中，数据恢复成功</li>
<li>可以清理旧的文件了</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://blog.lovezhy.cc/2020/08/17/LevelDB源码解析（五）- CURRENT和Manifest/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhy">
      <meta itemprop="description" content="敌视现实">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LoveZhy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/17/LevelDB源码解析（五）- CURRENT和Manifest/" class="post-title-link" itemprop="url">LevelDB源码解析（五）- CURRENT和Manifest</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-17 00:00:00" itemprop="dateCreated datePublished" datetime="2020-08-17T00:00:00+08:00">2020-08-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-15 18:47:55" itemprop="dateModified" datetime="2020-08-15T18:47:55+08:00">2020-08-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/LevelDB/" itemprop="url" rel="index">
                    <span itemprop="name">LevelDB</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Manifest文件，简单的看就是当前VersionEdit的持久化信息，其中包含了：</p>
<ol>
<li>Comparator：全局的比较方法</li>
<li>LogNumber：下一个MemTable的WAL日志文件的FileNumber</li>
<li>PreviousLogNumber：已经被废弃，之前版本有用到</li>
<li>NextFileNumber：下一个File的数字</li>
<li>LastSequence：最新的Seq</li>
<li>Compact_Pointer：在Compact一章中统一讲。</li>
<li>Deteted_Files：相对于上一个Version，删除的文件</li>
<li>New_Files：相对于上一个Version，新增的文件</li>
</ol>
<p>以上内容都在<code>VersionEditTag</code>中进行读写。</p>
<p>其中Manifest文件只会存在一个，但是名字中的FileNumber不是一定的，在数据目录下，文件名可能是</p>
<p><code>MANIFEST-000540</code>。个人猜想可能是版本问题导致的。</p>
<p>初始化：</p>
<p>在DbIMPL进行初始化时，会创建VersionSet，在VersionSet的构造函数中，调用了initializeIfNeeded对Manifest进行了初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File currentFile = <span class="keyword">new</span> File(databaseDir, Filename.currentFileName());  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (!currentFile.exists()) &#123; </span><br><span class="line">        VersionEdit edit = <span class="keyword">new</span> VersionEdit(); <span class="comment">// 2</span></span><br><span class="line">        edit.setComparatorName(internalKeyComparator.name());</span><br><span class="line">        edit.setLogNumber(prevLogNumber);    </span><br><span class="line">        edit.setNextFileNumber(nextFileNumber.get()); </span><br><span class="line">        edit.setLastSequenceNumber(lastSequence); </span><br><span class="line"></span><br><span class="line">        LogWriter log = Logs.createLogWriter(<span class="keyword">new</span> File(databaseDir, Filename.descriptorFileName(manifestFileNumber)), manifestFileNumber); <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writeSnapshot(log); <span class="comment">// 4</span></span><br><span class="line">            log.addRecord(edit.encode(), <span class="keyword">false</span>); <span class="comment">// 5</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.close();</span><br><span class="line">        &#125;</span><br><span class="line">        Filename.setCurrentFile(databaseDir, log.getFileNumber()); <span class="comment">// 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>找出名为”CURRENT”文件，前面提到这个文件的内容就是Manifest文件的文件名。</li>
<li>这里CURRENT文件不存在，所以new一个VersionEdit，其中prevLogNumber是0，nextFileNumber是2，lastSeq也是0。</li>
<li>这里的manifestFileNumber文件是1，这里知道为什么nextFileNumber默认是2开始了吧，因为1是ManifestFile的初始化FileNumber</li>
<li>这个方法里，new了一个VersionEdit，基本上什么值也没设，这里不知道为什么要先把这个VersionEdit放进去。</li>
<li>把上面的VersionEdit写入到Manifest中</li>
<li>这里把上面的Manifest文件名，写入CURRENT文件，这个方法中用到了Temp文件。</li>
</ol>
<p>每次Compact过后，就会调用VersionSet的logAndApply方法，把Edit的信息传入，加入到Manifest文件中。</p>
<p>这个方法下面会详细描述。</p>
<p>那么一个疑问就来了，每次Compact后都会往里面Append新的VersionEdit信息，那么这个文件不就会越来越大吗？就像Redis的Compact一样？是不是有什么机制，会导致创建新的Manifest文件，把当前的Version的快照放进去，然后丢弃旧的Manifest文件呢？</p>
<p>答案是有的：其中每次启动后，触发的第一次Compact，会导致旧的Manifest文件被丢弃，生成新的Manifest文件，把当前Version的快照信息放入。</p>
<p>这里其实有个问题的，只有每次重新启动后才会触发，如果一直在运行的话，其实不会触发重新清理的。</p>
<p>虽然在运行中并不会去读取这个Manifest文件，但是下次启动恢复Version信息时，需要从头到尾遍历这个文件，速度可能会很慢。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logAndApply</span><span class="params">(VersionEdit edit)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">boolean</span> createdNewManifest = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (descriptorLog == <span class="keyword">null</span>) &#123; <span class="comment">// 1</span></span><br><span class="line">            edit.setNextFileNumber(nextFileNumber.get());</span><br><span class="line">            descriptorLog = Logs.createLogWriter(<span class="keyword">new</span> File(databaseDir, Filename.descriptorFileName(manifestFileNumber)), manifestFileNumber); <span class="comment">// 2</span></span><br><span class="line">            writeSnapshot(descriptorLog); <span class="comment">// 3</span></span><br><span class="line">            createdNewManifest = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        Slice record = edit.encode();</span><br><span class="line">        descriptorLog.addRecord(record, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (createdNewManifest) &#123;</span><br><span class="line">            Filename.setCurrentFile(databaseDir, descriptorLog.getFileNumber()); <span class="comment">// 4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeSnapshot</span><span class="params">(LogWriter log)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Save metadata</span></span><br><span class="line">    VersionEdit edit = <span class="keyword">new</span> VersionEdit();</span><br><span class="line">    edit.setComparatorName(internalKeyComparator.name());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save compaction pointers</span></span><br><span class="line">    edit.setCompactPointers(compactPointers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save files</span></span><br><span class="line">    edit.addFiles(current.getFiles());</span><br><span class="line"></span><br><span class="line">    Slice record = edit.encode();</span><br><span class="line">    log.addRecord(record, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>descriptorLog除了在这个方法，没有在其他地方被赋值过，所以第一次进来，肯定是null的</li>
<li>创建一个新的Manifest文件</li>
<li>调用writeSnapshot方法，生成VersionEdit，把当前所有的文件写入Manifest文件</li>
<li>设置CURRENT文件，指向新的Manifest文件</li>
</ol>
<p>VersionSet的恢复：</p>
<p>前面提到过一个公式:<code>OldVersion + VersionEdit = NewVersion</code></p>
<p>如果重新启动应用，要恢复到最新的Version，只要把Manifest文件中的VersionEdit全部apply一遍就行了。</p>
<p>方法在<code>VersionSet::recover</code>中，代码浅显易懂，这里就不展开了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://blog.lovezhy.cc/2020/08/16/LevelDB源码解析（四）- SSTable解析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhy">
      <meta itemprop="description" content="敌视现实">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LoveZhy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/16/LevelDB源码解析（四）- SSTable解析/" class="post-title-link" itemprop="url">LevelDB源码解析（四）- SSTable解析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-16 00:00:00" itemprop="dateCreated datePublished" datetime="2020-08-16T00:00:00+08:00">2020-08-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-15 18:47:49" itemprop="dateModified" datetime="2020-08-15T18:47:49+08:00">2020-08-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/LevelDB/" itemprop="url" rel="index">
                    <span itemprop="name">LevelDB</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SSTable就是把一个跳表放入一个文件，但是我们不仅仅是把KeyValue写入文件就结束了，还需要做一些其他的事：</p>
<ol>
<li>写入KV</li>
<li>SSTable的一些元信息，如最大Key，最小Key，KV的个数等。</li>
<li>为KV维护一定的索引，加速查找</li>
<li>进行一定比例的数据压缩</li>
<li>数据完整性校验</li>
</ol>
<p>文件的大体格式如下：</p>
<p><img src="/Users/zhuyichen/Documents/我的坚果云/one/积累/孵化成功/levelDB/images/sstable1.png" alt="image-20200724153236851" style="zoom:50%;"></p>
<p>文件的格式大致分为一个一个的Block</p>
<ol>
<li>Data Block存储的是数据，就是KV。</li>
<li>MetaIndex Block</li>
<li>Index Block</li>
<li>Footer</li>
</ol>
<p>其中在源码中，DataBlock是大头，2和3叫Footer。</p>
<p>MetaIndex在Java版本的实现中是个空Block。</p>
<p>这三个Block的底层实现都是BlockBuilder，BlockBuilder是个存储KV的格式。</p>
<p>个人感觉上其实BlockBuilder是为了DataBlock打造的，而IndexBlock只是恰好复用了一下。</p>
<p>所以下文将的DataBlock其实就是DataBlock的机制。</p>
<h1 id="DataBlock"><a href="#DataBlock" class="headerlink" title="DataBlock"></a>DataBlock</h1><p>BlockBuilder的切分是根据每个Block的大小定的。</p>
<p>当一个Block的大小超过4 * 1024，也就是4M的时候，就会阶段，重启一个Block。</p>
<p>在Block内部的数据，也不是全部堆在一起，而是分为一组一组的，叫做DataGroup（非官方定义，我定的名字）。</p>
<p>分组个数是固定的，根据配置的blockRestartInterval来，默认是16个KV一组。</p>
<p>为什么要进行分组呢，其实这里要提一下写入数据时的压缩。</p>
<p>比如连续的两个Key，”the car”和”the car window”，他们有共同的前缀”the car”，对于这个前缀，我们可以只写入一份来起到数据压缩的效果。</p>
<p>如果我们不分组，那么我们找到一个Key，想知道他原来的Key是啥，得遍历前面所有的Key，这是不现实的。</p>
<p>所以每隔16个KV，我们就从头开始存储，不计算与之前的Key的共同前缀了。</p>
<p>假设我们put三个Entry，三个InternalKey如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. userKey=foo123, seq = <span class="number">3</span>, type=VALUE, value = <span class="string">"fvdnvfdn"</span></span><br><span class="line"><span class="number">2</span>. userKey=foo456, seq = <span class="number">4</span>, type=VALUE, value = <span class="string">"nvjkdfniq"</span></span><br><span class="line"><span class="number">3</span>. userKey=foo444, seq = <span class="number">1</span>, type=VALUE, value = <span class="string">"vfnvfdn233"</span></span><br></pre></td></tr></table></figure>
<p>写SSTable了，真正写入的Bytes，会对InternalKey调用encode方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Slice <span class="title">encode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Slice slice = Slices.allocate(userKey.length() + SIZE_OF_LONG);</span><br><span class="line">    SliceOutput sliceOutput = slice.output();</span><br><span class="line">    sliceOutput.writeBytes(userKey);</span><br><span class="line">    sliceOutput.writeLong(SequenceNumber.packSequenceAndValueType(sequenceNumber, valueType));</span><br><span class="line">    <span class="keyword">return</span> slice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致就是把seq + valueType拼成一个Long类型，和userKey合在了一起。</p>
<p>写入一个KV的操作基本流程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sharedKeyBytes = calculateSharedBytes(key, lastKey);  <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">int</span> nonSharedKeyBytes = key.length() - sharedKeyBytes;    <span class="comment">// 2</span></span><br><span class="line">VariableLengthQuantity.writeVariableLengthInt(sharedKeyBytes, block);     <span class="comment">// 3</span></span><br><span class="line">VariableLengthQuantity.writeVariableLengthInt(nonSharedKeyBytes, block);  <span class="comment">// 4</span></span><br><span class="line">VariableLengthQuantity.writeVariableLengthInt(value.length(), block);     <span class="comment">// 5</span></span><br><span class="line">block.writeBytes(key, sharedKeyBytes, nonSharedKeyBytes);                 <span class="comment">// 6</span></span><br><span class="line">block.writeBytes(value, <span class="number">0</span>, value.length());                               <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<p>这里我们以</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. userKey=foo123, seq = <span class="number">3</span>, type=VALUE, value = <span class="string">"fvdnvfdn"</span></span><br><span class="line"><span class="number">2</span>. userKey=foo456, seq = <span class="number">4</span>, type=VALUE, value = <span class="string">"nvjkdfniq"</span></span><br></pre></td></tr></table></figure>
<p>这两个KeyValue为例，假设<code>foo123</code>已经被写入了，就是<code>lastKey</code>，当前的<code>Key=foo456</code>，其实实际上不是这样的，这里实际拿到的值已经被拼了末尾的Long类型进去，这里为了好解释。同时写入数值也会做相应的转换，这里先忽略。</p>
<ol>
<li><code>foo123</code>和<code>foo456</code>的<code>sharedKeyBytes</code>，也就是开始的<code>foo</code>，数值为3</li>
<li><code>nonSharedKeyBytes</code>也即是<code>456</code>，数值也是3</li>
<li>这一步写入<code>sharedKeyBytes</code>值到文件中，文件内容变成 <code>3</code></li>
<li>写入<code>nonSharedKeyBytes</code>，文件内容为<code>3 | 3</code></li>
<li>写入Value的长度，文件内容变成<code>3 | 3 | 8 |</code></li>
<li>写入非共同前缀的字符也就是456，文件内容为 <code>3 | 3 | 8 | 456 |</code></li>
<li>写入Value的值，文件内容为 <code>3 | 3 | 8 | 456 | fvdnvfdn</code></li>
</ol>
<p>所以整体来看，一个DataGroup中每行Record的数据如下：</p>
<p><img src="/Users/zhuyichen/Documents/我的坚果云/one/积累/孵化成功/levelDB/images/sstable2.png" alt="image-20200724153236851" style="zoom:50%;"></p>
<p>前面提到，每个DataGroup有16行，超过16行之后，就会置LastKey为空，然后下一行开始的sharedKeyBytes就是0，nonSharedKeyBytes就是当前Key的完整长度。</p>
<p>下面就要为每个DataGroup建立索引，记录每个DataGroup的开始位置。</p>
<p>变量<code>restartPositions</code>就是为这个索引准备的。</p>
<p><img src="/Users/zhuyichen/Documents/我的坚果云/one/积累/孵化成功/levelDB/images/sstable3.png" alt="image-20200724153236851" style="zoom:50%;"></p>
<p>第一个DataGroup的位置就是0。</p>
<p>数据写完之后，把每个DataGroup的开始Offset写入到这个Block中。</p>
<p>看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Slice <span class="title">finish</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!finished) &#123;</span><br><span class="line">       finished = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">if</span> (entryCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            restartPositions.write(block); <span class="comment">//1</span></span><br><span class="line">            block.writeInt(restartPositions.size());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">            block.writeInt(<span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> block.slice();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1的源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(SliceOutput sliceOutput)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++) &#123;</span><br><span class="line">        sliceOutput.writeInt(values[index]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据写完后，如果符合压缩条件，还要进行数据压缩。</p>
<p>最后补上Trailer，Trailer就一个Byte和一个Int，Byte表示压缩方式，Int表示对数据的CRC32，用来验证数据完整性。</p>
<p>最后整个DataBlock的数据如下：</p>
<p><img src="/Users/zhuyichen/Documents/我的坚果云/one/积累/孵化成功/levelDB/images/sstable4.png" alt="image-20200724153236851" style="zoom:50%;"></p>
<h1 id="Index-Block"><a href="#Index-Block" class="headerlink" title="Index Block"></a>Index Block</h1><p>Index Block的内容每次写入一个DataBlock都会新增。</p>
<p>这里的代码其实还比较绕人，主要是<code>findShortestSeparator</code>这个方法。</p>
<p>让我们先抛开源代码，想一想对DataBlock建立索引需要记录哪些信息。</p>
<ol>
<li>最大Key，最小Key</li>
<li>KV的个数</li>
<li>StartOffset，EndOffset</li>
</ol>
<p>先来看看最大Key和最小Key的问题。</p>
<p>建立这个索引，主要是为了搜索Key，和最大的比较和最小的比较一下，就能知道是否在这个DataBlock中。</p>
<p>那么</p>
<p>问题1：是否需要最小Key？看源码，是Index Block中并没有存。</p>
<p>问题2：是否需要最大Key？是需要的，不过这里并没有存最大Key是什么。为什么？</p>
<p>或者我们再反问一句，存最大Key的意义是为了记录这个DataBlock里面的数据的边界，如果我们存储比MaxKey稍大一点的Key是不是也是同样的效果呢？</p>
<p>举个例子：MaxKey = helloworld，下一个Block的最小Key是hellozoomer，那么我们存储hellox，是不是可以起到同样的效果呢？</p>
<p>这就是方法<code>findShortestSeparator</code>的功能。</p>
<blockquote>
<p> 算出来一个Key，这个Key &gt; MaxKey &amp;&amp; Key &lt; nextBlockFirstKey。能够起到和MaxKey一样的作用，同时存储时能够压缩空间。</p>
</blockquote>
<p>解决了问题2，我们再来看看问题1，为啥IndexBlock中没有存MinIndex，我感觉是这样</p>
<blockquote>
<p>又不是不能用。</p>
<p>shortestSeparator既可以表示前一个Block的MaxKey，又可以表示后一个Block的MinKey</p>
<p>IndexBlock复用的DataBlock的格式，存储MinKey不太方便</p>
<p>按照上面一个观点，其实一个DataBlock中的KV的个数，在IndexBlock中也没有存储。</p>
</blockquote>
<p>其实如果我们看到后面那个，<code>BlockIterator::seak</code>方法，进行二分查找的时候，是直接seek到那个位置，然后读取出第一个Key的。</p>
<p>下面看看IndexBlock的存储。</p>
<p>每写完一个DataBlock，会返回这个DataBlock的两个数值</p>
<ol>
<li>offset：在文件中的offset</li>
<li>dataSize：block的存储长度</li>
</ol>
<p>在IndexBlock中，将shorttestSeparator作为key，（offset + dataSize)统一作为Value，构造出一个KV的结构放进去。</p>
<p>其实IndexBlock和DataBlock底层都是BlockBuilder的实现。</p>
<p>所以IndexBlock的格式和DataBlock是一样的。</p>
<h1 id="MetaIndex-Block"><a href="#MetaIndex-Block" class="headerlink" title="MetaIndex Block"></a>MetaIndex Block</h1><p>我看Java版本的实现中是个空Block。</p>
<h1 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h1><p>Footer主要是为了记录MetaIndexBlock和IndexBlock的位置信息和一些填充字段和MagicWord。</p>
<p>直接上源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeFooter</span><span class="params">(Footer footer, SliceOutput sliceOutput)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// remember the starting write index so we can calculate the padding</span></span><br><span class="line">    <span class="keyword">int</span> startingWriteIndex = sliceOutput.size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write metaindex and index handles</span></span><br><span class="line">    writeBlockHandleTo(footer.getMetaindexBlockHandle(), sliceOutput); <span class="comment">//1</span></span><br><span class="line">    writeBlockHandleTo(footer.getIndexBlockHandle(), sliceOutput); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// write padding</span></span><br><span class="line">    sliceOutput.writeZero(ENCODED_LENGTH - SIZE_OF_LONG - (sliceOutput.size() - startingWriteIndex));<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// write magic number as two (little endian) integers</span></span><br><span class="line">    sliceOutput.writeInt((<span class="keyword">int</span>) TableBuilder.TABLE_MAGIC_NUMBER); <span class="comment">//4</span></span><br><span class="line">    sliceOutput.writeInt((<span class="keyword">int</span>) (TableBuilder.TABLE_MAGIC_NUMBER &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>写入MetaIndexBlock的位置信息（offset + size）</li>
<li>写入IndexBlock的位置信息（offset + size）</li>
<li>padding</li>
<li>MagicNumber</li>
</ol>
<h1 id="Table的读取和iterator"><a href="#Table的读取和iterator" class="headerlink" title="Table的读取和iterator"></a>Table的读取和iterator</h1><p>对SSTable的读取，需要传入的是SSTable的fileChannel，然后进行初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Table</span><span class="params">(String name, FileChannel fileChannel, Comparator&lt;Slice&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.fileChannel = fileChannel;</span><br><span class="line"></span><br><span class="line">    Footer footer = init();  <span class="comment">// 1</span></span><br><span class="line">    indexBlock = readBlock(footer.getIndexBlockHandle()); <span class="comment">//2</span></span><br><span class="line">    metaindexBlockHandle = footer.getMetaindexBlockHandle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>seek到文件的尾部，把MetaIndexBlock的位置信息 + IndexBlock的位置信息读取出来</li>
<li>把IndexBlock的信息全部读取到内存中来</li>
</ol>
<p>因为DataBlock和IndexBlock的底层都是Block，所以这里先提一下对Block的迭代方法：</p>
<p>实现类是<code>BlockIterator</code></p>
<p>再回顾下之前的Block的格式</p>
<blockquote>
<p> 数据每16个KV一组分为DataGroup，在Block的尾部记录每个DataGroup的位置信息，也就是重启点位置。</p>
</blockquote>
<p>这里的迭代分几个重要的点：</p>
<ol>
<li>重启点的信息可以全部在初始化的时候就反序列化成数组</li>
<li>遍历DataGroup的KV时，需要记录上一个Key的原始值，不然不好恢复出当前Key的值</li>
<li>二分搜索时，转化成对RestartPositions数组的二分搜索</li>
</ol>
<p>讲完了对Block的迭代，下面讲讲对SSTable的迭代</p>
<p>对SSTable的迭代在方法<code>Table::iterator</code>中</p>
<p>方法的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TableIterator <span class="title">iterator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TableIterator(<span class="keyword">this</span>, indexBlock.iterator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>TableIterator</code>的实现思想和Block的迭代的实现思想差不多。</p>
<p>IndexBlock的KV，是对前面DataBlock的【分割Key】+ 位置信息的保存。</p>
<p>所以这里的<code>TableIterator</code>的实现思想是：</p>
<ol>
<li>遍历时，转化成对IndexBlock和DataBlock的双层遍历。</li>
<li>每次读取一个DataBlock在内存中。如果当前DataBlock遍历结束，就从IndexBlock读取下一个DataBlock的位置，seek到那个位置，把下一个DataBlock全部读取到内存中，再对这个DataBlock进行遍历。</li>
<li>二分查找，先对IndexBlock进行二分查找，找到【分割Key】的所在的DataBlock的位置信息，然后再读取改DataBlock，在这个DataBlock中进行二分搜索。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://blog.lovezhy.cc/2020/08/15/LevelDB源码解析（三）- MemTable解析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhy">
      <meta itemprop="description" content="敌视现实">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LoveZhy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/15/LevelDB源码解析（三）- MemTable解析/" class="post-title-link" itemprop="url">LevelDB源码解析（三）- MemTable解析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-15 00:00:00 / Modified: 18:34:02" itemprop="dateCreated datePublished" datetime="2020-08-15T00:00:00+08:00">2020-08-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/LevelDB/" itemprop="url" rel="index">
                    <span itemprop="name">LevelDB</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在LevelDB中，MemTable其实就是在内存中的一个跳表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentSkipListMap&lt;InternalKey, Slice&gt; table;</span><br></pre></td></tr></table></figure>
<p>稍等，为什么table的Key不是<code>String</code>，而是<code>InternalKey</code>？</p>
<h2 id="InternalKey"><a href="#InternalKey" class="headerlink" title="InternalKey"></a>InternalKey</h2><p>我们看看InternalKey的定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalKey</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Slice userKey;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceNumber;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ValueType valueType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面包含三个字段，分别是</p>
<ul>
<li>userKey，就是我们用户增删的key</li>
<li>seqNumber是每一次操作的时候，由LevelDB分配的</li>
<li>ValueType分为两种，分别是删除和新增。</li>
</ul>
<p>我们以这个为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.put(<span class="string">"foo"</span>, <span class="string">"v1"</span>); <span class="comment">//1</span></span><br><span class="line">db.put(<span class="string">"foo"</span>, <span class="string">"v2"</span>); <span class="comment">//2</span></span><br><span class="line">db.delete(<span class="string">"foo"</span>); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<ol>
<li>userKey=foo, seqNum = 1, valueType = VALUE</li>
<li>userKey=foo, seqNum = 2, valueType = VALUE</li>
<li>userKey=foo, seqNum = 3, valueType = DELETE</li>
</ol>
<p>这个时候，我们抛出一个问题，第2条put执行完之后，在MemTable中还有没有internelKey1？</p>
<p>其实这个问题取决于compare方法。</p>
<p>#comparator</p>
<p>新建这个跳表的时候，传入的<code>comparator</code>是<code>InternalKeyComparator</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">InternalKeyComparator#compare</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(InternalKey left, InternalKey right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = userComparator.compare(left.getUserKey(), right.getUserKey()); <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Long.compare(right.getSequenceNumber(), left.getSequenceNumber()); <span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>这里的<code>userComparator</code>是<code>BytewiseComparator</code>，而<code>BytewiseComparator</code>就是简单的比较<code>userKey</code>了。我们三次操作的userKey都是<code>foo</code>，所以这里返回的是<code>0</code></li>
<li>进入第二步，就是比较seqNum，seqNum越大的，InternalKey<strong>越小</strong>，注意，是越小。</li>
</ol>
<p>所以这里问题解答出来了，执行完这三个语句之后，三个InternalKey都会在跳表中，同时seqNum越大的，排名越靠前。</p>
<p>所以这就导致我们对某个userKey进行search的时候，我们的InternelKey的构造，userKey=foo，seq=currentSeq，valueType=Value。</p>
<p>这样查找的时候，使用ceilingEntry方法查找，这个方法查找的是最近的一个和他一样或者比他大的。</p>
<h1 id="compact"><a href="#compact" class="headerlink" title="compact"></a>compact</h1><p>一个MemTable什么时候停止写入，变成磁盘的SSTable呢？</p>
<p>答案在<code>makeRoomForWrite</code>方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memTable.approximateMemoryUsage() &lt;= options.writeBufferSize()</span><br></pre></td></tr></table></figure>
<p>这里的<code>options.writeBufferSize</code>，默认情况下是4 &lt;&lt; 20，也就是4G。</p>
<p>具体的compact逻辑在<code>compactMemTableInternal</code>方法中，使用tableBuilder，建立SSTable后，加入到VersionSet中。</p>
<p>但是具体加入到哪一个Level中呢？一定就是Level0吗？</p>
<p>答案是不一定。看代码，这里的meta就是新生成SSTable。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (meta != <span class="keyword">null</span> &amp;&amp; meta.getFileSize() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    Slice minUserKey = meta.getSmallest().getUserKey();</span><br><span class="line">    Slice maxUserKey = meta.getLargest().getUserKey();</span><br><span class="line">    <span class="keyword">if</span> (base != <span class="keyword">null</span>) &#123;</span><br><span class="line">        level = base.pickLevelForMemTableOutput(minUserKey, maxUserKey);</span><br><span class="line">    &#125;</span><br><span class="line">    edit.addFile(level, meta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体放入哪个Level，是由<code>pickLevelForMemTableOutput</code>这个方法决定的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pickLevelForMemTableOutput</span><span class="params">(Slice smallestUserKey, Slice largestUserKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!overlapInLevel(<span class="number">0</span>, smallestUserKey, largestUserKey)) &#123;</span><br><span class="line">        <span class="comment">// Push to next level if there is no overlap in next level,</span></span><br><span class="line">        <span class="comment">// and the #bytes overlapping in the level after that are limited.</span></span><br><span class="line">        InternalKey start = <span class="keyword">new</span> InternalKey(smallestUserKey, MAX_SEQUENCE_NUMBER, ValueType.VALUE);</span><br><span class="line">        InternalKey limit = <span class="keyword">new</span> InternalKey(largestUserKey, <span class="number">0</span>, ValueType.VALUE);</span><br><span class="line">        <span class="keyword">while</span> (level &lt; MAX_MEM_COMPACT_LEVEL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (overlapInLevel(level + <span class="number">1</span>, smallestUserKey, largestUserKey)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> sum = Compaction.totalFileSize(versionSet.getOverlappingInputs(level + <span class="number">2</span>, start, limit));</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; MAX_GRAND_PARENT_OVERLAP_BYTES) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法中，overlapInLevel方法是判断新SSTable的userKey范围是否与这一层的某个文件userKey的范围重合。</p>
<p>如果不重合，就直接下沉到下一个Level进行查找。</p>
<p>图例：MemTable变成了SSTable，范围是13 ~ 18。那么他会放到哪一层呢？</p>
<p><img src="/Users/zhuyichen/Documents/我的坚果云/one/积累/孵化成功/LevelDB/images/memtable1.png" alt="image-20200709113619550" style="zoom:50%;"></p>
<ol>
<li>首先看Level 0，没有一个SSTable的Key范围和他有重合的</li>
<li>再看Level 1，还是没有一个SSTable的Key范围和他有重合的。</li>
<li>再次下沉到Level 2，发现第一个SSTable与他有重合。</li>
<li>所以新的SSTable会被放到Level 1。</li>
</ol>
<p>最终结果如下图所示。</p>
<p><img src="/Users/zhuyichen/Documents/我的坚果云/one/积累/孵化成功/LevelDB/images/memtable2.png" style="zoom:50%;"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://blog.lovezhy.cc/2020/08/11/LevelDB源码解析（二）- Log文件格式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhy">
      <meta itemprop="description" content="敌视现实">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LoveZhy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/11/LevelDB源码解析（二）- Log文件格式/" class="post-title-link" itemprop="url">LevelDB源码解析（二）- Log文件格式</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-11 00:00:00 / Modified: 19:51:23" itemprop="dateCreated datePublished" datetime="2020-08-11T00:00:00+08:00">2020-08-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/LevelDB/" itemprop="url" rel="index">
                    <span itemprop="name">LevelDB</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>题目的Log指的是文件格式，并不特使某个FileType。</p>
<p>因为LOG文件和Manifest文件都是使用的Log格式的文件进行记录的。</p>
<p>这里主要讲解的是LogWriter和LogReader两个类。</p>
<p>格式镇楼：</p>
<p><img src="/images/leveldb/log文件格式1.png" alt="log文件格式" style="zoom:50%;"></p>
<p>对于LogWriter而言，其实最重要的就是一个接口，Append一个Record：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LogWriter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Writes a stream of chunks such that no chunk is split across a block boundary</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addRecord</span><span class="params">(Slice record, <span class="keyword">boolean</span> force)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且对于LogReader而言，它也是只有一个接口，读取一个Record：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogReader</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Slice <span class="title">readRecord</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然所有的操作都是顺序写，顺序读，没有其他的操作，这里的Log文件格式就可以简单粗暴一点。</p>
<p>文件格式有三个概念要理清：</p>
<ol>
<li><p>Block，这里的Block固定是32K。读取文件时，每次读取一个Block大小，而写入时则需要按照Block的大小进行切分。</p>
</li>
<li><p>Record：就是入参，这里的Record并没有限制大小，所有大小是不定的。</p>
</li>
<li><p>Chunk：文件的写入单位是Chunk，Chunk也没有固定大小，但是不超过一个Block。</p>
<p>Chunk的诞生缘由是因为Block固定是32K，而Record是不限制大小的。如果一个Record太大，超过了32K，则需要切分为多个Chunk，放入两个Block。</p>
</li>
</ol>
<p>由于返回给上层的单位都是Record，所以我们需要知道下一个Record被分成了几个Chunk。</p>
<p>于是每次写入Chunk时，存入一个ChunkType。</p>
<ol>
<li>如果Recod只被切分成一个Chunk，则ChunkType=FULL</li>
<li>如果Record被切分成多个Chunk，则第一个Chunk的Type=First，最后一个Chunk的Type=Last，中间的Chunk的Type=MIDDLE。</li>
</ol>
<p>所以一个Chunk的具体格式如下：</p>
<p><img src="/images/leveldb/log文件格式2.png" alt="log文件格式" style="zoom:50%;"></p>
<p>对于读取而言，其实要做的也比较简单，先不断的去读取Block，然后迭代Block中的Chunk。</p>
<p>同时根据ChunkType的不同，不断迭代的读取Block，拼凑出一个完整的Block。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://blog.lovezhy.cc/2020/08/10/LevelDB源码解析（一）-文件类型与文件名/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhy">
      <meta itemprop="description" content="敌视现实">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LoveZhy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/10/LevelDB源码解析（一）-文件类型与文件名/" class="post-title-link" itemprop="url">LevelDB源码解析（一）- 文件类型与文件名</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-10 00:00:00" itemprop="dateCreated datePublished" datetime="2020-08-10T00:00:00+08:00">2020-08-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-15 18:47:36" itemprop="dateModified" datetime="2020-08-15T18:47:36+08:00">2020-08-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/LevelDB/" itemprop="url" rel="index">
                    <span itemprop="name">LevelDB</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在源码中，特地有个枚举是表示FileType<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> FileType</span><br><span class="line">&#123;</span><br><span class="line">    LOG,</span><br><span class="line">    DB_LOCK,</span><br><span class="line">    TABLE,</span><br><span class="line">    DESCRIPTOR,</span><br><span class="line">    CURRENT,</span><br><span class="line">    TEMP,</span><br><span class="line">    INFO_LOG  <span class="comment">// Either the current one, or an old one</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>DB创建文件时将FileNumber加上特定的后缀作为文件名，FileNumber在内部是一个uint64_t类型，并且全局递增。不同类型的文件的拓展名不同，例如sstable文件是.sst，wal日志文件是.log。LevelDB有以下文件类型：</p>
<h1 id="一-FileNumber"><a href="#一-FileNumber" class="headerlink" title="一. FileNumber"></a>一. FileNumber</h1><p>每个文件的文件名都是一个数字，文件类型用后缀区分，即使是不同的后缀，文件的FileNumer也不会重复。</p>
<p>所以FileNumber类似于数据库的主键一下，自增的进行分配。</p>
<p>在VersionSet的变量中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong nextFileNumber = <span class="keyword">new</span> AtomicLong(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到默认的FileNumber是从2开始的。</p>
<p>为什么不是从1开始，因为1默认是给第一个Manifest文件</p>
<p>如果是重启的应用：</p>
<p>FileNumber会被写到CURRENT文件中，在<code>VersionSet::recover</code>中读取CURRENT文件指向的Manifest文件时恢复出来。</p>
<p>对于recover方法，本质上是CURRENT和Manifest文件，下面再讲。</p>
<h1 id="二-FileType"><a href="#二-FileType" class="headerlink" title="二. FileType"></a>二. FileType</h1><h2 id="2-1-DB-LOCK文件"><a href="#2-1-DB-LOCK文件" class="headerlink" title="2.1 DB_LOCK文件"></a>2.1 DB_LOCK文件</h2><p>这个文件作为文件锁存在，文件名就叫<code>LOCK</code>，里面不会保存任何东西</p>
<h2 id="2-2-TABLE文件"><a href="#2-2-TABLE文件" class="headerlink" title="2.2 TABLE文件"></a>2.2 TABLE文件</h2><p>就是SSTable文件，以<code>.sst</code>结尾</p>
<h2 id="2-3-LOG文件"><a href="#2-3-LOG文件" class="headerlink" title="2.3 LOG文件"></a>2.3 LOG文件</h2><p>类似于WAL文件，以<code>.log</code>结尾</p>
<p>注意，这里指的是文件类型，并不是文件格式。</p>
<p>项目中有个LogWriter类，这个生成的文件的文件格式相同，但是既可以作为LOG文件，又可以作为Manifest文件。</p>
<p>数据目录下只会有一个LOG文件，每次新启时，会将旧的删除，但是文件名中仍然带有FileNumber。</p>
<h2 id="2-4-DESCRIPTOR"><a href="#2-4-DESCRIPTOR" class="headerlink" title="2.4 DESCRIPTOR"></a>2.4 DESCRIPTOR</h2><p>就是常说的Manifest文件，以<code>MANIFEST-</code>开头</p>
<p>每次Compact之后，都会产生当前Compact后SSTable文件的修改VersionEdit。</p>
<p>同时将VersionEdit文件的内容写入Append到Manifest文件。</p>
<h2 id="2-5-CURRENT"><a href="#2-5-CURRENT" class="headerlink" title="2.5 CURRENT"></a>2.5 CURRENT</h2><p>文件名就叫CURRENT，里面的内容是当前的MANIFEST文件的文件名。</p>
<h2 id="2-6-Temp"><a href="#2-6-Temp" class="headerlink" title="2.6 Temp"></a>2.6 Temp</h2><p>因为Log文件和Manifest文件都只有一个，在使用新的覆盖的时候，需要先创建一个Temp文件，然后再rename成真正的。</p>
<h2 id="2-7-INFO-LOG"><a href="#2-7-INFO-LOG" class="headerlink" title="2.7 INFO_LOG"></a>2.7 INFO_LOG</h2><p>似乎没用到</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://blog.lovezhy.cc/2020/07/24/GuavaRateLimiter的理解/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhy">
      <meta itemprop="description" content="敌视现实">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LoveZhy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/24/GuavaRateLimiter的理解/" class="post-title-link" itemprop="url">GuavaRateLimiter的理解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-07-24 00:00:00 / Modified: 19:18:35" itemprop="dateCreated datePublished" datetime="2020-07-24T00:00:00+08:00">2020-07-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Guava/" itemprop="url" rel="index">
                    <span itemprop="name">Guava</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一-介绍"><a href="#一-介绍" class="headerlink" title="一. 介绍"></a>一. 介绍</h2><p>项目中一直在使用RateLimiter进行单机的限流，但是没有去了解他的运作原理，这里就简单记录下，为以后学习Sentinal做铺垫。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/07/24/GuavaRateLimiter的理解/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://blog.lovezhy.cc/2020/06/29/天池比赛经历/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhy">
      <meta itemprop="description" content="敌视现实">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LoveZhy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/29/天池比赛经历/" class="post-title-link" itemprop="url">天池比赛经历</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-29 00:00:00 / Modified: 22:05:21" itemprop="dateCreated datePublished" datetime="2020-06-29T00:00:00+08:00">2020-06-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/天池/" itemprop="url" rel="index">
                    <span itemprop="name">天池</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第一次参加这种类似黑客马拉松的比赛，感觉还是挺新奇的。</p>
<p>虽然成绩不咋好，但是毕竟第一次参加，还是记录一下。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/06/29/天池比赛经历/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://blog.lovezhy.cc/2020/06/10/Java堆外内存理解/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhy">
      <meta itemprop="description" content="敌视现实">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LoveZhy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/10/Java堆外内存理解/" class="post-title-link" itemprop="url">Java堆外内存理解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-10 00:00:00" itemprop="dateCreated datePublished" datetime="2020-06-10T00:00:00+08:00">2020-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-29 22:04:22" itemprop="dateModified" datetime="2020-06-29T22:04:22+08:00">2020-06-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java基础/" itemprop="url" rel="index">
                    <span itemprop="name">Java基础</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这文章算是同事约稿（手动狗头），但是从搜集资料的过程中确实也学到了不少。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/06/10/Java堆外内存理解/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://blog.lovezhy.cc/2020/06/08/论文翻译-What’s-Really-New-with-NewSQL/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhy">
      <meta itemprop="description" content="敌视现实">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LoveZhy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/08/论文翻译-What’s-Really-New-with-NewSQL/" class="post-title-link" itemprop="url">论文翻译-What’s-Really-New-wit-NewSQL</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-08 00:00:00 / Modified: 23:24:40" itemprop="dateCreated datePublished" datetime="2020-06-08T00:00:00+08:00">2020-06-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/论文翻译/" itemprop="url" rel="index">
                    <span itemprop="name">论文翻译</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong><a href="/files/newsql.pdf">论文PDF下载</a></strong></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/06/08/论文翻译-What’s-Really-New-with-NewSQL/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://blog.lovezhy.cc/2020/05/14/论文翻译 - Kafka~a Distributed Messaging System for Log Processing/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhy">
      <meta itemprop="description" content="敌视现实">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LoveZhy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/14/论文翻译 - Kafka~a Distributed Messaging System for Log Processing/" class="post-title-link" itemprop="url">论文翻译 - Kafka~a Distributed Messaging System for Log Processing</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-14 00:00:00" itemprop="dateCreated datePublished" datetime="2020-05-14T00:00:00+08:00">2020-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-17 15:57:24" itemprop="dateModified" datetime="2020-05-17T15:57:24+08:00">2020-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/论文翻译/" itemprop="url" rel="index">
                    <span itemprop="name">论文翻译</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文地址：<a href="http://notes.stephenholiday.com/Kafka.pdf" target="_blank" rel="noopener">http://notes.stephenholiday.com/Kafka.pdf</a></p>
<p>太长不看：</p>
<p>相对于JMS等其他的消息系统，Kafka舍弃了很多功能，以达到性能上的提升。</p>
<p>论文讲述了Kafka设计上的取舍，以及提升性能的很多点。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/05/14/论文翻译 - Kafka~a Distributed Messaging System for Log Processing/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://blog.lovezhy.cc/2020/03/16/业务思考-点赞列表怎么做/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhy">
      <meta itemprop="description" content="敌视现实">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LoveZhy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/16/业务思考-点赞列表怎么做/" class="post-title-link" itemprop="url">业务思考-点赞列表怎么做</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-16 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-16T00:00:00+08:00">2020-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-17 23:34:22" itemprop="dateModified" datetime="2020-03-17T23:34:22+08:00">2020-03-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/业务思考/" itemprop="url" rel="index">
                    <span itemprop="name">业务思考</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在小米有品的工作内容也算是和社交有点关系，会有类似微博的点赞，查看点赞列表的功能。<br>这个功能看起来简单，其实做起来一点都不容易。<br>为了避嫌，这里以微博为例，讲一讲自己的思考。<br>类似的，还有关注列表等。这里就简单思考点赞列表。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/03/16/业务思考-点赞列表怎么做/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://blog.lovezhy.cc/2020/03/14/搞懂内存屏障-CPU的演进/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhy">
      <meta itemprop="description" content="敌视现实">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LoveZhy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/14/搞懂内存屏障-CPU的演进/" class="post-title-link" itemprop="url">搞懂内存屏障-CPU的演进</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-14 00:00:00 / Modified: 22:55:28" itemprop="dateCreated datePublished" datetime="2020-03-14T00:00:00+08:00">2020-03-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机基础/" itemprop="url" rel="index">
                    <span itemprop="name">计算机基础</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>内存屏障是随着SMP系统的出现而出现的，也就意味着在单核的机器上，不需要任何的内存屏障。</p>
<p>所以要想理解内存屏障的意义，我们需要知道CPU从单核到多核，究竟修改了什么，需要我们引入内存屏障</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/03/14/搞懂内存屏障-CPU的演进/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://blog.lovezhy.cc/2020/03/14/搞懂内存屏障-指令与JMM/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhy">
      <meta itemprop="description" content="敌视现实">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LoveZhy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/14/搞懂内存屏障-指令与JMM/" class="post-title-link" itemprop="url">搞懂内存屏障-指令与JMM</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-14 00:00:00 / Modified: 22:55:25" itemprop="dateCreated datePublished" datetime="2020-03-14T00:00:00+08:00">2020-03-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机基础/" itemprop="url" rel="index">
                    <span itemprop="name">计算机基础</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前面讲了CPU的演进，提出了StoreBuffer和InvalidateQueue的设计，并且讲解了这两个设计会带来的问题。<br>解决这两个问题就是引入内存屏障：强制刷新StoreBuffer和InvalidateQueue。</p>
<p>这里详细讲讲x86机器上的内存屏障指令与其他隐式的含有内存屏障的指令。<br>然后再聊一聊JMM与内存屏障的对应关系。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/03/14/搞懂内存屏障-指令与JMM/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://blog.lovezhy.cc/2020/03/09/搞懂内存屏障-CPU重排序/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhy">
      <meta itemprop="description" content="敌视现实">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LoveZhy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/09/搞懂内存屏障-CPU重排序/" class="post-title-link" itemprop="url">搞懂内存屏障-CPU重排序</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-09 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-09T00:00:00+08:00">2020-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-14 22:55:31" itemprop="dateModified" datetime="2020-03-14T22:55:31+08:00">2020-03-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机基础/" itemprop="url" rel="index">
                    <span itemprop="name">计算机基础</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我决定写一个系列，从头到尾讲一讲我理解的内存屏障的起源。<br>要想真正理解内存屏障，其实要讲很多的东西。</p>
<p>第一节，先来讲讲CPU的执行与重排序。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/03/09/搞懂内存屏障-CPU重排序/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://blog.lovezhy.cc/2020/03/08/volatile和内存屏障/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhy">
      <meta itemprop="description" content="敌视现实">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LoveZhy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/08/volatile和内存屏障/" class="post-title-link" itemprop="url">volatile和内存屏障</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-08 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-08T00:00:00+08:00">2020-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-14 23:04:57" itemprop="dateModified" datetime="2020-03-14T23:04:57+08:00">2020-03-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机基础/" itemprop="url" rel="index">
                    <span itemprop="name">计算机基础</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>事实上，我很多次以为我懂了volatile的原理，最终都是错误的。<br>关于重排序，CPU，缓存一致性，内存可见性的话题，其实非常复杂。</p>
<p>这篇文章较为混乱，较为详细的可以看笔者的一个系列：</p>
<p><a href="https://blog.lovezhy.cc/2020/03/09/%E6%90%9E%E6%87%82%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C-CPU%E9%87%8D%E6%8E%92%E5%BA%8F/">搞懂内存屏障-CPU重排序</a></p>
<p><a href="https://blog.lovezhy.cc/2020/03/14/%E6%90%9E%E6%87%82%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C-CPU%E7%9A%84%E6%BC%94%E8%BF%9B/">搞懂内存屏障-CPU的演进</a></p>
<p><a href="https://blog.lovezhy.cc/2020/03/14/%E6%90%9E%E6%87%82%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C-%E6%8C%87%E4%BB%A4%E4%B8%8EJMM/">搞懂内存屏障-指令与JMM</a><br>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/03/08/volatile和内存屏障/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </p></div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://blog.lovezhy.cc/2020/03/03/Kafka指南-分区副本/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhy">
      <meta itemprop="description" content="敌视现实">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LoveZhy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/03/Kafka指南-分区副本/" class="post-title-link" itemprop="url">Kafka指南-分区副本详解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-03 00:00:00 / Modified: 22:40:27" itemprop="dateCreated datePublished" datetime="2020-03-03T00:00:00+08:00">2020-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Kafka指南/" itemprop="url" rel="index">
                    <span itemprop="name">Kafka指南</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>分区副本是Kafka中重要的概念。<br>下面我们来详细谈一谈副本相关的概念。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/03/03/Kafka指南-分区副本/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://blog.lovezhy.cc/2020/02/29/Kafka指南-模块与职能划分/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhy">
      <meta itemprop="description" content="敌视现实">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LoveZhy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/29/Kafka指南-模块与职能划分/" class="post-title-link" itemprop="url">Kafka指南-模块与职能划分</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-29 00:00:00 / Modified: 22:27:06" itemprop="dateCreated datePublished" datetime="2020-02-29T00:00:00+08:00">2020-02-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Kafka指南/" itemprop="url" rel="index">
                    <span itemprop="name">Kafka指南</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Kafka的是个复杂的系统，除了基本的Producer，Consumer，Broker外，为了实现完备的功能，Kafka中有许多重要的模块，本文梳理一下这些模块的划分，与他们负责的功能。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/02/29/Kafka指南-模块与职能划分/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://blog.lovezhy.cc/2020/02/23/Kafka指南-源码导入Idea/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhy">
      <meta itemprop="description" content="敌视现实">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LoveZhy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/23/Kafka指南-源码导入Idea/" class="post-title-link" itemprop="url">Kafka指南-源码导入Idea</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-23 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-23T00:00:00+08:00">2020-02-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-29 22:26:36" itemprop="dateModified" datetime="2020-02-29T22:26:36+08:00">2020-02-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Kafka指南/" itemprop="url" rel="index">
                    <span itemprop="name">Kafka指南</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>虽然网上教程很多，但是我依然要写系列<br>因为我踩到的坑有的是网上没有遇到过的</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/02/23/Kafka指南-源码导入Idea/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhy</p>
  <div class="site-description" itemprop="description">敌视现实</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">88</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">60</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhyzhyzhy" title="GitHub → https://github.com/zhyzhyzhy" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhuyichen1017@outlook.com" title="E-Mail → mailto:zhuyichen1017@outlook.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="beian"><a href="http://www.beian.miit.gov.cn" rel="noopener" target="_blank">苏ICP备15058469号 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhy</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  


</body>
</html>
