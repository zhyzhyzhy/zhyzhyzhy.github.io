<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="wE7ISC42t3QOT-S-gdbdy_XsP3NB23Xi3alKNWXd0dA">
  <meta name="baidu-site-verification" content="keFN8E7jd3">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Operator Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://blog.lovezhy.cc').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"right","display":"always","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="前言作为写了好几年Java的人，自然想去深入了解一下JVM的构造，它的具体实现。 Clone了代码，运行了起来，看了《HotSpot实战》和《揭秘Java虚拟机-JVM设计原理与实现》，但是能力一般，水平有限，对JVM还是知之甚少，发现继续研究下去将是一种苦修，要做好看很久代码都毫无进展的准备。但是本人志不在此，还是想去研究分布式与数据库，精力有限，只有暂且放弃JVM的深入研究。 如此直接放弃还是">
<meta name="keywords" content="JVM">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM杂记">
<meta property="og:url" content="https://blog.lovezhy.cc/2019/07/26/JVM杂记/index.html">
<meta property="og:site_name" content="LoveZhy">
<meta property="og:description" content="前言作为写了好几年Java的人，自然想去深入了解一下JVM的构造，它的具体实现。 Clone了代码，运行了起来，看了《HotSpot实战》和《揭秘Java虚拟机-JVM设计原理与实现》，但是能力一般，水平有限，对JVM还是知之甚少，发现继续研究下去将是一种苦修，要做好看很久代码都毫无进展的准备。但是本人志不在此，还是想去研究分布式与数据库，精力有限，只有暂且放弃JVM的深入研究。 如此直接放弃还是">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="https://blog.lovezhy.cc/images/JVM杂记/class文件格式.jpg">
<meta property="og:image" content="https://blog.lovezhy.cc/images/JVM杂记/锁转换.png">
<meta property="og:image" content="https://blog.lovezhy.cc/images/JVM杂记/markword.jpg">
<meta property="og:image" content="https://blog.lovezhy.cc/images/JVM杂记/写屏障.png">
<meta property="og:image" content="https://blog.lovezhy.cc/images/JVM杂记/栈帧结构.png">
<meta property="og:image" content="https://blog.lovezhy.cc/images/JVM杂记/解释器帧.png">
<meta property="og:updated_time" content="2020-02-23T10:30:17.951Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JVM杂记">
<meta name="twitter:description" content="前言作为写了好几年Java的人，自然想去深入了解一下JVM的构造，它的具体实现。 Clone了代码，运行了起来，看了《HotSpot实战》和《揭秘Java虚拟机-JVM设计原理与实现》，但是能力一般，水平有限，对JVM还是知之甚少，发现继续研究下去将是一种苦修，要做好看很久代码都毫无进展的准备。但是本人志不在此，还是想去研究分布式与数据库，精力有限，只有暂且放弃JVM的深入研究。 如此直接放弃还是">
<meta name="twitter:image" content="https://blog.lovezhy.cc/images/JVM杂记/class文件格式.jpg">

<link rel="canonical" href="https://blog.lovezhy.cc/2019/07/26/JVM杂记/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>JVM杂记 | LoveZhy</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125642214-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-125642214-1');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?c1f963571cb3d8a4a5dc82346dc65842";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="LoveZhy" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LoveZhy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>Sitemap</a>

  </li>
        <li class="menu-item menu-item-movie">

    <a href="/movies/index.html" rel="section"><i class="fa fa-fw fa-film"></i>movie</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/index.html" rel="section"><i class="fa fa-fw fa-book"></i>books</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Searching..." spellcheck="false" type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block " lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://blog.lovezhy.cc/2019/07/26/JVM杂记/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhy">
      <meta itemprop="description" content="敌视现实">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LoveZhy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM杂记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-07-26 00:00:00" itemprop="dateCreated datePublished" datetime="2019-07-26T00:00:00+08:00">2019-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-23 18:30:17" itemprop="dateModified" datetime="2020-02-23T18:30:17+08:00">2020-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/07/26/JVM杂记/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/07/26/JVM杂记/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为写了好几年Java的人，自然想去深入了解一下JVM的构造，它的具体实现。</p>
<p>Clone了代码，运行了起来，看了《HotSpot实战》和《揭秘Java虚拟机-JVM设计原理与实现》，但是能力一般，水平有限，对JVM还是知之甚少，发现继续研究下去将是一种苦修，要做好看很久代码都毫无进展的准备。但是本人志不在此，还是想去研究分布式与数据库，精力有限，只有暂且放弃JVM的深入研究。</p>
<p>如此直接放弃还是有点可惜，虽然目前学到的不成体系，但是还是想写一篇Blog记录一下。</p>
<p>所以此博客是上文提到的两本书的摘要+自己的一些学习理解，内容会很散，同时为了省力，摘要部分不特别标出。</p>
<a id="more"></a>
<h2 id="源码目录"><a href="#源码目录" class="headerlink" title="源码目录"></a>源码目录</h2><p>HotSpot源码目录较多，有几个是比较重要的</p>
<ul>
<li>/c1 =&gt; 客户端解释器</li>
<li>/classfile =&gt; Class文件解析</li>
<li>/gc =&gt; gc相关</li>
<li>/interpreter =&gt; C++解释器和模板解释器都在里面</li>
<li>/oops =&gt; Java的类模型，也就是OOP-KLASS模型</li>
<li>/opto =&gt; c2解释器，也就是服务端解释器</li>
<li>/prims =&gt; 供外部程序访问JVM的通道，比如JNI，Perf，JMX等</li>
<li>/runtime =&gt; 运行时模块，包括frame，thread，VMOptions等</li>
<li>/shark =&gt; 基于LLVM实现的JIT编译器</li>
</ul>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>JMM开头的方法，和Memory没关系，指的是Management的意思</p>
<h2 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h2><p>JRockit JVM中命令行选项分为三种</p>
<ul>
<li>系统属性，-D开头</li>
<li>标准选项，-X,-Xms其实我觉得全拼是-X:memory-start?</li>
<li>非标准选项,-XX</li>
</ul>
<h2 id="Class文件解析"><a href="#Class文件解析" class="headerlink" title="Class文件解析"></a>Class文件解析</h2><p>Class文件的解析的代码都在/classfile目录下</p>
<p><img src="/images/JVM杂记/class文件格式.jpg" alt=""></p>
<p>HotSpot构建了一个叫systemDictionary的字典，结构是<code>[class name,class loader] -&gt; class</code>，用来存储系统中已经加载的类，从这个Map中我们可以看到一些类加载器的条件，双亲委派的概念。</p>
<p>在classFileParser.cpp中，宏定义了Class文件开头的MagicWord和Java_Version的对应关系<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JAVA_CLASSFILE_MAGIC              0xCAFEBABE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JAVA_MIN_SUPPORTED_VERSION        45</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JAVA_MAX_SUPPORTED_VERSION        53</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JAVA_MAX_SUPPORTED_MINOR_VERSION  0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JAVA_1_5_VERSION                  49</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JAVA_6_VERSION                    50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JAVA_7_VERSION                    51</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JAVA_8_VERSION                    52</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JAVA_9_VERSION                    53</span></span><br></pre></td></tr></table></figure></p>
<p>文件解析后，各个Class文件是独立的，而各个类之间的联系其实是通过符号引用来串联在一起，JVM在进行符号引用的解析之后，就可以进行类型的相互引用和方法调用</p>
<p>JVM的链接分为三个部分：</p>
<ul>
<li>验证：对方法进行一系列的检查，方法的访问控制，参数和静态类型检查等</li>
<li>准备：为类静态变量分配内存空间，但是不会初始化值</li>
<li>解析：将常量池中的4类符号引用转换为直接引用(用常量池项表示的字符串 -&gt; 实际内存地址)<ul>
<li>类</li>
<li>接口</li>
<li>字段</li>
<li>类方法和接口方法</li>
</ul>
</li>
</ul>
<p>链接完之后就是进行初始化，也就是调用static {}方法</p>
<p>对于方法的链接，运用的是链接解析器，LinkResolver对方法进行解析和查找<br>对一个方法进行解析时，需要对instanceKlass中的method表进行查找，找到目标方法后转换成MethodHandle类型句柄返回<br>对方法的权限检查（public，private这种）是在找到之后进行</p>
<h2 id="runtime模块与Shutdown-Hook"><a href="#runtime模块与Shutdown-Hook" class="headerlink" title="runtime模块与Shutdown Hook"></a>runtime模块与Shutdown Hook</h2><p>runtime模块主要定义HotSpot运行时数据</p>
<p><code>frame.hpp</code>定义了栈帧的结构，包括Java栈帧，C栈帧。</p>
<p><code>destroy_vm</code>的退出流程中，会运行JVM层的关闭钩子函数。<br>这里的关闭钩子函数就是提到的<code>Runtime.getRuntime().addShutdownHook();</code><br>书中提到的File.deleteOnExit方法，也是调用的这个，但是获取方式看起来不太一样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.SharedSecrets.getJavaLangAccess()</span><br><span class="line">            .registerShutdownHook(<span class="number">2</span> <span class="comment">/* Shutdown hook invocation order */</span>,</span><br><span class="line">                <span class="keyword">true</span> <span class="comment">/* register even if shutdown in progress */</span>,</span><br><span class="line">                <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                       runHooks();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure></p>
<p>而且参数也是不止一个，看起来还可以指定顺序<br>但是不管咋样，最后两种方式其实都是调用的<code>Shutdown.add</code>方法<br>Runtime中的调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Shutdown.add(<span class="number">1</span> <span class="comment">/* shutdown hook invocation order */</span>,</span><br><span class="line">               <span class="keyword">false</span> <span class="comment">/* not registered if shutdown in progress */</span>,</span><br><span class="line">               <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                       runHooks();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           );</span><br></pre></td></tr></table></figure></p>
<p>看Order的参数来说的话，其实Runtime的优先级更高，而File.deleteOnExit的优先级第二。</p>
<h2 id="synchronized实现"><a href="#synchronized实现" class="headerlink" title="synchronized实现"></a>synchronized实现</h2><p>synchronized方法或者代码块，会生成两个特殊的字节码  </p>
<ul>
<li>monitorenter  </li>
<li>monitorexit<br>对于解释器而言，具体的执行逻辑在<br><code>intercepter/bytecodeIntercepter.cpp 1803行 JDK9</code><br>也就是<code>CASE(_monitorenter)</code>中<br>具体的实现分为偏向锁，轻量级锁，重量级锁<br>最后会调用<code>InterpreterRuntime::monitorenter</code>方法，这个方法定义在<code>interpreter/interpreterRuntime.cpp</code>中<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">IRT_ENTRY_NO_ASYNC(<span class="keyword">void</span>, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))</span><br><span class="line">	...</span><br><span class="line">  <span class="keyword">if</span> (PrintBiasedLockingStatistics) &#123;</span><br><span class="line">    Atomic::inc(BiasedLocking::slow_path_entry_count_addr());</span><br><span class="line">  &#125;</span><br><span class="line">  Handle h_obj(thread, elem-&gt;obj());</span><br><span class="line">  assert(Universe::heap()-&gt;is_in_reserved_or_null(h_obj()),</span><br><span class="line">         <span class="string">"must be NULL or an object"</span>);</span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="comment">// Retry fast entry if bias is revoked to avoid unnecessary inflation</span></span><br><span class="line">    ObjectSynchronizer::fast_enter(h_obj, elem-&gt;lock(), <span class="literal">true</span>, CHECK);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ObjectSynchronizer::slow_enter(h_obj, elem-&gt;lock(), CHECK);</span><br><span class="line">  &#125;</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>仔细看会使用到<code>ObjectSynchronizer</code>的两个方法，如果使用了偏向锁，那么就是<code>fast_enter</code>，如果不允许偏向锁，那么就是<code>slow_enter</code></p>
<p>在<code>slow_enter</code>的最后，如果还是不行，就会进入锁膨胀的状态，也就是重量级锁</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ObjectSynchronizer::inflate(THREAD,</span><br><span class="line">                            obj(),</span><br><span class="line">                            inflate_cause_monitor_enter)-&gt;enter(THREAD);</span><br></pre></td></tr></table></figure>
<p>这个时候就要用到<code>ObjectMonitor</code>类中的方法，最后还会涉及到<code>ObjectWaiter</code>类，这个类就是设计了一个链表，类似于<code>ReententLock</code>中的等待链表。</p>
<p>最后还是很好奇最终的互斥锁到底是怎么实现的，代码在<code>runtime/mutex.cpp</code>中，仔细看了一下，并没有使用到c语言中的Mutex库，最终还是依赖于CAS实现的。</p>
<p>其实说到底，最后所有的锁都是基于CAS + 链表。</p>
<p>这里有一个概念上的观念，就是<a href="https://stackoverflow.com/questions/1898374/does-the-jvm-create-a-mutex-for-every-object-in-order-to-implement-the-synchron" target="_blank" rel="noopener">https://stackoverflow.com/questions/1898374/does-the-jvm-create-a-mutex-for-every-object-in-order-to-implement-the-synchron</a>该问题中提到的</p>
<blockquote>
<p>Ask: Using only CAS instructions, how do you get the OS scheduler to put a thread to sleep? </p>
<p>Answer: you don’t. You only use CAS to acquire / release the lock in the uninflated / uncontended case. If contention is detected, the locking/unlocking code would then do the relevant thread scheduling syscalls … or whatever.</p>
</blockquote>
<p>如果你查看ReentrentLock的最后将等待的线程放入等待链表中，对线程调用的是<code>LockSupport.park()</code>方法，这是一个native方法，要去源码中找实现，在<code>hotspot/src/os/linux/vm/os_linux.cpp</code>中，可以看到这里为了让线程能够进入os的调度，也就是放弃CPU资源，还是需要进行<code>pthread_cond_wait</code>的调用的。最后对线程的唤醒，还是需要进行notify的。</p>
<p>在synchronized的底层实现中，最后也是进行park，调用的是<code>os::PlatformEvent::park</code>方法，使用的类是</p>
<p><code>class ParkEvent : public os::PlatformEvent</code></p>
<p>所以，(CAS+链表+pthread_mutex)才是真正的实现机制。</p>
<p>而如果是多线程争用的情况，其实最终的目的还是要保证原子释放CPU资源。</p>
<p>说了一堆，其实核心在锁的实现上，基本都放弃了直接使用pthread_mutex的方法，而是运用<strong>CAS的方式进行自旋</strong>，而pthread_mutex的使用仅仅是为了将线程进行操作系统的重新调度。</p>
<p>参考文章：</p>
<ul>
<li><a href="https://github.com/farmerjohngit/myblog/issues/15" target="_blank" rel="noopener">https://github.com/farmerjohngit/myblog/issues/15</a></li>
<li><a href="https://www.jianshu.com/p/c5058b6fe8e5" target="_blank" rel="noopener">https://www.jianshu.com/p/c5058b6fe8e5</a></li>
</ul>
<p>偏向锁<br>这个名词看名字不是那么容易理解，在JRockit中描述为延迟解锁</p>
<p><img src="/images/JVM杂记/锁转换.png" alt=""></p>
<blockquote>
<p>在上图中，有三种锁类型，其中胖锁和瘦锁在之前中介绍过，这里新增了延迟锁，用来解释 锁在大部分情况下都只作用于线程局部场景下的情况。<br>正如之前介绍过的，对象首先是未加锁状态的，然后线程 T1 执行 monitorenter 指令，使 之进入延迟加锁状态。但如果线程 T1 在该对象上执行了 monitorexit 指令，这时系统会假装 已经解锁了，但实际上仍是锁定状态，锁对象的锁字中仍记录着线程 T1 的线程 ID。在此之后， 线程 T1 如果再执行加锁操作，就不用再执行相关操作了。<br>如果另一个线程 T2 试图获取同一个锁，则之前所做“该锁绝大部分被线 T1 程使用”的假 设不再成立，会受到性能惩罚，将锁字中的线程 ID 由线程 T1 的 ID 替换为线程 T2 的。如果这 种情况经常出现，那么可能会禁用该对象作为延迟锁，并将该对象作为普通的瘦锁使用。假设这 是线程 T2 第一次在该对象上调用 monitorenter 指令，则程序会进入瘦锁控制流程。在上图中， 被禁用于延迟解锁的对象用星号(*)做了标记。此时，当线程 T3 试图在某个已被禁用于延迟解 锁的对象上加锁，如果该对象还未被锁定，则此时仍会使用瘦锁。<br>使用瘦锁时，如果竞争激烈，或者在锁对象上调用了 wait 方法或 notify 方法，则瘦锁会 膨胀为胖锁，需要等待队列来处理。从图中可以看到，处于延迟解锁状态的对象直接调用 wait 方法或 notify 方法的话，也会膨胀为胖锁</p>
</blockquote>
<p>单例模式的双重校验锁的实现其实是有问题的，加了volatile能解决问题，但是会带来略微的性能问题</p>
<h2 id="内存-OOP"><a href="#内存-OOP" class="headerlink" title="内存 OOP"></a>内存 OOP</h2><p>虚拟机中内存空间按照内存的用途，可以划分为<strong>堆和非堆</strong></p>
<ul>
<li>堆：用于对象的分配空间</li>
<li>非堆：包括方法区和Code Cache</li>
</ul>
<p>Perf Data区域，有perfMemory模块管理<br>为了支持虚拟机性能监控，在虚拟机中开辟了一块共享内存，专门存储一些性能指标<br>虚拟机使用共享内存方式向外部进程提供了一种通信手段，允许外部监控进程attach至虚拟机进程，从共享内存中读取这些perf Data</p>
<p>oop-klass模型<br>这个感觉是比较重要的点了<br>还是一个老生长谈的问题，why的问题<br>运用C++的基础模型去实现有没有问题呢？<br>其实我感觉是没有问题的，但是相对于C++的模型，Java这种方式，其实主要是更省内存。<br>同一个类的所有对象维护同一个VTable，其次就是和C++的多态方式不同，Java是模型每一个函数都是可以被子类覆盖的，而C++的只有是虚函数才能，换句话说，Java里面每个函数都是虚函数。<br>虚函数暴增的情况下，显然这种方式更加的省内存。<br>//fixMe</p>
<blockquote>
<p>而且我感觉还和Java的类加载机制有关，因为Java的符号引用转换为直接引用的解析过程，是可以再运行中才进行的，如果父类的方法被动态改变了，函数的地址肯定也需要进行相应的改变，而现有子类的对于这个方法的指向，只要改变一次Klass就行。</p>
</blockquote>
<p>在该模型中，Java的method也作为一种OOP存在</p>
<p><img src="/images/JVM杂记/markword.jpg" alt=""></p>
<p>实例对象的创建 分为快速分配和慢速分配  </p>
<ul>
<li>快速分配就是必须是该类已经被加载和正确解析 因为类的解析，就是符号引用变直接引用的过程不一定就是ClassLoader的时候进行，HotSpot是类第一次被使用的时候解析<br>快速分配就是可以在TLAB，就是线程缓存中分配，而不必先分配到Eden区，如果开启了TLAB选项</li>
<li>慢速分配就是需要先解析，然后在Eden区分配</li>
</ul>
<p>对象在内存中的布局，也就是OOP对象，可以分为连续的两部分，也就是MarkWord对象头和实例数据部分<br>而在Klass模型中，存储着对象的每个变量在实例数据部分的偏移量和长度</p>
<p>Klass中，有一个和Java类对应的mirror成员</p>
<p>JVM为每个线程分配一个PC寄存器，在真实机器中，往往提供一个PC寄存器专门用来保存程序运行的指令在内存中的位置，在HotSpot的实现中，为每个线程分配了一个字长的存储空间，以实现类似硬件级的PC寄存器<br>如果当前执行方法不是本地方法，那么PC寄存器就保存的是JVM正在执行的字节码指令的地址，如果是本地方法，那么PC寄存器的值是未定义的，因为本地方法的执行依赖硬件PC寄存器，其值是由操作系统维护</p>
<p>Java虚拟机栈的作用：存储方法执行中的局部变量，中间演算结果以及方法返回结果</p>
<p>JVM允许Java虚拟机栈被实现为固定大小和动态收缩</p>
<ul>
<li><p>固定大小，顾名思义，如果超过，抛出StackOverflowError异常</p>
</li>
<li><p>动态扩展：OOM异常</p>
</li>
</ul>
<p>虚拟机规范对方法区实现的位置并没有明确要求，在HotSpot中，位于永久代中。<br>HotSpot会收集方法区，主要是常量池的收集和类的卸载<br>在HotSpot内部，Java方法也是由一个内部对象表示的，对象的类型是methodOop，是Java方法在JVM内部的表示方式<br>methodOop内部有指向所在类的运行时常量池的指针<br>methodOop内部有个_constMethod指针，类型是constMethodOop，用来存储和定位方法中的只读数据，如字节码，方法引用，方法名，方法签名，异常表等信息</p>
<p>Perf Data区域，有perfMemory模块管理<br>为了支持虚拟机性能监控，在虚拟机中开辟了一块共享内存，专门存储一些性能指标<br>虚拟机使用共享内存方式向外部进程提供了一种通信手段，允许外部监控进程attach至虚拟机进程，从共享内存中读取这些perf Data</p>
<p>Java类的生命周期的第一个阶段，加载，就是为了在JVM内部创建一个与Java类结构对等的数据对象</p>
<p>如果想要破坏双亲委派的机制，自定义类加载器加载核心类库，还是会被拒绝，因为在defineClass方法中，会提供保护，对类名为Java开头的类，直接抛出异常</p>
<p>同样的，类型转换需要两个类都是同一个类加载器加载的，不然会报错，上次那个Dubbo的问题就这样，报错是两个一样的类，无法进行cast</p>
<h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>GC的几个策略</p>
<ul>
<li>GC工作线程：串行还是并行</li>
<li>GC工作线程和应用线程：并发执行还是暂停应用</li>
<li>基本收集算法：压缩，非压缩还是拷贝</li>
</ul>
<p>吞吐量：应用程序运行时间/(应用程序运行时间 + 垃圾收集时间)</p>
<p>HotSpot每个线程在Eden区都有自己的一小块区域，用于TLAB分配<br>通常情况下，系统中有大量连续的内存块可以用来进行分配的话，碰撞指针算法进行分配，效率很高。思路就是记录上一次分配对象的位置，当有新对象要分配的时候，只需要一次移动位置就可以完成内存的分配<br>在TLAB中进行分配，也就是碰撞指针(bump-the-pointer)分配，效率很高</p>
<p>不然就需要全局锁进行在Eden区分配</p>
<p>还有另外一种优化，叫栈上分配</p>
<p>栈上分配需要对方法的对象进行逃逸分析<br>如果局部变量的作用域仅限于方法内部，则JVM直接在栈帧内分配对象，避免在堆中分配<br>但是这里引用R大的话</p>
<blockquote>
<p>嗯但是Oracle/Sun的HotSpot VM从来没在产品里实现过栈上分配，而只实现过它的一种特殊形式——标量替换（scalar replacement）。这俩是不一样的喔。栈上分配还是要分配完整的对象结构，只不过是在栈帧里而不在GC堆里分配；标量替换则不分配完整的对象，直接把对象的字段打散看作方法的局部变量，也就是说标量替换后就没有对象头了，也不需要把该对象的字段打包为一个整体。<br><a href="https://book.douban.com/people/RednaxelaFX/annotation/25847620/" target="_blank" rel="noopener">https://book.douban.com/people/RednaxelaFX/annotation/25847620/</a></p>
</blockquote>
<p>有个类叫GCCause，里面定义了一些枚举，就是引起GC的一些情况<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Cause &#123;</span><br><span class="line"><span class="comment">/* public */</span></span><br><span class="line">_java_lang_system_gc,</span><br><span class="line">_full_gc_alot,</span><br><span class="line">_scavenge_alot,</span><br><span class="line">_allocation_profiler,</span><br><span class="line">_jvmti_force_gc,</span><br><span class="line">_gc_locker,</span><br><span class="line">_heap_inspection,</span><br><span class="line">_heap_dump,</span><br><span class="line">_wb_young_gc,</span><br><span class="line">_wb_conc_mark,</span><br><span class="line">_wb_full_gc,</span><br><span class="line">_update_allocation_context_stats_inc,</span><br><span class="line">_update_allocation_context_stats_full,</span><br><span class="line"></span><br><span class="line"><span class="comment">/* implementation independent, but reserved for GC use */</span></span><br><span class="line">_no_gc,</span><br><span class="line">_no_cause_specified,</span><br><span class="line">_allocation_failure,</span><br><span class="line"></span><br><span class="line"><span class="comment">/* implementation specific */</span></span><br><span class="line"></span><br><span class="line">_tenured_generation_full,</span><br><span class="line">_metadata_GC_threshold,</span><br><span class="line">_metadata_GC_clear_soft_refs,</span><br><span class="line"></span><br><span class="line">_cms_generation_full,</span><br><span class="line">_cms_initial_mark,</span><br><span class="line">_cms_final_remark,</span><br><span class="line">_cms_concurrent_mark,</span><br><span class="line"></span><br><span class="line">_old_generation_expanded_on_last_scavenge,</span><br><span class="line">_old_generation_too_full_to_scavenge,</span><br><span class="line">_adaptive_size_policy,</span><br><span class="line"></span><br><span class="line">_g1_inc_collection_pause,</span><br><span class="line">_g1_humongous_allocation,</span><br><span class="line"></span><br><span class="line">_dcmd_gc_run,</span><br><span class="line"></span><br><span class="line">_last_gc_cause</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>收集算法</p>
<ul>
<li>标记-清除 Mark-Sweep</li>
<li>复制算法 Copying</li>
<li>标记-压缩算法 Mark-Compact</li>
</ul>
<p>堆的类型</p>
<p>不同的收集器可能对应着不同类型的堆</p>
<p><code>CollectedHeap &lt;- ParallelScavengeHeap</code></p>
<p><code>CollectedHeap &lt;- SharedHeap &lt;- G1CollectedHeap</code></p>
<p>CMS的创新之处在于把标记分为两个阶段，初始标记和并发标记</p>
<p>但是引入了新的缺点，就是并发收集失败的问题，在并发标记时，内存使用过度，只有STW，采取线性标记和收集</p>
<p>而且只能由于并发清除的问题，只能进行标记-清除，将产生内存碎片，而新生代由于其特殊性，将产生更多的内存碎片，所以CMS在新生代并不适用，只运用在老年代</p>
<p>安全点</p>
<blockquote>
<p>由于JVM系统运行期间的复杂性，不可能做到随时暂停，因此引入了安全点（safepoint）：程序只有在运行到安全点的时候，才准暂停下来。HotSpot采取主动中断的方式，让执行线程在运行时轮询是否需要暂停的标识，若需要则中断挂起。</p>
</blockquote>
<p>//fixme<br>其实我觉得这里说的不对，应该不是不可能做到随时暂停，而是随时暂停的消耗太大了，因为后面也写到是主动中断的方式，如果在每个字节码后面都插入check是否需要中断的代码，则消耗确实是太大了<br>参考文章：<a href="https://www.jianshu.com/p/c79c5e02ebe6" target="_blank" rel="noopener">https://www.jianshu.com/p/c79c5e02ebe6</a></p>
<p>G1收集器<br>G1重新定义了堆空间，打破了原有的分代模型，将堆划分为一个个区域<br>在进行收集的时候，不必在全堆的范围内进行，好吃就是带来了停顿时间的可预测<br>G1会通过一个合理的计算模型，计算出每个region的收集成本并量化</p>
<p>分代模型的写屏障<br>这个是比较重要的一个，一开始是比较难理解的<br><img src="/images/JVM杂记/写屏障.png" alt=""><br>我们从正常的新生代的GC开始说，从图中看到，如果只从GCRoot出发，其实是扫描不到F的，如果扫描不到，说明F是需要被清除的<br>但是其实F被老年代的E所引用，也就是说他不能被清除<br>这就是说，GCRoot需要包含新生代中的被老年代引用的对象。<br>但是如果要实现这个功能，可能要扫描所有的老年代对象了，如果每次进行新生代的GC时都扫描老年代，那么分代GC的意义就不是那么明显了<br>所以这里用了一个写屏障，底层使用的是卡表的概念进行标记。<br>简单的说就是每当有老年代对象引用新生代对象时，就把老年代对象所在的位置标记一下，然后进行新生代GC时，把老年代标记了的位置进行扫描进行，而不用全部扫描<br><a href="https://juejin.im/post/5c39920b6fb9a049e82bbf94" target="_blank" rel="noopener">https://juejin.im/post/5c39920b6fb9a049e82bbf94</a></p>
<p>压缩指针<br>指针的大小一般是平台的决定的，但是在64位的机器上，但是还是可以进行一些优化，优化的基础是内存的申请是一下子一大片连续的内存<br>举个例子就是在64位机器上，如果我们要申请的一块内存小于4G，那么完全可以只用32位就可以进行指针的保存</p>
<p>JRockit里面提到了一种伪优化<br>就是对象池，有人认为，保留一个存活对象池来重新使用已创建的对象可以提升垃圾回收的性能</p>
<blockquote>
<p>但实际上，对象池不仅增加了应用程序的复杂度，还很容易出错。对于现代垃圾收集器来说，使用 java.lang. ref.Reference 系列类实现缓存，或者直接将无用对象的引用置为 null 就好了，不用多操心。<br>此外，长期持有无用的对象其实是个大麻烦，分代式垃圾回收器可以很好地处理临时对象，但如果这些临时对象被人为保存下来，无法被回收掉的话，最终就会被提升到老年代，并将其挤满。</p>
</blockquote>
<h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p>如果函数要返回整数或者指针的话，寄存器%eax可以用来返回值<br>寄存器eax，edx，ecx被划分为调用者保存<br>而寄存器ebx，esi，edi寄存器划分为被调用者保存<br>栈是以帧为单位保存当前线程的运行状态<br>当线程执行一个方法时，它会跟踪当前常量池<br>栈帧存储了方法的局部变量表，操作数栈，动态链接和方法返回地址</p>
<p><img src="/images/JVM杂记/栈帧结构.png" alt=""><br><img src="/images/JVM杂记/解释器帧.png" alt=""></p>
<p>局部变量表</p>
<ul>
<li>局部变量表被组织为一个字长为单位，从0开始计数的数组</li>
<li>存储时以slot为单位，一个slot一般为32位，short，byte，char在存入表中要先转换为int</li>
<li>一般会存储的类型除了基本类型和引用，还有returnAddress类型，它指向了一个字节码指令的地址</li>
<li>参数值到参数变量列表的传递依赖于局部变量表</li>
<li>第0位索引的slot默认是用于传递方法所属对象实例的引用</li>
</ul>
<p>局部变量表的描述</p>
<ul>
<li>start_pc，length：描述局部变量的作用域</li>
<li>name_index：描述局部变量名的常量池索引，对应Class文件中的Name</li>
<li>descriptor_index:描述局部变量类型的常量池索引，对应Class文件中的Signature</li>
<li>index：描述局部变量在当前栈帧的局部变量索引</li>
</ul>
<p>局部变量表的大小在编译期就可以确定，在Code属性中明确了大小</p>
<p>操作数栈</p>
<ul>
<li>操作数栈的深度由Code属性max_stacks在编译期确定</li>
<li>和局部变量表不同的是，操作数栈不是通过索引来访问的，而是通过入栈和出栈来访问</li>
<li>还有一个比较重要的点，就是操作数栈和下一个栈帧的参数列表是可以复用的，不然我们在HSDB调试操作数栈的时候看起来会比较迷惑</li>
</ul>
<p>异常表<br>为了处理Java方法中的异常情况，帧数据区还必须保存一个对此方法异常表的引用，当异常抛出时，JVM给catch块中的代码<br>如果没发现，方法立即终止，然后JVM用帧区数据的信息回复发起调用的方法的帧，然后再发起调用方法的上下文重新抛出同样的异常</p>
<p>Hotspot解释器执行引擎在执行字节码时，实际上是执行一段已经被编译成本地机器直接运行的指令<br>在JVM启动期间，解释器模块就会将每个字节码转换成与之等价的机器指令，放在Code Cache中<br>所以HotSpot充分利用了计算机的资源，包括寄存器</p>
<h2 id="JavaCalls"><a href="#JavaCalls" class="headerlink" title="JavaCalls"></a>JavaCalls</h2><p>JavaCalls，说白了就是JVM调用Java方法</p>
<p>然后CallStub，是一个函数指针，在调用Java程序的Main函数时，需要使用这个函数指针</p>
<p>但是CallStub指向的函数是一个entry_point，是一个例程</p>
<p>当然这里其实是有歧义的例程在JVM的概念就是提前用机器码写好的函数，而entry_point虽然也是例程，然后它主要突出entry这个词，主要是在方法调用切换时进行调用的例程</p>
<p>再说回CallStub，它指向的例程，就是为所有Java程序的唯一一个Main方法构造他的前一个栈帧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>最直接的就是参数args，在栈中需要使用CallStub指向的例程构建好，然后CallStub的函数指针的函数中，还需要传入一个entry_point，这个就是在进行Java函数调用的时候，需要进行寄存器的保存等之类的操作，而这些操作由不同的entry_point来操作。</p>
<p>//fix me</p>
<p>个人理解就是在各种invoke的字节码指令中，会频繁的调用这些不同的entry_point。</p>
<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>其实JVM中常量池有两种不同的概念<br>第一种是Class文件的常量池<br>虚拟机在创建一个类或者接口时候，按照Class文件的定义创建相应的常量池，也就是Class文件中的constant_pool表。<br>第二种是方法区中的常量池，虚拟机在对类进行解析和连接之后，将在内存中为该类生成一套运行时常量池，常量池在运行时动态分配<br>第三种是代码中我们提到的常量池，也就是String常量池，JVM中创建了一个String的Table</p>
<p>参考<a href="https://blog.csdn.net/zm13007310400/article/details/77534349" target="_blank" rel="noopener">https://blog.csdn.net/zm13007310400/article/details/77534349</a></p>
<p>那么为什么要有常量池呢<br>Answer：</p>
<blockquote>
<p>常量池的出现，解决了JVM定位字段和方法的问题，它在不破坏指令集的简洁性的前提下，仅仅通过少量字节就能定位到目标。<br>更详细的说，以字符串数据aVeryLongFunctionName为例，如果在编译时每次都要重新避免这个字符串的话，那么字节码就谈不上压缩了</p>
</blockquote>
<p>但是每次字段或者方法的访问都需要解析常量池项的话，将不可避免的造成性能下降<br>对于类文件的运行时常量池，JVM内还会有它的高速缓冲ConstantPoolCache</p>
<h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><p>HotSpot的解释器分为了两种<br>一种是CPP解释器，也就是最原始的解释器，类似于Case，Case这种形式，文件是intercepter/bytecodeIntercepter.cpp<br>一种是模板解释器，现在默认是这样，这种是在JVM启动时对每一个字节码都进行了当前平台的机器码转换，具体的是维护了一个平台相关TemplateTable，可以在cpu/x86/vm中的templateTable_XX.cpp中找到，相对于CPP解释器，其实这也是一种解释的方法，虽然第一种最终执行的也是C++编译成的机器码，但是模板解释器相对于CPP解释器，机器码是手动写的，可以进行一些优化，比如TOS，还有就是对于取出下一个执行进行运行，也可以直接插入到当前字节码的机器码中</p>
<p>对于模板解释器的取指令的操作，其实在写在每一个字节码指令的最后。<br>HotSpot在为每一个字节码指令生成其机器逻辑指令时，会同时为该字节码指令生成其取址逻辑</p>
<p>PC计数器，在x86平台上就是esi寄存器，所以在JVM中并不是完全不使用CPU的寄存器</p>
<p>面向栈式的指令，可以省去很多的操作数，所以一定程度上也减少了代码体积<br>这话其实不对，因为相对于寄存器式的指令，寄存器式的一个指令就能完成的事，其实栈式需要多个指令</p>
<p>栈帧重叠<br>就是前面提到的上一个方法的操作数栈可以直接成为下一个方法的参数表</p>
<p>栈上替换 OSR<br>个人理解就是在一个方法里遇到了Loop非常久的情况，对方法进行了JIT编译，但是由于这个Loop非常长，JIT编译完还未结束，所以为了将当前方法替换到新的栈帧，使用栈上替换<br>具体的解释在R大这儿<br><a href="https://www.zhihu.com/question/45910849" target="_blank" rel="noopener">OSR（On-Stack Replacement）是怎样的机制？</a><br>JRockit没有实现OSR，因为太复杂了</p>
<p>JIT编译器<br>为什么不直接全部aot编译一下，而是选择了解释+JIT的方式<br>R大这里也回答了[<a href="https://www.zhihu.com/question/37389356)(https://www.zhihu.com/question/37389356" target="_blank" rel="noopener">https://www.zhihu.com/question/37389356)(https://www.zhihu.com/question/37389356</a>)<br>我总结一下</p>
<ul>
<li>时间开销，aot的启动时间肯定很慢</li>
<li>空间开销，字节码到机器码会代码膨胀</li>
<li>编译时机，一些profile的收集对编译有很大的影响<blockquote>
<p>JIT是一个充满希望的方向，因为它可以搜集到程序在AOT编译时得不到的runtime数据，在优化时，有更多的上下文可以依靠，理论上应该有更好的优化特性</p>
</blockquote>
</li>
</ul>
<p>在JRockit中，讲了aot其实在90年代就已经出现了，但是这种方式虽然快了很多，但是抛弃了很多Java的动态特性，提到了一个很重要的场景，就是在JSP的应用中，我们知道JSP其实就是b被编译成class文件，做的事也仅仅是疯狂的sout，如果aot一下，效率不会提高太多，但是代码体积会提高很多</p>
<p>其实aot与全部JIT编译并不是一个概念，一个好的办法是，给JIT的编译加上不同层级的编译，一开始可能是优化不高的，后面收集到profile后再进行深层次的profile</p>
<p>判断热方法</p>
<ul>
<li>counter，但是会降低效率</li>
<li>基于软件的线程采样，周期性的获取活动线程的上下文</li>
</ul>
<p>JVM字节码的表现力其实比Java语言强，所以需要对字节码进行校验，防止一些恶意的技巧</p>
<h2 id="TOS"><a href="#TOS" class="headerlink" title="TOS"></a>TOS</h2><p>TosState的取值范围为0-8，共计9种</p>
<ul>
<li>byte，bool</li>
<li>char</li>
<li>short</li>
<li>int</li>
<li>long</li>
<li>float</li>
<li>double</li>
<li>object</li>
<li>void</li>
</ul>
<p>最后一种其实就是空，参见R大的笔记，HotSpot实战中写的是tos类型，我还去百度了tos类型是啥类型😓 </p>
<h2 id="VM选项"><a href="#VM选项" class="headerlink" title="VM选项"></a>VM选项</h2><table>
<thead>
<tr>
<th>配置</th>
<th>解释</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>-XX:UseG1GC</td>
<td>配置G1收集器</td>
<td></td>
</tr>
<tr>
<td>-Xint</td>
<td>配置虚拟机以纯解释方式运行</td>
<td></td>
</tr>
<tr>
<td>-XX:+MaxFDLimit</td>
<td>最大文件描述符数量</td>
<td></td>
</tr>
<tr>
<td>-XX:DisableExplicitGC</td>
<td>Parallel Scanvenge收集器的配置，屏蔽System.gc()</td>
</tr>
</tbody>
</table>
<h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2><p>实际的性能分析可以查看《HotSpot实战》的5.3小节，讲的很详细</p>
<ul>
<li>HSDB：可以用来看JVM的运行时数据，查看线程栈，对象的数据</li>
<li>jps：查看Java进程信息</li>
<li>jinfo：</li>
<li>jmap：</li>
<li>jhat：</li>
<li>jstat：</li>
<li>jstack：</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://book.douban.com/people/RednaxelaFX/annotation/25847620/?start=0" target="_blank" rel="noopener">RednaxelaFX对《HotSpot实战》的笔记</a><br><a href="https://book.douban.com/subject/25847620/" target="_blank" rel="noopener">HotSpot实战</a><br><a href="https://book.douban.com/subject/30394745/" target="_blank" rel="noopener">JRockit权威指南：深入理解JVM</a><br><a href="https://book.douban.com/subject/27086821/" target="_blank" rel="noopener">https://book.douban.com/subject/27086821/</a></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>zhy
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://blog.lovezhy.cc/2019/07/26/JVM杂记/" title="JVM杂记">https://blog.lovezhy.cc/2019/07/26/JVM杂记/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>Welcome to my other publishing channels</p>

    <div class="social-list">

            <div class="social-item">
              <a target="_blank" class="social-link" href="/atom.xml">
                <span class="icon">
                  <i class="fa fa-rss"></i>
                </span>

                <span class="label">RSS</span>
              </a>
            </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JVM/" rel="tag"># JVM</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/03/29/Java中FileLock的实现细节/" rel="prev" title="Java中FileLock的实现细节">
      <i class="fa fa-chevron-left"></i> Java中FileLock的实现细节
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/09/05/Raft实现指北/" rel="next" title="Raft实现指北">
      Raft实现指北 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源码目录"><span class="nav-number">2.</span> <span class="nav-text">源码目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源码"><span class="nav-number">3.</span> <span class="nav-text">源码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命令行选项"><span class="nav-number">4.</span> <span class="nav-text">命令行选项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Class文件解析"><span class="nav-number">5.</span> <span class="nav-text">Class文件解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#runtime模块与Shutdown-Hook"><span class="nav-number">6.</span> <span class="nav-text">runtime模块与Shutdown Hook</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized实现"><span class="nav-number">7.</span> <span class="nav-text">synchronized实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存-OOP"><span class="nav-number">8.</span> <span class="nav-text">内存 OOP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GC"><span class="nav-number">9.</span> <span class="nav-text">GC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#栈帧"><span class="nav-number">10.</span> <span class="nav-text">栈帧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaCalls"><span class="nav-number">11.</span> <span class="nav-text">JavaCalls</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常量池"><span class="nav-number">12.</span> <span class="nav-text">常量池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解释器"><span class="nav-number">13.</span> <span class="nav-text">解释器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TOS"><span class="nav-number">14.</span> <span class="nav-text">TOS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VM选项"><span class="nav-number">15.</span> <span class="nav-text">VM选项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tools"><span class="nav-number">16.</span> <span class="nav-text">Tools</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">17.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhy</p>
  <div class="site-description" itemprop="description">敌视现实</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhyzhyzhy" title="GitHub → https://github.com/zhyzhyzhy" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhuyichen1017@outlook.com" title="E-Mail → mailto:zhuyichen1017@outlook.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="beian"><a href="http://www.beian.miit.gov.cn" rel="noopener" target="_blank">苏ICP备15058469号 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhy</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://blog-lovezhy-cc-1.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://blog.lovezhy.cc/2019/07/26/JVM杂记/";
    this.page.identifier = "2019/07/26/JVM杂记/";
    this.page.title = "JVM杂记";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://blog-lovezhy-cc-1.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
