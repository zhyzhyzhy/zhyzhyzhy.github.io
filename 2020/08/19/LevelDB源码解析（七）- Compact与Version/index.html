<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="wE7ISC42t3QOT-S-gdbdy_XsP3NB23Xi3alKNWXd0dA">
  <meta name="baidu-site-verification" content="keFN8E7jd3">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Operator Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://blog.lovezhy.cc').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"right","display":"always","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="前言这一节讲述最复杂的Version以及Compact的部分">
<meta name="keywords" content="LevelDB">
<meta property="og:type" content="article">
<meta property="og:title" content="LevelDB源码解析（七）- Compact与Version">
<meta property="og:url" content="https://blog.lovezhy.cc/2020/08/19/LevelDB源码解析（七）- Compact与Version/index.html">
<meta property="og:site_name" content="LoveZhy">
<meta property="og:description" content="前言这一节讲述最复杂的Version以及Compact的部分">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="https://blog.lovezhy.cc/images/leveldb/compact.png">
<meta property="og:image" content="https://blog.lovezhy.cc/images/leveldb/compact1.png">
<meta property="og:image" content="https://blog.lovezhy.cc/images/leveldb/compact2.png">
<meta property="og:updated_time" content="2020-08-15T10:59:53.629Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LevelDB源码解析（七）- Compact与Version">
<meta name="twitter:description" content="前言这一节讲述最复杂的Version以及Compact的部分">
<meta name="twitter:image" content="https://blog.lovezhy.cc/images/leveldb/compact.png">

<link rel="canonical" href="https://blog.lovezhy.cc/2020/08/19/LevelDB源码解析（七）- Compact与Version/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>LevelDB源码解析（七）- Compact与Version | LoveZhy</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125642214-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-125642214-1');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?c1f963571cb3d8a4a5dc82346dc65842";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="LoveZhy" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LoveZhy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>Sitemap</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block " lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://blog.lovezhy.cc/2020/08/19/LevelDB源码解析（七）- Compact与Version/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhy">
      <meta itemprop="description" content="敌视现实">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LoveZhy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LevelDB源码解析（七）- Compact与Version
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-19 00:00:00" itemprop="dateCreated datePublished" datetime="2020-08-19T00:00:00+08:00">2020-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-15 18:59:53" itemprop="dateModified" datetime="2020-08-15T18:59:53+08:00">2020-08-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/LevelDB/" itemprop="url" rel="index">
                    <span itemprop="name">LevelDB</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这一节讲述最复杂的Version以及Compact的部分</p>
<a id="more"></a>
<h2 id="一-Version和VersionSet"><a href="#一-Version和VersionSet" class="headerlink" title="一.  Version和VersionSet"></a>一.  Version和VersionSet</h2><p>LevelDB算是实现了功能上的多版本控制。利用的是Version和VersionSet两个类。</p>
<p>当然这里的多版本控制肯定不是MVCC那么复杂，这里实现多版本的功能，我理解是为了解决两个操作的冲突：</p>
<ol>
<li>读取和迭代操作</li>
<li>后台异步Compact操作</li>
</ol>
<p>因为LevelDB的compact操作，其实是把多个文件合并成多个文件。</p>
<p>从SSTable那一章节，我们其实知道，一个SSTable就是对应一个文件。</p>
<p>如果我们直接修改文件，那么如果前台有线程正在迭代这个SSTable，就会出现不可预知的错误。</p>
<p>所以这就导致我们的Compact结果的文件需要重新生成，不能动以前的文件。</p>
<p>结果就是每个Level的SSTable集合是随着Compact操作会变化的。</p>
<p>迭代可能是个很长的操作，这中间不能保证不会发生Compact，所以干脆就搞个Version，把每次Compact后的SSTable集合存储起来。</p>
<p>这样迭代的时候，先拿到当前的Version。</p>
<p>DBImpl的Versions和CurrentVersion的初始化变量如下：</p>
<p><img src="/images/leveldb/compact.png" style="zoom:50%;"></p>
<p>我们先来看Version类中存储的变量：</p>
<ol>
<li><p>存储每个Level的SSTable集合：</p>
<p>其中Level0比较特殊，是个单独的类，其他的Level是用了个List存储。</p>
</li>
<li><p>retained表示目前这个Version有没有被正在运行的迭代器使用</p>
</li>
<li><p>剩余的四个都是和Compact有关，下面再讲</p>
</li>
</ol>
<p>再来看看VersionSet中的存储的变量：</p>
<ol>
<li>全局的文件名变量：nextFileNumber，LevelDB创建文件时，根据文件类型和FileNumber就可以定位到具体的File。这里存储这个，类似于数据库中的主键生成器，这里是自增的文件名生成器。</li>
<li>ManifestFileNumber：Manifest文件可以理解为是存储的当前的Version的持久化信息</li>
<li>lastSequence：每个写入的Key，都有一个唯一的序号与之对应</li>
<li>Log模块的配置：logNumber和prevLogNumber，类似于数据库中的WAL模块</li>
<li>activeVersions：当前被使用的Version有哪些</li>
<li>compactPointers：进行Compact时，为了保证每个SSTable都有被Compact机会，这个类似于游标，对于同一个Level，每次新Compact时，选择下一批SSTable。</li>
</ol>
<h2 id="二-Compact"><a href="#二-Compact" class="headerlink" title="二. Compact"></a>二. Compact</h2><p>讲完了Version，还有好多坑没填，主要是因为Version和Compact的联系太紧密了，这里将Compact的流程顺便把Version的坑填了。</p>
<p>LevelDB的Compact的代码在DbImpl的<code>backgroundCompaction()</code>中。</p>
<p>具体的Compact其实分为两步：</p>
<ol>
<li>找出需要compact的SSTable集合</li>
<li>对这些SSTable进行compact</li>
</ol>
<p>其中第一步的代码主要是<code>VersionSet::pickCompaction</code>中，但是触发Compact的情况比较多，这里先不谈了。</p>
<p>直接先来看第二步，我们经过<code>pickCompaction</code>已经找到了需要Compact的SSTable，并且已经生成了<code>Compaction</code>对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Compaction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> level; <span class="comment">// 需要compact的Level</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;FileMetaData&gt; levelInputs; <span class="comment">//level对应的需要compact的SSTable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;FileMetaData&gt; levelUpInputs; <span class="comment">//下一层Level对应的需要compact的SSTable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;FileMetaData&gt; grandparents; <span class="comment">//再下一层level对应的需要compact的SSTable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到了这些文件之后，下一步就是对这么文件进行合并。</p>
<p>合并的过程其实就是多路归并的过程。</p>
<p><img src="/images/leveldb/compact1.png" style="zoom:50%;"></p>
<p><strong>从iterator的视角来看，其实相同的UserKey已经按照seqNum的顺序从大到小排列好了。</strong></p>
<p>所以我们进行迭代的时候，看到的数据大致如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. UserKey = <span class="string">"foo123"</span>, seq = <span class="number">34</span>，Type=VALUE</span><br><span class="line"><span class="number">2</span>. UserKey = <span class="string">"foo123"</span>, seq = <span class="number">20</span>，Type=VALUE</span><br><span class="line"><span class="number">3</span>. UserKey = <span class="string">"foo123"</span>, seq = <span class="number">18</span>，Type=DELETE</span><br><span class="line"><span class="number">4</span>. UserKey = <span class="string">"foo123"</span>, seq = <span class="number">8</span>， Type=VALUE</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>. UserKey = <span class="string">"foo456"</span>, seq = <span class="number">213</span>,Type=DETELE</span><br><span class="line"><span class="number">6</span>. UserKey = <span class="string">"foo456"</span>, seq = <span class="number">200</span>,Type=VALUE</span><br><span class="line"><span class="number">7</span>. UserKey = <span class="string">"foo456"</span>, seq = <span class="number">93</span>, Type=VALUE</span><br></pre></td></tr></table></figure>
<p>这里我们根据UserKey把数据分为两段，第一段是1-4，UserKey都是”foo123”。</p>
<p>同时由于1的SEQ最大，剩余的都要被drop掉。</p>
<p>第二段是5-7，UserKey都是”foo456”。</p>
<p>这里由于5的seq最大，所以6-7需要被drop掉。</p>
<p>但是5能不能drop呢？</p>
<p>能不能drop需要查找下面所有的Level，是否是该UserKey了，如果没有了，那么可以drop，否则需要保留。</p>
<p>所以这里对迭代的每行数据而言，都需要判断是否能drop。</p>
<p>简略代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> hasCurrentUserKey = <span class="keyword">false</span>;</span><br><span class="line">Slice currentUserKey = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">long</span> lastSequenceForKey = MAX_SEQUENCE_NUMBER;</span><br><span class="line"><span class="keyword">while</span> () &#123;</span><br><span class="line">  <span class="keyword">boolean</span> drop = <span class="keyword">false</span>;</span><br><span class="line">  InternalKey key = iterator.peek().getKey();</span><br><span class="line">  <span class="keyword">if</span> (!hasCurrentUserKey || !equals(currentUserKey, key)) &#123;</span><br><span class="line">    <span class="comment">//这个key是第一次出现，类似于上述的1和5</span></span><br><span class="line">    currentUserKey = key.getUserKey();</span><br><span class="line">    hasCurrentUserKey = <span class="keyword">true</span>;</span><br><span class="line">    lastSequenceForKey = MAX_SEQUENCE_NUMBER;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//对特定UserKey的第一次循环不会进入，从第二次开始进入</span></span><br><span class="line">  <span class="comment">//目的也就是保留最早的Seq的记录</span></span><br><span class="line">  <span class="comment">//对于剩余的，一律都丢掉</span></span><br><span class="line">  <span class="keyword">if</span> (lastSequenceForKey &lt;= compactionState.smallestSnapshot) &#123;</span><br><span class="line">    <span class="comment">// Hidden by an newer entry for same user key</span></span><br><span class="line">    drop = <span class="keyword">true</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果 </span></span><br><span class="line">  <span class="comment">//1：这个记录是删除记录</span></span><br><span class="line">  <span class="comment">//2: 且key的seqNum小于compact时分配出去的最小seq（感觉这个永远为true）</span></span><br><span class="line">  <span class="comment">//3: 下面level中没有这个Key了</span></span><br><span class="line">  <span class="comment">//就可以drop，简单讲就是如果第一个就是DELETE记录，且下面的Level没有此UserKey了，那么第一个记录也就可以丢了</span></span><br><span class="line">  <span class="keyword">if</span> (key.getValueType() == DELETION</span><br><span class="line">     &amp;&amp; key.getSequenceNumber() &lt;= compactionState.smallestSnapshot</span><br><span class="line">     &amp;&amp; compactionState.compaction.isBaseLevelForKey(key.getUserKey())) &#123;</span><br><span class="line">    drop = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  lastSequenceForKey = key.getSequenceNumber();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>讲完了合并是，判断某个Key是否能丢，下面就是生成新SSTable的逻辑了。</p>
<p>对于一个KV，如果drop=false，那么建立一个Table，把它放进去就行了。</p>
<p>这里我们主要关注：</p>
<ol>
<li>新的SSTable在哪一层</li>
<li>Version是怎么链接到新的SSTable的</li>
</ol>
<p>顺着源码往下看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!drop) &#123;</span><br><span class="line">  <span class="keyword">if</span> (compactionState.builder == <span class="keyword">null</span>) &#123;</span><br><span class="line">    openCompactionOutputFile(compactionState); <span class="comment">// 1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (compactionState.builder.getEntryCount() == <span class="number">0</span>) &#123;</span><br><span class="line">    compactionState.currentSmallest = key;</span><br><span class="line">  &#125;</span><br><span class="line">  compactionState.currentLargest = key;</span><br><span class="line">  compactionState.builder.add(key.encode(), iterator.peek().getValue());</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (compactionState.builder.getFileSize() &gt;=</span><br><span class="line">      compactionState.compaction.getMaxOutputFileSize()) &#123;</span><br><span class="line">    finishCompactionOutputFile(compactionState); <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>这里的builder就是TableBuilder，如果TableBuilder为空，则新建一个TableBuilder。</p>
<p>openCompactionOutputFile这个方法属于DbIMPL。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openCompactionOutputFile</span><span class="params">(CompactionState compactionState)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">long</span> fileNumber = versions.getNextFileNumber();</span><br><span class="line">  </span><br><span class="line">   compactionState.currentFileNumber = fileNumber;</span><br><span class="line">   compactionState.currentFileSize = <span class="number">0</span>;</span><br><span class="line">   compactionState.currentSmallest = <span class="keyword">null</span>;</span><br><span class="line">   compactionState.currentLargest = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">   File file = <span class="keyword">new</span> File(databaseDir, Filename.tableFileName(fileNumber));</span><br><span class="line">   compactionState.outfile = <span class="keyword">new</span> FileOutputStream(file).getChannel();</span><br><span class="line">   compactionState.builder = <span class="keyword">new</span> TableBuilder(options, compactionState.outfile, <span class="keyword">new</span> InternalUserComparator(internalKeyComparator)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法中主要做了一件事：初始化新的SSTable的一些信息到compactionState中</p>
</li>
<li><p>当当前的SSTable的大小超过阈值时，结束往这个SSTable添加，准备重启一个SSTable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompactionOutputFile</span><span class="params">(CompactionState compactionState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> outputNumber = compactionState.currentFileNumber;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> currentEntries = compactionState.builder.getEntryCount();</span><br><span class="line">        compactionState.builder.finish();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> currentBytes = compactionState.builder.getFileSize();</span><br><span class="line">        compactionState.currentFileSize = currentBytes;</span><br><span class="line">        compactionState.totalBytes += currentBytes;</span><br><span class="line"></span><br><span class="line">        FileMetaData currentFileMetaData = <span class="keyword">new</span>           FileMetaData(compactionState.currentFileNumber,</span><br><span class="line">                compactionState.currentFileSize,</span><br><span class="line">                compactionState.currentSmallest,</span><br><span class="line">                compactionState.currentLargest);</span><br><span class="line">  </span><br><span class="line">        compactionState.outputs.add(currentFileMetaData); <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">        compactionState.builder = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        compactionState.outfile.force(<span class="keyword">true</span>);</span><br><span class="line">        compactionState.outfile.close();</span><br><span class="line">        compactionState.outfile = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentEntries &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            tableCache.newIterator(outputNumber);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法中，我们主要关注位置1的代码，在CompactionState中，有一个List，用来存储新生成的SSTable的信息。</p>
</li>
</ol>
<p>到这儿，合并过程结束了，我们生成了多个SSTable，在CompactionState的outputs中保存</p>
<p>然后进行最后一步：<code>installCompactionResults(compactionState);</code></p>
<p>说到这儿，你可能猜到了，下面就是与Version构建连接关系的过程了。</p>
<p>这里不得不插入一个很重要的类，就是VersionEdit。</p>
<p>我们知道后一个Version和前一个Version的主要区别就是SSTable会发生变化，而VersionEdit就是记录这个变化的。</p>
<p>我们可以理解为 <code>NewVersion = OldVersion + VersionEdit</code>;</p>
<p>而在VersionEdit中，也存有两个变量表示SSTable的增减。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VersionEdit</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Multimap&lt;Integer, FileMetaData&gt; newFiles;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Multimap&lt;Integer, Long&gt; deletedFiles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>installCompactionResults</code>中：主要就是构建VersionEdit。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installCompactionResults</span><span class="params">(CompactionState compact)</span> </span>&#123;</span><br><span class="line">    compact.compaction.addInputDeletions(compact.compaction.getEdit()); <span class="comment">// 1</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> level = compact.compaction.getLevel();</span><br><span class="line">    <span class="keyword">for</span> (FileMetaData output : compact.outputs) &#123;</span><br><span class="line">        compact.compaction.getEdit().addFile(level + <span class="number">1</span>, output); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        versions.logAndApply(compact.compaction.getEdit());</span><br><span class="line">        deleteObsoleteFiles();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>将之前的输入的SSTable放到<code>VersionEdit</code>的<code>deletedFiles</code>中</li>
<li>将新产生的SSTable放到<code>newFiles</code>中，这里可以看到，新生成的SSTable，放到了level+1层，也就是levelUp层，也就是下一层。</li>
</ol>
<p>下面就是进入<code>versions.logAndApply</code>方法了，这个方法属于VersionSet类。</p>
<p>在这个方法中，最重要的有几句话：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logAndApply</span><span class="params">(VersionEdit edit)</span> </span>&#123;</span><br><span class="line">    edit.setLogNumber(logNumber);</span><br><span class="line">    edit.setNextFileNumber(nextFileNumber.get());</span><br><span class="line">    edit.setLastSequenceNumber(lastSequence);</span><br><span class="line"></span><br><span class="line">    Version version = <span class="keyword">new</span> Version(<span class="keyword">this</span>);</span><br><span class="line">    Builder builder = <span class="keyword">new</span> Builder(<span class="keyword">this</span>, current);</span><br><span class="line">    builder.apply(edit);</span><br><span class="line">    builder.saveTo(version);</span><br><span class="line"></span><br><span class="line">    finalizeVersion(version);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> createdNewManifest = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (descriptorLog == <span class="keyword">null</span>) &#123;</span><br><span class="line">            edit.setNextFileNumber(nextFileNumber.get());</span><br><span class="line">            descriptorLog = Logs.createLogWriter(<span class="keyword">new</span> File(databaseDir, Filename.descriptorFileName(manifestFileNumber)), manifestFileNumber);</span><br><span class="line">            writeSnapshot(descriptorLog);</span><br><span class="line">            createdNewManifest = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        Slice record = edit.encode();</span><br><span class="line">        descriptorLog.addRecord(record, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (createdNewManifest) &#123;</span><br><span class="line">            Filename.setCurrentFile(databaseDir, descriptorLog.getFileNumber());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				<span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    appendVersion(version);</span><br><span class="line">    logNumber = edit.getLogNumber();</span><br><span class="line">    prevLogNumber = edit.getPreviousLogNumber();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendVersion</span><span class="params">(Version version)</span> </span>&#123;</span><br><span class="line">    Version previous = current;</span><br><span class="line">    current = version;</span><br><span class="line">    activeVersions.put(version, <span class="keyword">new</span> Object());</span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">        previous.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的逻辑之前已经分析过了，这里再过一遍整体的流程，主要就是2步：</p>
<ol>
<li>根据当前的Version和传入的VersionEdit，构造新的Version。并且在appendVersion方法中替换current。</li>
<li>把VersionEdit写入Manifest文件</li>
</ol>
<p>彩蛋：</p>
<p>前面的多路归并生成新的SSTable的流程，具体的某个SSTable结束Build逻辑其实就是判定新的SSTable的大小。</p>
<p>其实源代码中不然，还有一种情况也会触发SSTable生成结束。</p>
<p>不过这种场景，我想了很久都没想通，这里先抛出来：TODO</p>
<p>写到这里，Version，VersionSet和Compact的耦合流程已经理清楚了。</p>
<p>下面就是重点了，设计到策略方面的：如何选择需要合并的SSTable。</p>
<p>我们知道，LevelDB最多有7层Level，每个Level可能有很多SSTable，其中Level0的SSTable的KV是无序的。</p>
<p>如果我们每次都合并某个Level，或者我们每次都合并每个Level的前几个SSTable，必然会导致KV不均的情况。</p>
<p>同时我们还需要机制触发合并流程，不能是配死的规则。</p>
<p>1 针对Level0的searchMiss的情况</p>
<p>我们知道Level0的SSTable之间的Key并不是顺序的，互相之间可能overlap。那么在查找一个Key的时候，仅仅从最大key和最小key才判断，可能命中好几个SSTable。</p>
<p>比如如下场景的Level0：</p>
<p><img src="/images/leveldb/compact2.png" style="zoom:50%;"></p>
<p>我们要查找19这个Key，会发现符合条件的有3个。</p>
<p>我们要查找22这个Key，会发现符合条件的有2个。</p>
<p>遇到超过一个SSTable需要查找的情况，我们认为情况不太好，但是只谈性质不谈次数就是耍流氓。</p>
<p>所以我们给每个SSTable维护一个计数器，指示SearchMiss的次数。</p>
<p>比如我们搜索20，最终在第二个SSTable中搜索到了，那么第一个SSTable就是SearchMiss了，计数器减一。</p>
<p>但是注意，每次搜索，只会将第一个SearchMiss的SSTable的计数器减一。</p>
<p>比如我们查找19这个Key，最终在第三个SSTable中搜索到了，或者3个都没搜索到，也只会将第一个SSTable的SearchMiss计数器减一。</p>
<p>来看源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Version::get(LookupKey key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LookupResult <span class="title">get</span><span class="params">(LookupKey key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ReadStats readStats = <span class="keyword">new</span> ReadStats(); <span class="comment">// 1</span></span><br><span class="line">        LookupResult lookupResult = level0.get(key, readStats); <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">if</span> (lookupResult == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Level level : levels) &#123;</span><br><span class="line">                lookupResult = level.get(key, readStats); <span class="comment">// 3</span></span><br><span class="line">                <span class="keyword">if</span> (lookupResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        updateStats(readStats.getSeekFileLevel(), readStats.getSeekFile()); <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">return</span> lookupResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateStats</span><span class="params">(<span class="keyword">int</span> seekFileLevel, FileMetaData seekFile)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (seekFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        seekFile.decrementAllowedSeeks(); <span class="comment">// 5</span></span><br><span class="line">        <span class="keyword">if</span> (seekFile.getAllowedSeeks() &lt;= <span class="number">0</span> &amp;&amp; fileToCompact == <span class="keyword">null</span>) &#123;</span><br><span class="line">            fileToCompact = seekFile;   </span><br><span class="line">            fileToCompactLevel = seekFileLevel; <span class="comment">// 6</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>这里的ReadStats保存的是第一个SearchMiss的SSTable。</li>
<li>搜索Level0</li>
<li>搜索Level1往下的，但是这里面因为SSTable都是有序的，所有不会出现SearchMiss的情况，也就是不会更新ReadStats</li>
<li>更新stats，传入的是SearchMiss的SSTable的Level和FileMetaData</li>
<li>在updateStats方法中，将SearchMiss的数值减一，这个值初始为1 &lt;&lt; 30，不是很小其实，这个阈值还是很难达到的，达到了表示有热点Key了。</li>
<li>fileToCompact和fileToCompactLevel是Version的成员变量，在下一个pickCompact时会考虑这两个值。</li>
</ol>
<p>2 根据每个Level的文件个数和字节大小</p>
<p>从Level0到Level7，作为LSM来看的话，越往下的Level的KV数应该是越多的。所以如果中间某个Level的KV数超过某个阈值，就要Compact到下一个Level。</p>
<p>同时Level0因为无序，对他而言，SSTable如果超过一定的个数，也要进行Compact。</p>
<p>总结一下就是，选择下一次的Compact的SSTable：</p>
<ol>
<li>Level0的SSTable个数</li>
<li>其他Level的KV个数，也就是等价于Bytes个数</li>
</ol>
<p>于是我们给每个Level打个分，分越高表示越需要尽快Compact。</p>
<p>在VersionSet的finalizeVersion方法中，就是给每个Level打分，选出下一个需要Compact的Level。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finalizeVersion</span><span class="params">(Version version)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bestLevel = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> bestScore = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; version.numberOfLevels() - <span class="number">1</span>; level++) &#123;</span><br><span class="line">        <span class="keyword">double</span> score;</span><br><span class="line">        <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//level0是根据文件数计算score</span></span><br><span class="line">            score = <span class="number">1.0</span> * version.numberOfFilesInLevel(level) / L0_COMPACTION_TRIGGER;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//其他的level是根据文件总大小计算score</span></span><br><span class="line">            <span class="keyword">long</span> levelBytes = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (FileMetaData fileMetaData : version.getFiles(level)) &#123;</span><br><span class="line">                levelBytes += fileMetaData.getFileSize();</span><br><span class="line">            &#125;</span><br><span class="line">            score = <span class="number">1.0</span> * levelBytes / maxBytesForLevel(level);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (score &gt; bestScore) &#123;</span><br><span class="line">            bestLevel = level;</span><br><span class="line">            bestScore = score;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    version.setCompactionLevel(bestLevel);</span><br><span class="line">    version.setCompactionScore(bestScore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假如我们选出了得分最高的，比如Level3，但是Level3中可能有100个SSTable，具体怎么选择呢？</p>
<p>是固定选择第一个SSTable，但是最后一个，还是中间1个？</p>
<p>或者选择其中的几个？随机几个吗？</p>
<p>LevelDB为为每个Level维护了一个Compact进度的游标，这个变量叫<code>compactPointers</code>，维护在VersionSet和VersionEdit中，因为维护在了VersionEdit中了，所以每次Compact完会写入Manifest文件中，重新启动的时候会恢复出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, InternalKey&gt; compactPointers = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>定义如上，Key是Level的值，Value是具体的InternalKey。</p>
<p>具体流程如下：</p>
<ol>
<li>根据finalizeVersion的结果，找个该Level。</li>
<li>遍历该Level下的所有文件，找到第一个LargestKey大于compactPointers中该Level的Value的SSTable</li>
<li>以这一个SSTable作为Base，寻找Level + 1 层有overlap的SSTable</li>
<li>更新compactPointers该Level的结果，Value更新为pick中的SSTable的LargestKey。下一次查找的时候就是顺位的下一个SSTable。</li>
<li>将这些SSTable进行Compact。</li>
</ol>
<p>这里为什么维护这种游标呢？是让每个SSTable都有机会进行Compact吗？</p>
<p>其实我理解是为了LevelDB中所有的Key的分布在每个Level都更均匀。</p>
<p>如果每次都Compact第一个SSTable，那么所有Key靠前的都会被优先Compact到下一层。</p>
<p>查询的时候很容易就找到了最后一个Level。</p>
<p>维护了这种游标之后，每个Level的Key分布都均匀的向下Compact。</p>
<p>综合上面的两种情况，我们最后可以来看pickCompact方法了，代码比较多，但是如果上面的都理解了，还是比较好懂的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Compaction <span class="title">pickCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span> sizeCompaction = (current.getCompactionScore() &gt;= <span class="number">1</span>); <span class="comment">// 对应上面的第二种触发Compact情况</span></span><br><span class="line">	<span class="keyword">boolean</span> seekCompaction = (current.getFileToCompact() != <span class="keyword">null</span>);<span class="comment">// 对应上面第一种触发情况</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> level;</span><br><span class="line">	List&lt;FileMetaData&gt; levelInputs;</span><br><span class="line">	<span class="keyword">if</span> (sizeCompaction) &#123; <span class="comment">//如果第二种情况满足条件</span></span><br><span class="line">		level = current.getCompactionLevel();</span><br><span class="line">		levelInputs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">		<span class="keyword">for</span> (FileMetaData fileMetaData : current.getFiles(level)) &#123;</span><br><span class="line">      <span class="comment">//下面就是compactPointer找到大于Value的第一个SSTable</span></span><br><span class="line">			<span class="keyword">if</span> (!compactPointers.containsKey(level) ||</span><br><span class="line">					internalKeyComparator.compare(fileMetaData.getLargest(), compactPointers.get(level)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				levelInputs.add(fileMetaData); </span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (levelInputs.isEmpty()) &#123;</span><br><span class="line">			levelInputs.add(current.getFiles(level).get(<span class="number">0</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (seekCompaction) &#123; <span class="comment">//如果第一种情况满足条件</span></span><br><span class="line">		level = current.getFileToCompactLevel();</span><br><span class="line">		levelInputs = ImmutableList.of(current.getFileToCompact());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//都不满足直接返回</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Level0的overlap情况要特殊处理</span></span><br><span class="line">	<span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">		Entry&lt;InternalKey, InternalKey&gt; range = getRange(levelInputs);</span><br><span class="line">		levelInputs = getOverlappingInputs(<span class="number">0</span>, range.getKey(), range.getValue());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Compaction compaction = setupOtherInputs(level, levelInputs);</span><br><span class="line">	<span class="keyword">return</span> compaction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个方法是找到level + 1 和level + 2的overlap的情况</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Compaction <span class="title">setupOtherInputs</span><span class="params">(<span class="keyword">int</span> level, List&lt;FileMetaData&gt; levelInputs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Entry&lt;InternalKey, InternalKey&gt; range = getRange(levelInputs);</span><br><span class="line">	InternalKey smallest = range.getKey();</span><br><span class="line">	InternalKey largest = range.getValue();</span><br><span class="line"></span><br><span class="line">	List&lt;FileMetaData&gt; levelUpInputs = getOverlappingInputs(level + <span class="number">1</span>, smallest, largest);</span><br><span class="line"></span><br><span class="line">	range = getRange(levelInputs, levelUpInputs);</span><br><span class="line">	InternalKey allStart = range.getKey();</span><br><span class="line">	InternalKey allLimit = range.getValue();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//expand，这里看看就好</span></span><br><span class="line">	<span class="keyword">if</span> (!levelUpInputs.isEmpty()) &#123;</span><br><span class="line">		List&lt;FileMetaData&gt; expanded0 = getOverlappingInputs(level, allStart, allLimit);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (expanded0.size() &gt; levelInputs.size()) &#123;</span><br><span class="line">			range = getRange(expanded0);</span><br><span class="line">			InternalKey newStart = range.getKey();</span><br><span class="line">			InternalKey newLimit = range.getValue();</span><br><span class="line"></span><br><span class="line">			List&lt;FileMetaData&gt; expanded1 = getOverlappingInputs(level + <span class="number">1</span>, newStart, newLimit);</span><br><span class="line">			<span class="keyword">if</span> (expanded1.size() == levelUpInputs.size()) &#123;</span><br><span class="line">				smallest = newStart;</span><br><span class="line">				largest = newLimit;</span><br><span class="line">				levelInputs = expanded0;</span><br><span class="line">				levelUpInputs = expanded1;</span><br><span class="line"></span><br><span class="line">				range = getRange(levelInputs, levelUpInputs);</span><br><span class="line">				allStart = range.getKey();</span><br><span class="line">				allLimit = range.getValue();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	List&lt;FileMetaData&gt; grandparents = ImmutableList.of();</span><br><span class="line">	<span class="keyword">if</span> (level + <span class="number">2</span> &lt; NUM_LEVELS) &#123;</span><br><span class="line">		grandparents = getOverlappingInputs(level + <span class="number">2</span>, allStart, allLimit);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Compaction compaction = <span class="keyword">new</span> Compaction(current, level, levelInputs, levelUpInputs, grandparents);</span><br><span class="line"></span><br><span class="line">	compactPointers.put(level, largest); <span class="comment">// 更新游标，重点</span></span><br><span class="line">	compaction.getEdit().setCompactPointer(level, largest);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> compaction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>zhy
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://blog.lovezhy.cc/2020/08/19/LevelDB源码解析（七）- Compact与Version/" title="LevelDB源码解析（七）- Compact与Version">https://blog.lovezhy.cc/2020/08/19/LevelDB源码解析（七）- Compact与Version/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>Welcome to my other publishing channels</p>

    <div class="social-list">

            <div class="social-item">
              <a target="_blank" class="social-link" href="/atom.xml">
                <span class="icon">
                  <i class="fa fa-rss"></i>
                </span>

                <span class="label">RSS</span>
              </a>
            </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/LevelDB/" rel="tag"># LevelDB</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/18/LevelDB源码解析（六）- WAL和Log文件/" rel="prev" title="LevelDB源码解析（六）- WAL和Log文件">
      <i class="fa fa-chevron-left"></i> LevelDB源码解析（六）- WAL和Log文件
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一-Version和VersionSet"><span class="nav-number">2.</span> <span class="nav-text">一.  Version和VersionSet</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二-Compact"><span class="nav-number">3.</span> <span class="nav-text">二. Compact</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhy</p>
  <div class="site-description" itemprop="description">敌视现实</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">88</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">60</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhyzhyzhy" title="GitHub → https://github.com/zhyzhyzhy" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhuyichen1017@outlook.com" title="E-Mail → mailto:zhuyichen1017@outlook.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="beian"><a href="http://www.beian.miit.gov.cn" rel="noopener" target="_blank">苏ICP备15058469号 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhy</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID: '397fc9b869aab02e85ba',
      clientSecret: 'fb88003acd1df02f7ad1d3f19b54e8ce0f09932d',
      repo: 'zhyzhyzhy.github.io',
      owner: 'zhyzhyzhy',
      admin: ['zhyzhyzhy'],
      id: '655476c19f8f89df7d97c23d763e8fc3',
        language: 'zh_CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
