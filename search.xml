[{"title":"天池比赛经历","url":"https://blog.lovezhy.cc/2020/06/29/天池比赛经历/","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>第一次参加这种类似黑客马拉松的比赛，感觉还是挺新奇的。</p>\n<p>虽然成绩不咋好，但是毕竟第一次参加，还是记录一下。</p>\n<a id=\"more\"></a>\n<h1 id=\"成绩\"><a href=\"#成绩\" class=\"headerlink\" title=\"成绩\"></a>成绩</h1><p>写了大概5天吧。</p>\n<p>Score从900 -&gt; 3118 -&gt; 6454 -&gt; 49051 -&gt; 75348 -&gt; 100089 -&gt; 116530</p>\n<p>看时间消耗的话，正好卡在20s这儿，排名，6月29号看65名这儿。</p>\n<p>前几名都是2s多的都是什么神仙啊。<br>我看我GC日志，单台机器的STW都不止2s了。</p>\n<h1 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h1><p>对于聚合服务器而言，就是不断的请求流处理机器，获得出错的日志的traceId，取出交集作为Response响应，发送给所有服务器。</p>\n<p>流处理机器获得响应后，再次把需要聚合的所有日志发送给聚合服务器。</p>\n<p>而对于流处理的服务器而言：</p>\n<ol>\n<li>建立与日志文件的Http请求，获得InputStream对象，不断的read，一行一行的获取日志。</li>\n<li>在内存中建立索引</li>\n<li>配合聚合服务器做出响应</li>\n</ol>\n<p>这里涉及到一个问题，就是怎么判断一个traceId的所有日志能不能丢。</p>\n<p>这里比赛放出了个限定条件：</p>\n<blockquote>\n<p>为了方便选手解题，相同traceId的第一条数据（span）到最后一条数据不会超过2万行。方便大家做短暂缓存的流式数据处理。真实场景中会根据时间窗口的方式来处理，超时数据额外处理。</p>\n</blockquote>\n<p>所以基本上，我们不断的read日志的时候，已经有2w条没有出现TraceId=X了，那么就可以认为下面不会再出现TraceId=X的日志了。</p>\n<p>如果索引中TraceId=X的日志，没有出现Error，就可以丢掉了。</p>\n<h1 id=\"优化思路\"><a href=\"#优化思路\" class=\"headerlink\" title=\"优化思路\"></a>优化思路</h1><ol>\n<li>SpringMVC改成自定义协议，减少Http协议的解析时间，效果：低</li>\n<li>传输数据使用更好的序列化工具，减少Http传输体积和反序列化时间，效果：低</li>\n<li>HttpClient使用连接池，减少TCP每次都进行握手的时间，效果：低</li>\n<li>调整GC，很多对象都是朝生夕死，调大年轻代内存，效果：一般</li>\n<li>分析日志，手写方法提取出spanId和startTime和tag，不用String.split()，效果：显著</li>\n<li>使用Http Range方法拉取trace文件，分批处理，最后合并checksum的map，效果：显著</li>\n<li>使用生产者消费者模型，生产者线程拉取Http的Stream，解析成Model，消费者通过阻塞队列拉取，效果：待验证</li>\n</ol>\n<h1 id=\"感触\"><a href=\"#感触\" class=\"headerlink\" title=\"感触\"></a>感触</h1><p>其实这里有两个性能瓶颈是很容易想到的，因为这里最大的问题就是数据量非常大，单文件2500w行。</p>\n<ol>\n<li>Http请求数据，IO性能</li>\n<li>parse日志，提取spanId</li>\n<li>建立日志的索引</li>\n</ol>\n<p>IO性能这个基本无解，没什么好的优化方法，或者换C++是个好思路（手动狗头）</p>\n<p>parse日志这个也基本无解，这里的parse其实还算简单的</p>\n<p>建立日志的索引倒是考究很多。</p>\n<p>还有个就是不能太迷信多线程，这里简单提一个例子，就是parse日志的过程中，我曾经改成了多线程的方法，但是发现CPU消耗上去了，但是性能几乎没啥变化，本地测甚至还有点下降。</p>\n<h1 id=\"吐槽\"><a href=\"#吐槽\" class=\"headerlink\" title=\"吐槽\"></a>吐槽</h1><p>官方的题目中，明明写着是面向数据流的，然后还允许通过Range方式拉取，这不打脸么。</p>\n","categories":["天池"],"tags":["天池"]},{"title":"Java堆外内存理解","url":"https://blog.lovezhy.cc/2020/06/10/Java堆外内存理解/","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>这文章算是同事约稿（手动狗头），但是从搜集资料的过程中确实也学到了不少。</p>\n<a id=\"more\"></a>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><p>申请堆外内存：使用unsafe.allocate，返回一个long类型，表示起始地址</p>\n<p>使用：unsafe.putByte，unsafe.getByte</p>\n<p>释放堆外内存：使用unsafe.free</p>\n<p>JDK自动释放，使用虚引用注册一个DirectByteBuffer的即将被GC的Hook，在这个Hook中调用unsafe.free</p>\n<h1 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h1><p>使用场景：</p>\n<ol>\n<li>JDK IO，对fd进行read和write时，申请一个堆外内存作为中转 -&gt; [源码IOUtil]<ol>\n<li>为啥？</li>\n<li>解答：R大的解答：<a href=\"https://www.zhihu.com/question/57374068/answer/152691891\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/57374068/answer/152691891</a></li>\n</ol>\n</li>\n<li>Netty作为ByteBuffer内存池</li>\n<li>OHC框架，Off-Heap-Cache，作为堆外缓存使用</li>\n</ol>\n<h1 id=\"优势和劣势\"><a href=\"#优势和劣势\" class=\"headerlink\" title=\"优势和劣势\"></a>优势和劣势</h1><p>为什么使用堆外内存：</p>\n<ol>\n<li>IO友好，使用场景1</li>\n<li>自己管理内存，减少堆内存占用，减轻JVM GC压力</li>\n</ol>\n<p>劣势：</p>\n<ol>\n<li>常见内存泄漏问题，难以排查</li>\n<li>只能是byte[]对象，存储与获取其他对象，需要自己序列化和反序列化</li>\n<li>性能问题（相对于GC消耗需要辩证看待）<ol>\n<li>申请和释放堆外内存消耗较大（NativeMethod，底层是malloc和free）</li>\n<li>访问堆外内存速度不如访问JVM对象（”leave” the JVM “context”）</li>\n</ol>\n</li>\n<li>内存占用：如果使用内存池管理，实际占用比实际使用的较大</li>\n</ol>\n<h1 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h1><p>适用于：</p>\n<ol>\n<li>IO的Buffer</li>\n<li>单次使用：内存占用较大的，不影响JVM堆</li>\n<li>频繁使用：<ol>\n<li>占用空间较大，对象存活时间较长，配合内存池使用：减轻GC压力，减少GC毛刺与抖动，范例OHC</li>\n<li>生命周期较短，但是量多且涉及IO，配合内存池使用：范例Netty</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"补充阅读\"><a href=\"#补充阅读\" class=\"headerlink\" title=\"补充阅读\"></a>补充阅读</h1><ol>\n<li><a href=\"https://github.com/snazy/ohc\" target=\"_blank\" rel=\"noopener\">https://github.com/snazy/ohc</a></li>\n<li>视频：Netty-A framework to rule them all，B站和Youtube均有，讲了Netty在内存使用上的优化</li>\n<li>Java未提供munmap方法：<a href=\"https://www.cnblogs.com/huxi2b/p/6637425.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/huxi2b/p/6637425.html</a></li>\n<li>使用堆外内存优化GC，<a href=\"https://juejin.im/post/5cdf8df4f265da1bd260bae9\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5cdf8df4f265da1bd260bae9</a></li>\n<li>堆外内存溢出问题排查，<a href=\"https://coldwalker.com/2018/12//troubleshooter_directbytebuffer_memory_issue/\" target=\"_blank\" rel=\"noopener\">https://coldwalker.com/2018/12//troubleshooter_directbytebuffer_memory_issue/</a></li>\n</ol>\n","categories":["Java基础"],"tags":["Java"]},{"title":"论文翻译-What’s-Really-New-wit-NewSQL","url":"https://blog.lovezhy.cc/2020/06/08/论文翻译-What’s-Really-New-with-NewSQL/","content":"<p><strong><a href=\"/files/newsql.pdf\">论文PDF下载</a></strong></p>\n<a id=\"more\"></a>\n<h2 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h2><p><strong>What’s Really New with NewSQL?</strong></p>\n<p>Andrew Pavlo Carnegie Mellon University pavlo@cs.cmu.edu</p>\n<p>Matthew Aslett 451 Research matthew.aslett@451research.com</p>\n<h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>一类新的数据库管理系统(DBMSs)被称为NewSQL，它声称自己有能力以传统系统所不具备的方式扩展现代在线交易处理(OLTP)的工作负载。</p>\n<p>这篇论文的作者之一（论文的两位作者分别是pavlo和matthew.aslett）在2011年的一份商业分析报告中首次使用了NewSQL这个术语，该报告讨论了新的数据库系统作为对这些老牌厂商（Oracle、IBM、微软）的挑战者的崛起。</p>\n<p>而另一位作者则是第一批研究NewSQL DBMS的人。</p>\n<p>从那时起，一些公司和研究项目都用这个词来描述他们的系统（无论他们是否使用正确）。</p>\n<p><br><br>考虑到关系型DBMS已经有四十多年的历史，我们有理由问一下，NewSQL的优越性的说法是真的，还是仅仅是营销手段。</p>\n<p>如果它们确实能够获得更好的性能，那么接下来的问题是，它们是否有什么新技术使它们能够获得这些优势，还是说硬件已经进步了很多，以至于现在早些年的瓶颈不再是问题。</p>\n<p><br><br>为了做到这一点，我们首先讨论数据库的历史，以说明NewSQL系统是如何产生的。</p>\n<p>然后，我们将详细解释NewSQL这个词的含义，以及属于这个定义下的不同类别的系统。</p>\n<h2 id=\"1-DBMS简史\"><a href=\"#1-DBMS简史\" class=\"headerlink\" title=\"1. DBMS简史\"></a>1. DBMS简史</h2><p>最早的DBMS是在1960年代中期上线的。</p>\n<p>最早的其中一个是IBM的IMS系统，用于跟踪土星五号和阿波罗太空探索项目的物资和零件库存。</p>\n<p>它引入了应用程序的代码应该和它所操作的数据分开的理念。这使得开发人员可以编写的应用程序只关注数据的访问和操作，而不是与如何实际执行这些操作相关的复杂性和开销。</p>\n<p>IMS之后，在20世纪70年代初，IBM公司的System R和加州大学的INGRES等第一批关系型DBMS的开创性工作也随之而来。INGRES很快被其他大学的信息系统所采用，并在70年代末实现了商业化。</p>\n<p>大约在同一时间，甲骨文公司发布了他们的第一个DBMS版本，与System R的设计相似。<br>1980年代初，其他的公司也纷纷成立，试图重复第一批商业化DBMS的成功，包括Sybase和Informix。</p>\n<p>尽管IBM从未向公众提供过System R，但它后来在1983年发布了一个新的关系型DBMS (DB2)，其使用了System R的部分代码库。</p>\n<p><br><br>20世纪80年代末和90年代初诞生了一类新的DBMS，这些DBMS的设计是为了克服关系模型和面向对象编程语言之间的阻抗不匹配的问题。</p>\n<p>然而，这些面向对象的DBMS从未在市场上得到广泛的应用，因为它们缺乏像SQL那样的标准接口。</p>\n<p>但是当十年后各大厂商增加了对对象和XML的支持时，其中的许多想法最终被纳入到了面向对象的<br>DBMS中，20多年后又在面向文档的NoSQL系统中再次被纳入。</p>\n<p><br><br>在90年代，另一个值得注意的事件是今天的两个主要的开源DBMS项目的开始。</p>\n<p>MySQL是1995年在瑞典开始的，它是基于早期基于ISAM的mSQL系统。</p>\n<p>PostgreSQL开始于1994年，当时两个伯克利大学的研究生fork了20世纪80年代原始的基于QUEL的Post-gres代码，增加了对SQL的支持。</p>\n<p><br><br>2000年代，互联网应用的出现，对硬件资源的要求比前几年的应用更具挑战性。</p>\n<p>它们需要扩大规模以支持大量的并发用户，并且必须一直在线。<br>但这些新应用使用的数据库一直是一个瓶颈，因为资源需求远远超过了当时的DBMS和硬件所能支持的范围。  </p>\n<p>许多人尝试了最简单的选择，即通过将数据库移动到具有更好的硬件的机器上，垂直扩展他们的DBMS。<br>然而，这样做只能提高性能，回报率却越来越低。  </p>\n<p>此外，将数据库从一台机器移动到另一台机器是一个复杂的过程，往往需要大量的停机时间，这对于这些基于Web的应用来说是不可接受的。  </p>\n<p>为了克服这个问题，一些公司创建了定制的中间件，将单节点的DBMS分片到成本较低的机器集群上。这样的中间件向应用程序展示了一个存储在多个物理节点上的单一逻辑数据库。</p>\n<p>当应用程序针对这个数据库发出查询时，中间件会重定向和/或重写它们，将它们分配到集群中的一个或多个节点上执行。</p>\n<p>节点执行这些查询，并将结果发送回中间件，中间件再将其汇总成一个单一的响应给应用。</p>\n<p>这种中间件方法的两个显著例子是eBay的基于Oracle的集群和Google的基于MySQL的集群。</p>\n<p>这种方法后来被Facebook采用，他们自己的MySQL集群至今仍在使用。</p>\n<p><br><br>Sharding 中间件对于简单的操作，如读取或更新一条记录，效果很好。</p>\n<p>但要在事务或联接表中执行更新一条以上记录的查询则比较困难。</p>\n<p>因此，这些早期的中间件系统并不支持这些类型的操作。例如，eBay在2002年的中间件，要求其开发人员在应用级代码中实现所有的join操作。</p>\n<p><br><br>最终，这些公司中的一些脱离了中间件，开发了自己的分布式DBMS。</p>\n<p>这样做的动机有三个方面。</p>\n<p>最重要的是，当时传统的DBMS注重一致性和正确性，而牺牲了可用性和性能。但这种权衡被认为不适合于需要一直在线并需要进行大量并发操作的基于Web的应用程序。</p>\n<p>其次，有人认为使用像MySQL这样的全功能DBMS作为 “哑巴 “数据存储，会有太多的开销。</p>\n<p>同样，也有人认为关系型模型不是表示应用程序数据的最佳方式，使用SQL对于简单的查询查询来说是一种过度的做法。</p>\n<p><br><br>这些问题被证明是2000年代中后期NoSQL1运动的推动力的起源。</p>\n<p>这些NoSQL系统的核心是放弃了传统DBMS的强大的事务保证和关系模型，而倾向于最终的一致性和替代性数据模型（例如，键/值、图、文档）。</p>\n<p>这是因为有些人认为，现有的DBMS的特点抑制了它们的扩展能力和实现Web的应用所需的高可用<br>性。</p>\n<p>最早遵循这一信条最著名的两个系统是Google的BigTable和Amazon的Dynamo。</p>\n<p>这两个系统一开始都不在各自公司之外出现（尽管它们现在是以云服务的形式出现），因此，其他组织创建了自己的开源克隆系统。</p>\n<p>这些包括Facebook的Cassandra（基于BigTable和Dynamo）和PowerSet的Hbase（基于BigTable）。</p>\n<p>其他初创公司创建了自己的系统，这些系统不一定是Google或Amazon的系统的复制品，但仍然遵循NoSQL哲学的原则；其中最著名的是MongoDB。</p>\n<p><br><br>到了2000年代末，现在已经有了多种多样的、可扩展的、更实惠的分布式DBMS。</p>\n<p>使用NoSQL系统的好处是，开发人员可以专注于他们的应用中对他们的业务或组织更有利的方面，而不必担心如何扩展DBMS。</p>\n<p>然而，许多应用无法使用这些NoSQL系统，因为它们不能放弃强大的交易和一致性要求。</p>\n<p>这种情况对于处理高等级数据的企业系统（例如，财务和订单处理系统）很常见。</p>\n<p>一些组织，最明显的是Google，发现NoSQL DBMS导致他们的开发人员花了太多时间编写代码来处理一致的数据，而使用事务使他们的工作效率更高，因为它们提供了一个有用的抽象，更容易被人类理解。</p>\n<p>因此，这些组织唯一的选择是，要么购买更强大的单节点机器，并对DBMS进行动态扩展，要么开发自己的支持事务的自定义分片中间件。</p>\n<p>这两种方法都非常昂贵，因此对很多人来说都不是一个选择。正是在这种环境下，NewSQL系统应运而生。</p>\n<h2 id=\"2-NewSQL的崛起\"><a href=\"#2-NewSQL的崛起\" class=\"headerlink\" title=\"2. NewSQL的崛起\"></a>2. NewSQL的崛起</h2><p>我们对NewSQL的定义是，它们是一类现代关系型DBMS，试图为OLTP读写工作负载提供与NoSQL相同的可扩展性能，同时仍然保持事务的ACID保证。</p>\n<p>换句话说，这些系统希望实现与2000年代的NoSQL DBMS一样的可扩展性，但仍然保持1970-80年代的传统DBMS的关系模型（带SQL）和事务支持。</p>\n<p>这使得应用程序可以执行大量的并发事务来获取新的信息，并使用SQL（代替专有的API）修改数据库的状态。</p>\n<p>如果一个应用程序使用了NewSQL DBMS，那么开发人员就不需要像在NoSQL系统中那样编写逻辑来处理最终一致的更新。</p>\n<p>正如我们在下面讨论的那样，这种解释涵盖了许多学术和商业系统。</p>\n<p><br><br>我们注意到，在2000年代中期，有一些人认为符合这个标准的数据仓库DBMS出现了（如Vertica、Greenplum、Aster Data）。</p>\n<p>这些DBMS针对的是在线分析处理（OLAP）工作负载，不应该被认为是NewSQL系统。</p>\n<p>OLAP DBMS专注于执行复杂的只读查询（即聚合、多路join），这些查询需要很长时间来处理大数据集（例如，几秒钟甚至几分钟）。</p>\n<p>这些查询中的每个查询都可能与前者有明显的不同。</p>\n<p>另一方面，NewSQL DBMS所针对的应用的特点是执行读写事务，这些事务(1)是短暂的(即没有用户停顿)，(2)使用索引查找触及一小部分数据(即没有完整的表扫描或大型分布式join)，(3)是重复性的(即用不同的输入执行相同的查询)。</p>\n<p>其他的人认为，NewSQL系统的实现必须使用(1)无锁并发控制方案和(2)无共享的分布式架构。</p>\n<p>所有我们在第3节中将其归类为NewSQL的DBMS确实具有这些属性，因此我们同意这一定义。</p>\n<h2 id=\"3-NewSQL分类\"><a href=\"#3-NewSQL分类\" class=\"headerlink\" title=\"3. NewSQL分类\"></a>3. NewSQL分类</h2><p>鉴于上述定义，我们现在来看看今天的NewSQL DBMS的情况。</p>\n<p>为了简化分析，我们将根据系统的优点对系统进行分类。</p>\n<p>我们认为最能代表NewSQL系统的三类是：(1)使用新的架构从头开始构建的新型系统，(2)重新实现与Google等人在2000年代开发的分片基础架构相同的中间件，以及(3)同样基于新架构的云计算供应商提供的数据库即服务。</p>\n<p><br><br>两位作者之前都将替换现有的单节点DBMS的存储引擎的方案纳入了我们对NewSQL系统的分类中。</p>\n<p>其中最常见的例子是对MySQL默认的InnoDB存储引擎的替代（例如TokuDB、ScaleDB、Akiban、deepSQL）。</p>\n<p>使用新引擎的好处是，企业可以获得更好的性能，而不需要改变他们的应用中的任何东西，并且仍然可以利用DBMS的现有生态系统（如工具、API）。</p>\n<p>其中最有趣的是ScaleDB，因为它通过在存储引擎之间重新分配执行，在不使用中间件的情况下提供了透明的分片，而不需要使用中间件；不过，该公司后来转向了另一个领域。</p>\n<p>除了MySQL之外，还有其他类似的系统扩展。</p>\n<p>微软为SQL Server的内存中的Hekaton OLTP引擎几乎与传统的磁盘驻留表无缝集成。</p>\n<p>其他的引擎则使用Postgres的外来数据封装器和API钩子来实现相同类型的集成，但以OLAP工作负载为目标（如Vitesse、CitusDB）。</p>\n<p><br><br>我们现在断定，这样的存储引擎和单节点DBMS的扩展并不代表NewSQL系统，因此我们将其从我们的分类中省略。</p>\n<p>MySQL的InnoDB在可靠性和性能方面已经有了很大的改进，所以切换到另一个引擎用于OLTP应用的好处并不明显。</p>\n<p>我们承认，从面向行的InnoDB引擎切换到OLAP工作负载的列存储引擎的好处更明显（例如Infobright、InfiniDB）。</p>\n<p>但总的来说，针对OLTP工作负载的MySQL存储引擎替换业务是失败的数据库项目的墓地。</p>\n<h3 id=\"3-1-采用新型架构\"><a href=\"#3-1-采用新型架构\" class=\"headerlink\" title=\"3.1 采用新型架构\"></a>3.1 采用新型架构</h3><p>这一类包含了对我们来说最有趣的NewSQL系统，因为它们都是从头开始构建的。</p>\n<p>也就是说，它们不是扩展现有的系统（例如，基于微软SQL Server的Hekaton），而是从一个新的代码库中设计出来的，没有传统系统的任何架构包袱。</p>\n<p>这一类中的所有DBMS都是基于分布式架构的，它们在shared-nothing的架构上运行，并包含支持多节点并发控制、基于复制的错误容忍、流程控制和分布式查询处理的组件。</p>\n<p>使用为分布式处理而构建的新DBMS的优势在于，系统的所有部分都可以针对多节点环境进行优化。</p>\n<p>这包括查询优化器和节点之间的通信协议等。</p>\n<p>例如，大多数NewSQL DBMS能够在节点之间直接发送节点内的查询数据，而不是像一些中间件系统那样将数据路由到中心位置。</p>\n<p><br><br>这类DBMS中的每一个DBMS（除了Google Spanner之外）也都管理着自己的主存储系统，无论是内存中的还是磁盘上的。</p>\n<p>这意味着他们用一个定制的存储引擎，并在其中分配数据库，而不是依赖现成的分布式文件系统（如HDFS）或存储结构（如Apache Ignite）。</p>\n<p>这是它们的非常重要的一点，因为它允许DBMS “把查询送到数据中去”，而不是 “把数据带到查询中去”，这样做的结果是大大减少了网络流量，因为传输查询通常比必须把数据（不仅仅是图元，还包括索引和物化视图）传输到计算中去的网络流量要少得多。</p>\n<p><br><br>管理自己的存储也使 DBMS 能够采用比 HDFS 中使用的基于块的复制方案更复杂的复制方案。</p>\n<p>一般来说，它允许这些DBMS比其他建立在其他现有技术之上的系统获得更好的性能；这方面的例子包括像Trafodion和Splice Machine这样的 “SQL on Hadoop “系统，它们在Hbase之上提供事务处理。</p>\n<p>因此，我们认为这样的系统不应该被认为是NewSQL。</p>\n<p><br><br>但是，使用基于新架构的DBMS也有其弊端。</p>\n<p>最重要的是，很多公司对采用太新的技术抱有戒心，还未被大规模使用。</p>\n<p>这意味着与更受欢迎的DBMS厂商相比，有经验的人要少得多。</p>\n<p>这也意味着企业将有可能无法访问现有管理和报告工具。</p>\n<p>一些DBMS，如Clustrix和MemSQL，通过保持与MySQL线协议的兼容性来避免这个问题。</p>\n<p><strong>比如： Clustrix, CockroachDB, Google Spanner, H-Store, HyPer, MemSQL, NuoDB, SAP HANA, VoltDB.</strong></p>\n<h3 id=\"3-2-透明的分片中间件\"><a href=\"#3-2-透明的分片中间件\" class=\"headerlink\" title=\"3.2 透明的分片中间件\"></a>3.2 透明的分片中间件</h3><p>现在有一些产品可以提供与eBay、Google、Facebook和其他公司在2000年代开发的同类分片中间件功能。</p>\n<p>这些产品允许一个公司将数据库分割成多个分片，这些分片存储在一个单节点的DBMS实例集群中。</p>\n<p>Sharding技术与20世纪90年代的数据库联盟技术不同，因为每个节点(1)运行着相同的DBMS，(2)只有整体数据库的一部分，(3)不是由应用程序独立地访问和更新。</p>\n<p><br><br>集中化的中间件组件负责路由查询、协同管理事务，以及管理节点间的数据放置、复制和分区。</p>\n<p>通常，每个DBMS节点上都安装有一个与中间件通信的shim层。</p>\n<p>这个组件负责在其本地DBMS实例中代表中间件执行查询并返回结果。</p>\n<p>所有这些加在一起，使得中间件产品可以向应用程序展示一个单一的逻辑数据库，而不需要修改底层DBMS。</p>\n<p><br><br>使用分片式中间件的关键优势在于，它们通常是对已经在使用现有单节点DBMS的应用程序的即插即用替代。</p>\n<p>开发人员不需要对他们的应用程序做任何改动，就可以使用新的分片数据库。</p>\n<p>中间件系统最常见的目标是MySQL。</p>\n<p>这意味着，为了与MySQL兼容，中间件必须支持MySQL线协议。</p>\n<p>Oracle提供了MySQL Proxy和Fabric工具包来完成这个任务，但其他的人也编写了自己的协议处理程序库，以避免GPL许可问题。</p>\n<p><br><br>尽管中间件使企业很容易将数据库扩展到多个节点上，但这样的系统仍然必须在每个节点上使用传统的DBMS（如MySQL、Postgres、Oracle）。</p>\n<p>这些DBMS是基于20世纪70年代开发的面向磁盘的架构，因此它们不能像一些基于新架构的NewSQL系统中那样，使用面向内存的存储管理器或并发控制方案进行优化。</p>\n<p>之前的研究表明，面向磁盘的架构的组件是一个重要的障碍，使这些传统的DBMS无法扩展到更高的CPU内核数和更大的内存容量。</p>\n<p>中间件的方法也会在碎片化的节点上产生冗余的查询规划和优化（即在中间件上和单个DBMS节点上分别进行一次查询），但这也允许每个节点对每个查询应用自己的本地优化。</p>\n<p><strong>例如: AgilData Scalable Cluster 2, MariaDB MaxScale, ScaleArc, ScaleBase3.</strong></p>\n<h3 id=\"3-3-Database-as-a-Service\"><a href=\"#3-3-Database-as-a-Service\" class=\"headerlink\" title=\"3.3 Database-as-a-Service\"></a>3.3 Database-as-a-Service</h3><p>最后，还有一些云计算供应商提供NewSQL数据库即服务（DBaaS）产品。</p>\n<p>通过这些服务，企业无需在自己的私有硬件或云托管的虚拟机（VM）上维护DBMS。</p>\n<p>相反，DBaaS提供商负责维护数据库的物理配置，包括系统调整（如缓冲池大小）、复制和备份。</p>\n<p>客户将获得一个连接到DBMS的URL，以及一个仪表板或API来控制数据库系统。</p>\n<p><br><br>DBaaS的用户根据其预期的应用程序的资源利用率支付费用。</p>\n<p>由于数据库不同的查询语句在使用计算资源的方式上有很大的差异，因此DBaaS提供商通常不会像在面向块的存储服务（如亚马逊的S3、谷歌的云存储）中那样，以同样的方式来计量查询调用。</p>\n<p>取而代之的是，客户订阅一个定价层，该定价层指定了提供商将保证的最大资源利用率阈值（例如，存储大小、计算能力、内存分配）。</p>\n<p><br><br>与云计算的因素一样，由于经济规模限制，DBaaS领域的主要参与者仍然是最大的那几个公司。</p>\n<p>但几乎所有的DBaaS都只是提供了传统的单节点DBMS（如MySQL）的托管实例：著名的例子包括Google Cloud SQL、Microsoft Azure SQL、Rackspace云数据库和Sales-force Heroku。</p>\n<p>我们不认为这些都是NewSQL系统，因为它们使用的是基于20世纪70年代架构的面向磁盘的DBMS。</p>\n<p>一些厂商，如微软，对他们的DBMS进行了改造，为多租户部署提供了更好的支持。</p>\n<p><br><br>相反，我们只把那些基于新架构的DBaaS产品视为NewSQL。</p>\n<p>最显著的例子是Amazon的Aurora为他们的MySQL RDS。</p>\n<p>与InnoDB相比，它的显著特点是使用日志结构化存储管理器来提高I/O并行性。</p>\n<p><br><br>还有一些公司不维护自己的数据中心，而是销售运行在这些公共云平台之上的DBaaS软件。</p>\n<p>ClearDB提供了自己的定制DBaaS，可以部署在所有主要的云平台上。</p>\n<p>这样做的好处是可以将数据库分布在同一地理区域的不同供应商之间，避免因服务中断而造成的停机。</p>\n<p><br><br>截至2016年，Aurora和ClearDB是这个NewSQL类别中仅有的两个产品。</p>\n<p>我们注意到，这个领域的几家公司已经失败了（例如，GenieDB、Xeround），迫使他们的客户争相寻找新的提供商，并在这些DBaaS被关闭之前将数据迁移出这些DBaaS。</p>\n<p>我们将其失败的原因归结为超前于市场需求，以及被各大厂商压价。</p>\n<p><strong> Examples: Amazon Aurora, ClearDB.</strong></p>\n<h2 id=\"4-NewSQL现状\"><a href=\"#4-NewSQL现状\" class=\"headerlink\" title=\"4. NewSQL现状\"></a>4. NewSQL现状</h2><p>接下来，我们讨论NewSQL DBMS的特点，以说明这些系统中的新奇之处（如果有的话）。</p>\n<p>我们的分析总结如表1所示。</p>\n<p><img src=\"/images/NewSql论文/1.png\" alt=\"image-20200525195922408\" style=\"zoom:50%;\"></p>\n<h3 id=\"4-1-内存存储\"><a href=\"#4-1-内存存储\" class=\"headerlink\" title=\"4.1 内存存储\"></a>4.1 内存存储</h3><p>所有主要的DBMS都使用了基于70年代原始DBMS的面向磁盘的存储架构。</p>\n<p>在这些系统中，数据库的主要存储位置被认为是在一个可块寻址的耐用存储设备上，如SSD或HDD。</p>\n<p>由于对这些存储设备的读写速度很慢，因此DBMS使用内存来缓存从磁盘上读取的块，并缓冲事务的更新。</p>\n<p>这是很有必要的，因为历史上，内存的价格要贵得多，而且容量有限。</p>\n<p>然而，当下容量和价格已经到了可以完全用内存来存储所有的OLTP数据库的地步，但最大的OLTP数据库除外。</p>\n<p>这种方法的好处是，它可以实现某些优化，因为DBMS不再需要假设一个事务可能在任何时候访问不在内存中的数据而不得不停滞不前。</p>\n<p>因此，这些系统可以获得更好的性能，因为许多处理这些情况所需要的组件，如缓冲池管理器或重量级并发控制方案等，都不需要了。</p>\n<p><br><br>有几种基于内存存储架构的NewSQL DBMS，包括学术型（如H-Store、HyPer）和商业型（如MemSQL、SAP HANA、VoltDB）系统。</p>\n<p>这些系统在OLTP工作负载方面的表现明显优于基于磁盘的DBMS，因为使用内存的原因。</p>\n<p><br><br>完全在内存中存储数据库的想法并不是一个新的想法。</p>\n<p>20世纪80年代初，威斯康星大学麦迪逊分校的开创性研究为主内存DBMS的许多方面奠定了基础，包括索引、查询处理和恢复算法。</p>\n<p>在这十年中，第一个分布式主内存DBMS-&gt;PRISMA/DB，也是在这十年中开发出来的。<br>第一批商业化的主内存DBMS出现在20世纪90年代，如Altibase、Oracle的TimesTen和AT&amp;T的DataBlitz。</p>\n<p><br><br>在内存NewSQL系统中，有一件事是具有创新的，那就是能够将数据库的子集持久化到持久化存储中，以减少其内存占用。</p>\n<p>这使得DBMS能够支持比可用内存更大的数据库，而不必切换回面向磁盘的架构。</p>\n<p>一般的方法是在系统内部使用一个内部跟踪机制来识别哪些数据行不再被访问，然后选择它们进行持久化。</p>\n<p>H-Store的反缓存组件将冷数据移动到磁盘存储，然后在数据库中安装一个带有原始数据位置的 “墓碑 “记录。</p>\n<p>当一个事务试图通过其中一个墓碑访问一行记录时，它会被中止，然后一个单独的线程异步检索该记录并将其移回内存。</p>\n<p>另一个支持大于内存的数据库的变体是EPFL的一个学术项目，它在VoltDB中使用操作系统虚拟内存分页。</p>\n<p>为了避免误报，所有这些DBMS都在数据库的索引中保留了被持久化的数据行的键，这抑制了那些有许多二级索引的应用程序的潜在内存节省。（就是有许多二级索引的表的也没怎么节省内存）</p>\n<p>虽然不是NewSQL DBMS，但微软为Hekaton开发的Project Siberia在每个索引中保留了一个Bloom过滤器，以减少跟踪被持久化的数据行的内存存储开销。</p>\n<p><br><br>另一个对内存数据库采取不同的方法的是MemSQL，管理员可以手动指示DBMS以列式格式存储一个表。</p>\n<p>MemSQL不为这些磁盘驻留的数据行维护任何内存跟踪元数据。</p>\n<p>它以日志结构化(log-structured)存储的方式组织这些数据，以减少更新的开销，因为在OLAP数据仓库中，更新速度传统上是很慢的。</p>\n<h3 id=\"4-2-分区-分片\"><a href=\"#4-2-分区-分片\" class=\"headerlink\" title=\"4.2 分区/分片\"></a>4.2 分区/分片</h3><p>几乎所有的分布式NewSQL DBMS 的扩展方式都是将数据库分割成不相干的子集，称为分区或分片。</p>\n<p><br><br>基于分区数据库上的分布式事务处理并不是一个新概念。</p>\n<p>这些系统的许多基本原理来自于伟大的Phil Bernstein（和其他人）在1970年代末的SDD-1项目中的开创性工作。</p>\n<p>在20世纪80年代初，两个开创性的单节点DBMS的背后团队—System R和INGRES，也都创建了各自系统的分布式版本。</p>\n<p>IBM的R*是一个类似于SDD-1的shared-nothing、面向磁盘的分布式DBMS。</p>\n<p>INGRES的分布式版本的动态查询优化算法将分布式查询递归分解成更小的块而被人记住。</p>\n<p>后来，威斯康星大学麦迪逊分校的GAMMA项目探索了不同的分区策略。</p>\n<p><br><br>但是，这些早期的分布式DBMS始终没有得到普及，原因有两个。</p>\n<p>其中第一个原因是20世纪的计算硬件非常昂贵，以至于大多数公司无法负担得起在集群机器上部署数据库。</p>\n<p>第二个问题是，对高性能分布式DBMS的应用需求根本不存在。</p>\n<p>当时，DBMS的预期峰值吞吐量通常以每秒几十到几百个事务来衡量。</p>\n<p>而当今社会，这两种假设都不存在了。</p>\n<p>现在创建一个大规模的、数据密集型的应用比以往任何时候都要容易，部分原因在于开源的分布式系统工具、云计算平台和大量的廉价的移动设备的出现。</p>\n<p><br><br>数据库的表被水平地分成多个分片，其边界基于表的一个（或多个）列的值（即分区属性）。</p>\n<p>DBMS根据这些属性的值将每行数据分配到一个分片，使用范围或哈希分区法将每行记录分配到一个分片。</p>\n<p>来自多个表的相关分片被组合在一起，形成一个由单个节点管理的分区。</p>\n<p>该节点负责执行任何需要访问其分区中存储的数据的查询。</p>\n<p>只有DBaaS系统（Amazon Aurora、ClearDB）不支持这种类型的分区。</p>\n<p><br><br>理想情况下，DBMS也应该能够将一个查询的执行分配到多个分区，然后将它们的结果合并成一个结果。</p>\n<p>除了ScaleArc之外，所有支持原生分区的NewSQL系统都提供了这种功能。</p>\n<p><br><br>许多OLTP应用的数据库都有一个关键的属性，使其可以进行分区。</p>\n<p>它们的数据库模式可以被移植到类似于树状的结构中，其中树的子节点与树根有外键关系。</p>\n<p>然后根据这些关系中所涉及的属性对表进行分区，这样一来，单个实体的所有数据都被共同定位在同一个分区中。</p>\n<p>例如，树的根可以是客户表，而数据库的分区是这样的，每个客户以及他们的订单记录和账户信息都存储在一起。</p>\n<p>这样做的好处是，它允许大多数（如果不是全部）事务只需要在一个分区访问数据。</p>\n<p>这反过来又降低了系统的通信开销，因为它不需要使用原子承诺协议（例如，两阶段承诺）来确保事务在不同的节点上正确完成。</p>\n<p><br><br>偏离同源集群节点架构的NewSQL DBMS有NuoDB和MemSQL。</p>\n<p>对于NuoDB来说，它指定一个或多个节点作为存储管理器（SM），每个节点存储数据库的一个分区。</p>\n<p>SM的分区分为块（NuoDB中称为 “原子”）。</p>\n<p>集群中所有其他节点都被指定为事务引擎（TE），作为原子的内存缓存。</p>\n<p>为了处理一个查询，一个TE节点会检索它所需要的所有原子（从相应的SMs或其他TE中检索）。</p>\n<p>TE 会在数据行上获取写锁，然后将原子的任何更改广播给其他 TE 和 SM。</p>\n<p>为了避免原子在节点之间来回移动，NuoDB采用了负载平衡方案来确保一起使用的数据经常驻留在同一个TE上。</p>\n<p>这意味着NuoDB最终采用了和其他分布式DBMS一样的分区方案，但不需要预先对数据库进行分区，也不需要识别表之间的关系。</p>\n<p><br><br>MemSQL也使用了类似的异构架构，由只执行的聚合节点和存储实际数据的叶子节点组成。</p>\n<p>这两个系统的区别在于它们如何减少从存储节点拉到执行节点的数据量。</p>\n<p>在NuoDB中，TE缓存数据（atoms）来减少从SM读取的数据量。</p>\n<p>MemSQL的聚合器节点不缓存任何数据，但叶子节点执行部分查询，以减少发送至聚合器节点的数据量；而在NuoDB中，这一点是不可能的，因为SM只是一个数据存储。</p>\n<p><br><br>这两个系统能够在DBMS的集群中增加额外的执行资源（NuoDB的TE节点、MemSQL的聚合节点），而不需要重新划分数据库。</p>\n<p>SAP HANA的一个研究原型也探索了使用这种方法。</p>\n<p>然而，这样的异构架构在性能或操作复杂性方面是否优于同源架构（即每个节点既存储数据又执行查询），还有待观察。</p>\n<p><br><br>NewSQL系统中分区的另一个创新的方面是，有些系统支持实时迁移。</p>\n<p>这使得DBMS可以在物理资源之间移动数据来重新平衡和缓解热点，或者在不中断服务的情况下增加/减少DBMS的容量。</p>\n<p>这与NoSQL系统中的再平衡类似，但难度较大，因为NewSQL DBMS在迁移过程中必须保持事务的ACID。</p>\n<p>DBMS有两种方法来实现这个目标。</p>\n<p>第一种是将数据库组织成许多粗粒度的 “虚拟”（即逻辑）分区，这些分区分布在物理节点之间。</p>\n<p>然后，当DBMS需要重新平衡时，它将这些虚拟分区在节点之间移动。这是Clustrix和AgilData，以及Cassandra和DynamoDB等NoSQL系统中使用的方法。</p>\n<p>另一种方法是DBMS通过范围分区来重新分配单个图例或图例组，以执行更精细的再平衡。这类似于MongoDB NoSQL DBMS中的自动分片功能。它在ScaleBase和H-Store等系统中得到了应用。</p>\n<h3 id=\"4-3-并发控制\"><a href=\"#4-3-并发控制\" class=\"headerlink\" title=\"4.3 并发控制\"></a>4.3 并发控制</h3><p>并发控制方案是事务处理DBMS中最重要的实现细节，因为它几乎影响到系统的所有方面。</p>\n<p>并发控制允许终端用户并发的访问数据库，同时给每个用户一种假象，让他们以为在只有自己在单独执行事务。</p>\n<p>它本质上提供了系统中的原子性和隔离保证，因此它影响着整个系统的行为。</p>\n<p><br><br>除了系统采用哪种并发控制方案外，分布式DBMS设计的另一个重要方面是系统采用中心化还是去中心化事务协调协议。</p>\n<p>在一个采用中心化协调器的系统中，所有事务的操作都必须经过协调器，然后由协调器决定是否允许事务进行。</p>\n<p>这与20世纪70-80年代的TP监控器（如IBM CICS、Oracle Tuxedo）采用的方法相同。</p>\n<p>在一个去中心化的系统中，每个节点维护访问它所管理的数据的事务的状态。<br>然后，各节点之间必须相互协调，以确定并发事务是否冲突。</p>\n<p>去中心化协调器的可扩展性更好，但要求DBMS节点中的时钟高度同步，以产生全局性的事务排序。</p>\n<p><br><br>1970-80年代的第一批分布式DBMS使用了两阶段锁定（2PL）方案。</p>\n<p>SDD-1是第一个专门为分布式事务处理而设计的DBMS，它是由一个中心化协调器管理的共享节点集群。</p>\n<p>IBM的R*与SDD-1类似，但主要的区别在于R*中事务的协调是完全去中心化的；它使用分布式的2PL协议，即事务直接在节点上锁定其访问的数据项。</p>\n<p>分布式版本的INGRES也使用了去中心化2PL，并采用了中心化死锁检测。</p>\n<p><br><br>因为处理死锁的复杂性，几乎所有基于新架构的NewSQL系统都放弃了2PL。</p>\n<p>相反，目前的趋势是使用时间戳顺序（TO）并发控制的各种变体方案，此方案中，DBMS假定事务不会以非线性顺序的执行。</p>\n<p>NewSQL系统中最广泛使用的协议是去中心化的多版本并发控制（MVCC），当一行数据被事务更新时，DBMS会在数据库中创建一行新版本的数据。</p>\n<p>维护多个版本允许某个事务在另一个事务更新相同的数据时仍能完成。</p>\n<p>它还允许长期运行的、只读的事务不对写入者进行阻塞。</p>\n<p>几乎所有基于新架构的NewSQL系统，如MemSQL、HyPer、HANA和CockroachDB，都使用了这个协议。虽然这些系统在其MVCC实现中使用了一些工程优化和微调来提高性能，但该方案的基本概念并不新鲜。</p>\n<p>第一个描述MVCC的已知工作是1979年的一篇MIT博士论文[49]，而最早使用MVCC的商用DBMS是Digital公司的VAX Rdb和80年代初的InterBase。</p>\n<p>我们注意到，InterBase的架构是由Jim Starkey设计的，他也是NuoDB和失败的Falcon MySQL存储引擎项目的原设计者。</p>\n<p><br><br>其他系统则组合了2PL和MVCC。</p>\n<p>使用这种方案，事务仍然必须在2PL方案下获得锁来修改数据库。</p>\n<p>当一个事务修改一条记录时，DBMS会创建一个新的记录版本，就像使用MVCC一样。</p>\n<p>这种方案允许只读查询，从而避免了获取锁，从而不阻塞写事务。这种方法最著名的实现是MySQL的InnoDB，但它也在Google的Spanner、NuoDB和Clustrix中使用。</p>\n<p>NuoDB在原有的MVCC的基础上进行了改进，采用了gossip协议在节点之间广播版本信息。</p>\n<p><br><br>所有的中间件和DBaaS服务都继承了其底层DBMS体系结构的并发控制方案；</p>\n<p>由于它们大多使用MySQL，这使得它们都是带MVCC的2PL方案。</p>\n<p><br><br>我们认为Spanner中的并发控制实现（连同它的后代F1和SpannerSQL）是NewSQL系统中最新颖的方案之一。</p>\n<p>实际方案本身是基于前几十年开发的2PL和MVCC组合。但Spanner的不同之处在于，它使用硬件设备（如GPS、原子钟）进行高精度时钟同步。</p>\n<p>DBMS使用这些时钟来为事务分配时间戳，以便在广域网络上实现多版本数据库的一致视图。</p>\n<p>CockroachDB也声称要为跨数据中心的事务提供与Spanner相同的一致性，但没有使用原子钟。<br>相反，它们依赖于一种混合时钟协议，将松散同步的硬件时钟和逻辑计数器结合在一起。</p>\n<p><br><br>Spanner还有一点值得注意，就是它预示着Google重新转向使用事务处理最关键的服务。</p>\n<p>Spanner的作者甚至表示，让他们的应用程序员来处理由于过度使用事务而导致的性能问题，比起像NoSQL DBMS那样编写代码来处理缺乏事务的问题要好得多。</p>\n<p><br><br>最后，唯一没有使用MVCC变体的商用NewSQL DBMS是VoltDB。</p>\n<p>这个系统仍然使用TO并发控制，但它没有像MVCC那样将事务交织在一起，而是安排事务在每个分区一次执行。</p>\n<p>它还采用了混合架构，其中单分区事务以分散的方式进行调度，但多分区事务则由集中式协调器调度。</p>\n<p>VoltDB根据逻辑时间戳对事务进行排序，然后在轮到事务时安排它们在某个分区执行。</p>\n<p>当一个事务在一个分区执行时，它对该分区的所有数据都有独占的访问权限，因此系统不需要在其数据结构上设置细粒度的锁和锁存。</p>\n<p>这使得只需要访问单一分区的事务能够有效地执行，因为没有来自其他事务的争夺。</p>\n<p>基于分区的并发控制的缺点是，如果事务跨越多个分区，它的工作效果并不好，因为网络通信延迟会导致节点在等待消息的时候闲置。</p>\n<p>这种基于分区的并发控制并不是一个新的想法。</p>\n<p>它的一个早期变体是由Hector Garcia-Molina[34]在1992年的一篇论文中首次提出，并在20世纪90年代末的kdb系统[62]和H-Store（也就是VoltDB的学术前身）中实现。</p>\n<p><br><br>总的来说，我们发现NewSQL系统中的核心并发控制方案除了让这些算法在现代硬件和分布式操作环境下很好地运行外，并没有什么明显的新意。</p>\n<h3 id=\"4-4-二级索引\"><a href=\"#4-4-二级索引\" class=\"headerlink\" title=\"4.4 二级索引\"></a>4.4 二级索引</h3><p>二级索引是一个表所有属性的子集，这些属性和主键不同。</p>\n<p>这使得DBMS能够支持超过主键或分区键查询性能的快速查询。</p>\n<p>在非分区DBMS中支持二级索引是不值得拿出来说的，因为整个数据库位于单一节点上。</p>\n<p>二级索引在非分区DBMS中面临的挑战是，它们不能以与数据库其他部分相同的方式进行分区。</p>\n<p>举个例子，假设数据库的表是根据客户表的主键来分区的。</p>\n<p>但又有一些查询想要进行从客户的电子邮件地址到账户反向查询。</p>\n<p>由于表是根据主键分区的，所以DBMS必须将这些查询广播到每一个节点，这显然是低效的。</p>\n<p><br></p>\n<p>在分布式DBMS中支持二级索引的两个设计问题是：</p>\n<p>(1)系统将在哪里存储二级索引；(2)如何在事务的上下文中维护它们。</p>\n<p>在一个具有中心化协调器的系统中，就像sharding中间件一样，二级索引可以同时驻留在协调器节点和分片节点上。</p>\n<p>这种方法的优点是，整个系统中只有一个版本的索引，因此更容易维护。</p>\n<p><br></p>\n<p>所有基于新架构的NewSQL系统都是去中心化的，并且使用分区二级索引。</p>\n<p>这意味着每个节点存储索引的一部分，而不是每个节点都有一个完整的副本。</p>\n<p>分区索引和复制索引之间的权衡是，对于前者，查询可能需要跨越多个节点才能找到他们要找的东西，但如果一个事务更新一个索引，它只需要修改一个节点。</p>\n<p>在复制索引中，角色是相反的：查找查询可以只由集群中的一个节点来满足，但任何时候一个事务修改二级索引底层表中引用的属性（即键或值）时，DBMS必须执行一个分布式事务，更新索引的所有副本。</p>\n<p><br>Clustrix是一个混合了这两个概念的去中心化二级索引的例子。</p>\n<p>DBMS首先在每个节点上存储一个冗余的，粗粒度的（即，基于范围的）索引，它将值映射到分区。</p>\n<p>这个映射让DBMS使用一个不是表的分区属性的属性将查询路由到适当的节点。</p>\n<p>然后，这些查询将访问该节点的第二个分区索引，该索引将精确值映射到某一行数据。</p>\n<p>这种两层方法重新减少了在整个集群中保持复制索引同步所需的协调量，因为它只映射范围而不是单个值。</p>\n<p><br></p>\n<p>当使用不支持二级索引的NewSQL DBMS时，开发人员创建二级索引最常见的方法是使用内存中的分布式缓存部署索引，例如Memcached。</p>\n<p>但是使用外部系统需要应用程序维护缓存，因为DBMS不会自动失效外部缓存。</p>\n<h3 id=\"4-5-副本\"><a href=\"#4-5-副本\" class=\"headerlink\" title=\"4.5 副本\"></a>4.5 副本</h3><p>一个公司能够保证其OLTP应用的高可用和数据持久化的最好方法是为他们的数据库建立副本。</p>\n<p>所有现代DBMS，包括NewSQL系统，都支持某种副本机制。</p>\n<p>DBaaS在这方面具有明显的优势，因为它们向客户隐藏了设置副本的所有粗暴细节。</p>\n<p>它们使得部署一个有副本的DBMS变得很容易，管理员不必担心日志传输和确保节点同步。</p>\n<p><br></p>\n<p>在数据库复制方面，有两个设计方案需要决策。</p>\n<p>第一个是DBMS如何在节点间确保数据一致性。</p>\n<p>在一个强一致性的DBMS中，所有的写入操作必须在所有的副本中被确认和执行，这个事务才算成功执行。</p>\n<p>这种方法的优点是，副本在执行读查询时仍然是一致的。</p>\n<p>也就是说，如果应用程序收到了一个事务已经提交的确认，那么该事务所做的任何修改对未来的任何后续事务都是可见的，无论他们访问的是哪个DBMS节点。</p>\n<p>这也意味着，当一个副本失败时，不会丢失更新，因为所有其他节点都是同步的。</p>\n<p>但是维持这种同步重新要求DBMS使用原子承诺协议（例如，两阶段提交）来确保所有的副本与事务的结果一致，这有额外的开销，并且如果一个节点失败或者有网络分区延迟，可能会导致停滞。</p>\n<p>这就是为什么NoSQL系统选择弱一致性模型（也称为最终一致性），在这种模型中，即使有副本没有确认修改成功，DBMS也可以通知应用程序已经执行成功。</p>\n<p><br></p>\n<p>我们所知道的所有NewSQL系统都支持强一致的复制。</p>\n<p>但是这些系统如何保证这种一致性并没有什么创新。</p>\n<p>DBMS的状态机复制的基本原理早在20世纪70年代就被研究出来了（引用37，42）。</p>\n<p>NonStop SQL是20世纪80年代建立的第一批使用强一致性复制以这种同样的方式提供容错的分布式DBMS之一（引用59）。</p>\n<p><br></p>\n<p>除了DBMS何时向副本传播更新的策略外，对于DBMS如何执行这种传播，还有两种不同的执行模式。</p>\n<p>第一种，称为主动-主动复制，即每个副本节点同时处理同一个请求。</p>\n<p>例如，当一个事务执行一个查询时，DBMS会在所有的副本节点上并行执行该查询。</p>\n<p>这与主动-被动复制不同，主动被动复制是先在单个节点处理一个请求，然后DBMS将结果状态传输到其他副本。</p>\n<p>大多数NewSQL DBMS实现了第二种方法，因为它们使用了一个非确定性的并发控制方案。</p>\n<p>这意味着它们不能在查询到达leader副本时向其他副本发送查询，因为它们可能会在其他副本上以不同的顺序被执行，导致数据库的状态会在每个副本上出现分歧。</p>\n<p>这是因为它们的执行顺序取决于几个因素，包括网络延迟、缓存停顿和时钟偏移。</p>\n<p><br></p>\n<p>而确定性的DBMS（如H-Store、VoltDB、ClearDB）则不执行这些额外的协调步骤。</p>\n<p>这是因为DBMS保证事务的操作在每个副本上以相同的顺序执行，从而保证数据库的状态是相同的[44]。</p>\n<p>VoltDB和ClearDB还确保应用程序不会执行利用DBMS外部信息源的查询，而这些信息源在每个副本上可能是不同的（例如，将时间戳字段设置为本地系统时钟）。</p>\n<p><br></p>\n<p>NewSQL系统与以往学术界以外的工作不同的一个方面是考虑在广域网（WAN）上进行复制。</p>\n<p>这是现代操作环境的一个副产品，现在，将系统部署在地理差异较大的多个数据中心是轻而易举的事情。</p>\n<p>任何NewSQL DBMS都可以被配置为通过广域网提供数据的同步更新，但这将会对正常的操作造成明显的减速。</p>\n<p>因此，它们反而提供了异步复制方法。</p>\n<p>据我们所知，Spanner和CockroachDB是唯一的提供了一个优化的复制方案的NewSQL系统，他们可以在广域网上进行强一致的复制。</p>\n<p>同样的，它们通过原子钟和GPS硬件时钟（在Spanner[24]的情况下）或混合时钟（在CockroachDB[41]的情况下）的组合来实现的。</p>\n<h3 id=\"4-6-崩溃恢复\"><a href=\"#4-6-崩溃恢复\" class=\"headerlink\" title=\"4.6 崩溃恢复\"></a>4.6 崩溃恢复</h3><p>NewSQL DBMS提供容错性的另一个重要功能是其崩溃恢复机制。</p>\n<p>但与传统的DBMS不同的是，传统DBMS容错的主要关注点是确保不丢失更新[47]，新的DBMS还必须尽量减少停机时间。因为现代网络应用系统要一直在线，而网站中断的代价很高。</p>\n<p>在没有副本的单节点系统中，传统的恢复方法是，当DBMS在崩溃后重新上线时，它从磁盘上加载最后一个检查点，然后重播它的写前日志（WAL），重新将数据库的状态转到崩溃时的状态。  </p>\n<p>这种方法的典范方法被称为ARIES[47]，由IBM研究人员在20世纪90年代发明。所有主要的DBMS都实现了ARIES的某种变体。</p>\n<p><br></p>\n<p>然而，在有副本的分布式DBMS中，传统的单节点方法并不直接适用。</p>\n<p>这是因为当主节点崩溃时，系统会将其中一个从节点作为新的主节点。当上一个主节点重新上线时，它不能只加载它的最后一个检查点并重新运行它的WAL，因为DBMS还在继续处理事务，因此数据库的状态已经向前移动。</p>\n<p>恢复中的节点需要从新的主节点（以及可能的其他副本）获取它在宕机时错过的更新。</p>\n<p>有两种潜在的方法可以做到这一点。</p>\n<p>第一种是让恢复节点从本地存储中加载它的最后一个检查点和WAL，然后从其他节点提取它错过的日志条目。</p>\n<p>只要该节点处理日志的速度能快于新更新附加到它身上的速度，该节点最终会收敛到与其他复制节点相同的状态。</p>\n<p>如果DBMS使用物理或逻辑日志，这是有可能的，因为将日志更新直接应用于数据行的时间远远小于执行原始SQL语句的时间。</p>\n<p>为了减少恢复所需的时间，另一种选择是让恢复中的节点丢弃它的检查点，让系统取一个新的检查点，节点将从中恢复。这种方法的另外一个好处是，在DBMS中也可以使用这种相同的机制来增加一个新的复制节点。</p>\n<p><br>中间件和DBaaS系统依赖于其底层单节点DBMS的内置机制，但增加了额外的基础设施，用于领导者选举和其他管理功能。</p>\n<p>基于新架构的NewSQL系统使用现成的组件（如ZooKeeper、Raft）和自己对现有算法的定制实现（如Paxos）相结合。</p>\n<p>所有这些都是20世纪90年代以来商业分布式系统中的标准程序和技术。</p>\n<h2 id=\"未来趋势\"><a href=\"#未来趋势\" class=\"headerlink\" title=\"未来趋势\"></a>未来趋势</h2><p>我们预计，在不久的将来，数据库应用的下一个趋势是能够在新数据上执行分析查询和机器学习算法。</p>\n<p>这种工作方式，通俗地讲就是 “实时分析 “或混合事务分析处理(HTAP)，试图通过分析历史数据集与新数据的组合来推断洞察力和知识[35]。</p>\n<p>不同于前十年的传统商业智能业务只能对历史数据进行这种分析。</p>\n<p>在现代应用中，拥有较短的周转时间是很重要的，因为数据刚创建时具有巨大的价值，但这种价值会随着时间的推移而减少。</p>\n<p><br></p>\n<p>在数据库应用中支持HTAP管道的方法有三种：最常见的是部署单独的DBMS：一个用于事务，另一个用于分析查询。</p>\n<p>在这种架构下，前端OLTP DBMS存储了所有事务中产生的新信息。</p>\n<p>然后在后台，系统使用提取-转换-加载的方式将数据从这个OLTP DBMS迁移到第二个后端数据仓库DBMS。</p>\n<p>应用程序在后端 DBMS 中执行所有复杂的 OLAP 查询，以避免减慢 OLTP 系统的速度。</p>\n<p>从 OLAP 系统生成的任何新信息都会被推送到前端 DBMS 中。</p>\n<p><br></p>\n<p>另一种盛行的系统设计，即所谓的lambda架构[45]，是使用一个独立的批处理系统（如Hadoop、Spark）来计算历史数据的综合视图，同时使用一个流处理系统（如Storm[61]、Spark Streaming[64]）来提供传入数据的视图。</p>\n<p>在这种分体式架构中，批处理系统定期重新扫描数据集，并将结果进行批量上传至流处理系统，然后流处理系统根据新的更新进行修改。</p>\n<p><br></p>\n<p>这两种方法的分叉环境本身就存在几个问题。</p>\n<p>最重要的是，在不同的系统之间传播变化所需的时间通常是以分钟甚至以小时为单位的。</p>\n<p>这种数据传输抑制了应用程序在数据库中输入数据时立即采取行动的能力。</p>\n<p>其次，部署和维护两个不同的DBMS的管理开销是不小的，因为据估计，人员费用几乎占到了一个大型数据库系统总成本的50%[50]。</p>\n<p>如果应用开发者要将不同数据库的数据结合起来，还需要为多个系统编写查询。</p>\n<p>一些系统，试图通过隐藏这种拆分系统架构来实现单一平台；一个例子是Splice Machine[16]，但这种方法还有其他技术问题，因为要把数据从OLTP系统（Hbase）复制到OLAP系统（Spark）中去。</p>\n<p><br></p>\n<p>第三种（我们认为更好的）方法是使用单一的HTAP DBMS，它支持OLTP工作负载的高吞吐量和低延迟需求，同时还允许复杂的、运行时间较长的OLAP查询对热数据（事务性）和冷数据（历史）进行操作。</p>\n<p>这些较新的HTAP系统与传统的通用DBMS的不同之处在于，它们结合了过去十年中专门的OLTP(如内存存储、无锁执行)和OLAP(如列式存储、矢量执行)系统的进步，但却在一个DBMS中。</p>\n<p><br>SAP HANA和MemSQL是第一个以HTAP系统自居的NewSQL DBMS。</p>\n<p>HANA通过在内部使用多个执行引擎来实现：一个引擎用于面向行的数据，更适合交易；另一个不同的引擎用于面向列的数据，更适合分析查询。</p>\n<p>MemSQL使用两个不同的存储管理器（一个用于行，一个用于列），但将它们混合在一个执行引擎中。</p>\n<p>HyPer从专注于OLTP的H-Store式并发控制的面向行的系统，转而使用带有MVCC的HTAP列存储架构，使其支持更复杂的OLAP查询[48]。</p>\n<p>甚至VoltDB也将其市场策略从单纯的OLTP性能转向提供流式语义。</p>\n<p>同样，S-Store项目也试图在H-Store架构之上增加对流处理操作的支持[46]。</p>\n<p>从2000年中期开始，专门的OLAP系统(如Greenplum)将开始增加对更好的OLTP的支持。</p>\n<p><br></p>\n<p>然而，我们注意到，HTAP DBMS的兴起确实意味着巨大的单体OLAP仓库的结束。</p>\n<p>这种系统在短期内仍然是必要的，因为它们是一个组织所有前端OLTP孤岛的通用后端数据库。</p>\n<p>但最终，数据库联合的复兴将使公司能够执行跨越多个OLTP数据库（甚至包括多个供应商）的分析查询，而无需移动数据。</p>\n<h2 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h2><p>从我们的分析中得到的主要启示是，NewSQL数据基础系统并不是对现有系统架构的彻底背离，而是代表了数据库技术持续发展的下一个篇章。</p>\n<p>这些系统所采用的大部分技术都存在于学术界和工业界以往的DBMS中。</p>\n<p>但其中许多技术只是在单个系统中逐一实现，从未全部实现。</p>\n<p>因此，这些NewSQL DBMS的创新之处在于，它们将这些思想融入到单一的平台中。</p>\n<p>实现这一点绝不是一个微不足道的工程努力。</p>\n<p>它们是一个新时代的副产品，在这个时代，分布式计算资源丰富且价格低廉，但同时对应用的要求也更高。</p>\n<p><br></p>\n<p>此外，考虑NewSQL DBMS在市场上的潜在影响和未来发展方向也很有意思。</p>\n<p>鉴于传统的DBMS厂商已经根深蒂固，而且资金充裕，NewSQL系统要想获得市场份额，将面临一场艰苦的战斗。</p>\n<p>自我们首次提出NewSQL这个术语[18]以来，在过去的五年里，有几家NewSQL公司已经倒闭（如GenieDB、Xeround、Translattice），或者转而专注于其他领域（如ScaleBase、ParElastic）。</p>\n<p>根据我们的分析和对几家公司的访谈，我们发现NewSQL系统的被接受的速度相对较慢，特别是与开发者驱动的NoSQL吸收相比。</p>\n<p>这是因为NewSQL DBMS的设计是为了支持事务性工作场景，而这些工作场景大多出现在企业应用中。</p>\n<p>与新的Web应用工作场景相比，这些企业应用的数据库选择决策可能更加保守。</p>\n<p>这一点从以下事实也可以看出，我们发现NewSQL DBMS被用来补充或替换现有的RDBMS部署，而NoSQL则被部署在新的应用工作场景中[19]。</p>\n<p><br></p>\n<p>与2000年代的OLAP DBMS初创公司不同，当时几乎所有的厂商都被大型技术公司收购，到目前为止，只有一家收购NewSQL公司。</p>\n<p>2016年3月，Tableau宣布收购了为HyPer项目组建的初创公司。</p>\n<p>另外两个可能的例外是：（1）Ap-ple在2015年3月收购了FoundationDB，但我们把它们排除在外，因为这个系统的核心是一个NoSQL键值存储，上面嫁接了一个低效的SQL层；（2）ScaleArc收购了ScaleBase，但这是一个竞争对手收购了另一个竞争对手。 </p>\n<p>这些例子都不是那种传统厂商收购后起之秀系统的收购（比如2011年Teradata收购Aster Data Systems）。</p>\n<p>我们反而看到，大型厂商选择创新和改进自己的系统，而不是收购NewSQL新秀。</p>\n<p>微软在2014年在SQL Server中加入了内存Hekaton引擎，以改善OLTP工作负载。</p>\n<p>甲骨文和IBM的创新速度稍慢；他们最近在其系统中增加了面向列的存储扩展，以与惠普Vertica和亚马逊Redshift等日益流行的OLAP DBMS竞争。它们有可能在未来为OLTP工作负载增加内存选项。</p>\n<p><br></p>\n<p>从更长远的角度来看，我们认为，在我们这里讨论的四类系统中，将出现功能的融合。</p>\n<p>(1)1980-1990年代的老式DBMS，(2)2000年代的OLAP数据仓库，(3)2000年代的NoSQL DBMS，(4)2010年代的NewSQL DBMS。</p>\n<p>我们预计，这些分类中的所有关键系统都将支持某种形式的关系模型和SQL（如果它们还没有的话），以及像HTAP DBMS那样同时支持OLTP操作和OLAP查询。当这种情况发生时，这种分类将毫无意义。</p>\n<p><br></p>\n<p><strong> 鸣谢 </strong></p>\n<p>The authors would like to thank the following people for their feedback: Andy Grove (AgilData), Prakhar Verma (Amazon), Cashton Coleman (ClearDB), Dave Anselmi (Clustrix), Spencer Kimball (CockroachDB), Peter Mattis (CockroachDB), Ankur Goyal (MemSQL), Seth Proctor (NuoDB), Anil Goel (SAP HANA), Ryan Betts (VoltDB). This work was supported (in part) by the National Science Foundation (Award CCF-1438955).</p>\n<p>For questions or comments about this paper, please call the CMU Database Hotline at <strong>+1-844-88-CMUDB</strong>.</p>\n<h2 id=\"7-引用\"><a href=\"#7-引用\" class=\"headerlink\" title=\"7. 引用\"></a>7. 引用</h2><p>略了</p>\n<p>​     </p>\n<p>​    </p>\n","categories":["论文翻译"],"tags":["NewSQL"]},{"title":"论文翻译 - Kafka~a Distributed Messaging System for Log Processing","url":"https://blog.lovezhy.cc/2020/05/14/论文翻译 - Kafka~a Distributed Messaging System for Log Processing/","content":"<p>原文地址：<a href=\"http://notes.stephenholiday.com/Kafka.pdf\" target=\"_blank\" rel=\"noopener\">http://notes.stephenholiday.com/Kafka.pdf</a></p>\n<p>太长不看：</p>\n<p>相对于JMS等其他的消息系统，Kafka舍弃了很多功能，以达到性能上的提升。</p>\n<p>论文讲述了Kafka设计上的取舍，以及提升性能的很多点。</p>\n<a id=\"more\"></a>\n<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><p>日志处理已经成为消费互联网公司数据管道的重要组成部分。</p>\n<p>我们将开始介绍Kafka，这是一个我们开发出用于收集和传递大批量的日志数据，并且具有低延迟的分布式消息传递系统。</p>\n<p>Kafka融合了现有的日志聚合器和消息传递系统的思想，适用于消费离线和在线消息。</p>\n<p>我们在Kafka中做了不少非常规但又实用的设计，使我们的系统具有高效和扩展性。</p>\n<p>我们的实验结果表明，与两种流行的消息传递系统相比，Kafka具有优越的性能。</p>\n<p>我们在生产中使用Kafka已经有一段时间了，它每天要处理数百GB的新数据。</p>\n<h1 id=\"1-介绍\"><a href=\"#1-介绍\" class=\"headerlink\" title=\"1. 介绍\"></a>1. 介绍</h1><p>任何一家大型互联网公司都会产生大量的 “日志 “数据。</p>\n<p>这些数据通常包括：</p>\n<ul>\n<li><p>用户活动事件，包括登录、页面浏览、点击、”喜欢”、分享、评论和搜索查询</p>\n</li>\n<li><p>运营指标，如服务调用堆栈、调用延迟、错误，以及系统指标，如CPU、内存、网络或磁盘利用率等。</p>\n</li>\n</ul>\n<p>长期以来，日志数据一直是分析的一个组成部分，用于跟踪用户参与度、系统利用率和其他指标。</p>\n<p>然而最近互联网应用的趋势使得活动数据成为产品数据管道的一部分，直接用于网站功能中。</p>\n<p>这些用途包括：</p>\n<ul>\n<li>搜索相关性</li>\n<li>活动流中的受欢迎或共同出现的项目产生的推荐</li>\n<li>广告定位和报告</li>\n<li>防止滥用行为的安全应用，如垃圾邮件或未经授权的数据爬取</li>\n<li>新闻联播功能，将用户的状态更新或行动汇总起来，供其 “朋友 “阅读。</li>\n</ul>\n<p>这种生产、实时使用的日志数据给数据系统带来了新的挑战，因为它的数据量比 “真实 “的数据要大好几个数量级。</p>\n<p>例如，搜索、推荐和广告往往需要计算颗粒化的点击率，这不仅会产生每一个用户点击的日志记录，还会产生每个页面上几十个未点击的项目的日志记录。</p>\n<p>中国移动每天收集5-8TB的电话通话记录，Facebook每天则收集了近6TB的各种用户活动事件。</p>\n<p>许多早期处理这类数据的系统都是依靠从生产服务器上实际收集日志文件进行分析。</p>\n<p>近年来，一些专门的分布式日志聚合器已经发布，包括Facebook的Scribe[6]、Yahoo的Data Highway和Cloudera的Flume。</p>\n<p>这些系统主要是为了收集日志数据，并将日志数据加载到数据仓库或Hadoop[8]中进行离线消费。</p>\n<p>在LinkedIn（一家社交网站），我们发现除了传统的离线分析之外，我们还需要以不超过几秒的延迟支持上述大部分实时应用。</p>\n<p>我们构建了一种新型的日志处理的消息传递系统，称为Kafka，它结合了传统日志聚合器和消息传递系统的优点。</p>\n<p>一方面，Kafka具有分布式和可扩展性，并提供了高吞吐量。</p>\n<p>另一方面，Kafka提供了类似于消息传递系统的API，允许应用程序实时消耗日志事件。</p>\n<p>Kafka已经开源，并在LinkedIn的生产中成功使用了6个多月。</p>\n<p>它极大地简化了我们的基础设施，因为我们可以利用一个单一的软件来在线和离线消费各种类型的日志数据。</p>\n<p>本文的其余部分安排如下。</p>\n<ul>\n<li>在第2节中，我们重新审视了传统的消息传递系统和日志聚合器。</li>\n<li>在第3节中，我们描述了Kafka的架构及其关键设计原则。</li>\n<li>在第4节中，我们描述了我们在LinkedIn上部署的Kafka</li>\n<li>在第5节中描述了Kafka的性能结果。</li>\n<li>我们在第6节中讨论了未来的工作</li>\n<li>在第6节中做了总结。</li>\n</ul>\n<h1 id=\"2-相关工作\"><a href=\"#2-相关工作\" class=\"headerlink\" title=\"2. 相关工作\"></a>2. 相关工作</h1><p>传统的企业消息系统已经存在了很长时间，通常在处理异步数据流的事件总线中起着至关重要的作用。</p>\n<p>然而，有几个原因导致它们往往不能很好地适应日志处理。</p>\n<p>首先，企业级系统提供的特性与日志处理该有的不匹配。那些系统往往侧重于提供丰富的交付保证。</p>\n<p>例如，IBM Websphere MQ具有事务式支持，允许一个应用程序将消息以原子方式插入到多个队列中。</p>\n<p>而JMS规范允许每个消息在消费后被确认消费，消费顺序可能是无序的。（没看懂，对JMS不了解，脑补了下，乱序消费并幂等的意思？）</p>\n<p>这样的交付保证对于收集日志数据来说往往是矫枉过正的。偶尔丢失几个页面浏览事件当然不是世界末日。</p>\n<p>那些不需要的功能往往会增加这些系统的API和底层实现的复杂性。</p>\n<p>其次，相比较首要设计约束功能，许多系统并不是那样强烈地关注吞吐量。例如，JMS没有API允许生产者明确地将多个消息批量化为一个请求。这意味着每个消息都需要进行一次完整的TCP/IP往返，这对于我们领域的吞吐量要求是不可行的。</p>\n<p>第三，那些系统在分布式支持方面比较弱。没有简单的方法可以在多台机器上对消息进行分区和存储。</p>\n<p>最后，许多消息系统假设消息会被近似实时消费掉，未被消费的消息量总是相当小。</p>\n<p>导致如果出现消息累积，它们的性能就会大大降低。比如当数据仓库等离线消耗者对消息系统做周期性的大负载消费，而不是连续消费数据时。</p>\n<p>在过去几年里，已经建立了一些专门的日志聚合器。</p>\n<p>比如Facebook使用了一个叫Scribe的系统，每个前端机器可以通过网络向一组Scribe机器发送日志数据。</p>\n<p>每台Scribe机器聚合日志条目，并定期将其转储到HDFS或NFS设备上。</p>\n<p>雅虎的数据高速公路项目也有类似的数据传递方式，一组机器聚合来自客户端的事件，按分钟保存为文件，然后将</p>\n<p>其添加到HDFS。</p>\n<p>Flume是Cloudera开发的一个比较新的日志聚合器。它支持可扩展的 “管道 “和 “数据下沉”，使流式日志数据的传</p>\n<p>输非常灵活。它也有更多的集成分布式支持。</p>\n<p>但是，这些系统大多是为离线消耗日志数据而构建的，往往会将实现细节（如 “按分钟保存的文件”）不必要地暴露给消费者。</p>\n<p>此外，他们中的大多数都采用了 “推送 “模式，即Broker将数据转发给消费者。</p>\n<p>在LinkedIn，我们发现 “拉动 “模式更适合我们的应用，因为每个消费者都能以自己能承受的最大速率检索到消</p>\n<p>息，避免被推送的消息淹没在比自己能承受的速度更快的消息中。</p>\n<p>拉动模式还可以让消费者很容易回传，我们在</p>\n<p>3.2节末尾讨论了这个好处的细节。</p>\n<p>最近，雅虎研究公司开发了一种新的分布式pub/sub系统，名为HedWig。HedWig具有高度的可扩展性和可</p>\n<p>用性，并提供了强大的持久性保证。不过，它主要是用于存储资料库（data store）的提交日志。</p>\n<h1 id=\"3-Kafka架构和设计原则\"><a href=\"#3-Kafka架构和设计原则\" class=\"headerlink\" title=\"3. Kafka架构和设计原则\"></a>3. Kafka架构和设计原则</h1><p>由于现有的各种消息系统的局限性，我们开发了一种新的基于消息传递的日志聚合器Kafka。</p>\n<p>我们首先介绍一下Kafka中的基本概念。</p>\n<p>一个主题定义一个特定类型的消息流。</p>\n<p>一个生产者可以向一个主题发布消息。然后，发布的消息被存储在一组称为Broker的服务器上。</p>\n<p>一个消费者可以从Broker那里订阅一个或多个主题，并通过从Broker那里提取数据来消费订阅的消息。</p>\n<p>从概念上讲，消息传递的定义是比较简单的。同样的，我们试图使Kafka API也一样简单。为了证明这一点，我们</p>\n<p>不展示具体的API，而是介绍一些示例代码来展示API的使用方法。</p>\n<p>下面给出了生产者的示例代码。一个消息被定义为只包含一个字节的内容。用户可以选择自己喜欢的序列化方</p>\n<p>法对消息进行编码。为了提高效率，生产者可以在一次发布请求中发送一组消息。</p>\n<blockquote>\n<p><strong>Sample producer code</strong>:</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">producer = <span class=\"keyword\">new</span> Producer(...);</span><br><span class=\"line\">message = <span class=\"keyword\">new</span> Message(“test message str”.getBytes()); </span><br><span class=\"line\">set = <span class=\"keyword\">new</span> MessageSet(message); </span><br><span class=\"line\">producer.send(“topic1”, set);</span><br></pre></td></tr></table></figure>\n<p>要订阅一个主题，消费者首先要为该主题创建一个或多个消息流（理解为分区）。</p>\n<p>发布到该主题的消息将被平均分配到这些子消息流（分区）中。</p>\n<p>关于Kafka如何分配消息的细节将在后面的3.2节中描述。</p>\n<p>每个消息流在持续产生的消息流上提供了一个迭代器接口。</p>\n<p>消费者对消息流中的每个消息进行迭代，并处理消息的内容。</p>\n<p>与传统的迭代器不同，消息流迭代器永远不会终止。</p>\n<p>如果当前没有更多的消息要消费，迭代器就会阻塞，直到新的消息被发布到主题上。</p>\n<p>我们既支持点对点的传递模式，即多个消费者共同消费一个主题中所有消息的单一副本，也支持多个消费者各自检</p>\n<p>索一个主题的副本的发布/订阅模式。</p>\n<blockquote>\n<p> <strong>Sample consumer code</strong>:</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">streams[] = Consumer.createMessageStreams(“topic1”, <span class=\"number\">1</span>) <span class=\"keyword\">for</span> (message : streams[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">bytes = message.payload();</span><br><span class=\"line\"> <span class=\"comment\">// do something with the bytes</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/Kafka论文/1.png\" alt=\"image-20200428203312364\" style=\"zoom:50%;\"></p>\n<p>Kafka的整体架构如图1所示。</p>\n<p>由于Kafka是分布式的，所以一个Kafka集群通常由多个Broker组成。</p>\n<p>为了平衡负载，一个主题被划分成多个分区，每个Broker存储一个或多个分区。</p>\n<p>多个生产者和消费者可以同时发布和消费消息。</p>\n<p>在第3.1节中，我们将描述Broker上的单个分区的布局，以及我们选择的一些设计选择，以使访问分区的效率更高。</p>\n<p>在第3.2节中，我们将描述生产者和消费者在分布式设置中如何与多个Broker交互。</p>\n<p>在第3.3节中，我们将讨论Kafka的交付保证（delivery guarantees）。</p>\n<h2 id=\"3-1-单分区的性能\"><a href=\"#3-1-单分区的性能\" class=\"headerlink\" title=\"3.1 单分区的性能\"></a>3.1 单分区的性能</h2><p>我们在Kafka中做了一些设计的决策，让系统更有效率。</p>\n<p><strong>1. 简单的存储方式</strong>：Kafka有一个非常简单的存储布局。</p>\n<p>一个主题的每个分区对应一个逻辑日志。</p>\n<p>在物理上，一个日志被实现为一组大小大致相同的段文件（例如，1GB）。</p>\n<p>每当生产者向分区发布消息时，Broker只需将消息附加到最后一个段文件中。</p>\n<p>为了更好的性能，我们只有在发布了一定数量的消息后，或者在发布了一定时间后，才会将段文件刷新到磁盘上。</p>\n<p>一个消息只有在刷新后才会暴露在消费者面前。</p>\n<p>与典型的消息传递系统不同，Kafka中存储的消息没有明确的消息ID。</p>\n<p>相反，每条消息都是通过其在日志中的逻辑偏移来寻址。</p>\n<p>这避免了维护用于辅助查询的索引结构的开销，这些索引结构将消息id映射到实际的消息位置。</p>\n<p>注意，我们提到的消息id是递增的，但不是连续的。为了计算下一条消息的id，我们必须将当前消息的长度加到它的id上。</p>\n<p>从现在开始，我们将交替使用消息id和偏移量。</p>\n<p>消费者总是顺序消费来自特定分区的消息。</p>\n<p>如果消费者确认某个特定的消息偏移，就意味着消费者已经接收到了该分区中该偏移之前的所有消息。</p>\n<p>在实际的运行中，消费者向Broker发出异步拉取消息请求，以便有一个缓冲区的数据准备好供应用程序消费。</p>\n<p>每个拉取消息请求都包含消费开始的消息的偏移量和可接受的字节数。</p>\n<p>每个Broker在内存中保存一个排序的偏移量列表，包括每个段文件中第一个消息的偏移量。Broker<br>通过搜索偏移量列表来定位所请求的报文所在的段文件，并将数据发回给消费者。</p>\n<p>当消费者收到一条消息后，它计算出下一条要消费的消息的偏移量，并在下一次拉取请求中使用它。</p>\n<p>Kafka日志和内存中索引的布局如图2所示。每个框显示了一条消息的偏移量。</p>\n<p><img src=\"/images/Kafka论文/2.png\" alt=\"image-20200506192830629\" style=\"zoom:50%;\"></p>\n<p><strong>2. 高效的传输</strong>: 我们在Kafka中传输数据的时候非常谨慎。</p>\n<p>早前，我们已经表明，生产者可以在一次发送请求中提交一组消息。</p>\n<p>虽然消费者API每次迭代一条消息，但在实际运行中，每一个消费者的拉动请求也会检索到多个消</p>\n<p>息。一次传输通常是几百个K字节的大小。</p>\n<p>我们做出的另一个非常规的选择是避免在Kafka层面缓存消息在内存中。</p>\n<p>相反，我们依赖底层文件系统的页面缓存。</p>\n<p>这样做的主要好处是避免了双重缓冲，消息就只会缓存在页面缓存中。</p>\n<p>这样做还有一个额外的好处，那就是即使在代理进程重启的时候，也能保留热缓存（warm cache)。</p>\n<p>由于Kafka根本不在进程中缓存消息，所以它在垃圾回收内存方面的开销非常小，这使得在基于VM</p>\n<p>的语言中高效实现是可行的。</p>\n<p>最后，由于生产者和消费者都是按顺序访问段文件，而消费者往往会比生产者晚一点，所以正常的</p>\n<p>操作系统缓存启发式缓存是非常有效的（缓存直写和预读）。</p>\n<p>我们发现，生产者和消费者的性能都与数据大小呈线性关系，最大的数据量可以达到很多T字节。（没看懂）</p>\n<p>此外，我们还对消费者的网络访问进行了优化。</p>\n<p>Kafka是一个多消费者系统，一条消息可能被不同的消费者应用多次消耗。</p>\n<p>从本地文件向远程socket发送字节的典型方法包括以下步骤。</p>\n<ol>\n<li>从存储介质中读取数据到操作系统中的页面缓存</li>\n<li>将页面缓存中的数据复制到应用缓冲区</li>\n<li>将应用缓冲区复制到另一个内核缓冲区</li>\n<li>将内核缓冲区发送到Socket。</li>\n</ol>\n<p>其中包括4个数据复制和2个系统调用。</p>\n<p>在Linux和其他Unix操作系统上，存在一个sendfile API，可以直接将字节从文件通道传输到socket</p>\n<p>通道。这通常可以避免步骤（2）和（3）中介绍的2个复制和1个系统调用。</p>\n<p>Kafka利用sendfile API来有效地将日志段文件中的字节从代理服务器向消费者传递。</p>\n<p><strong>3. 无状态的Broker</strong>: 与大多数其他消息系统不同，在Kafka中，每个消费者消费了多少消息的信</p>\n<p>息不是由Broker维护，而是由消费者自己维护。这样的设计减少了很多的复杂性，也减少了Broker</p>\n<p>的开销。</p>\n<p>但是，这使得删除消息变得很棘手，因为Broker不知道是否所有的用户都消费了这个消息。</p>\n<p>Kafka通过使用简单的基于时间的SLA保留策略解决了这个问题。</p>\n<p>如果一条消息在代理中保留的时间超过一定的时间，通常是7天，则会自动删除。</p>\n<p>这个方案在实际应用中效果不错。大部分消费者包括离线的消费者，都是按日、按小时或实时完成</p>\n<p>消费。由于Kafka的性能不会随着数据量的增大而降低，所以这种长时间保留的方案是可行的。</p>\n<p>这种设计有一个重要的副作用。</p>\n<p>一个消费者可以故意倒退到一个旧的偏移量，重新消费数据。</p>\n<p>这违反了队列的通用规定，但事实证明，这对很多消费者来说是一个必不可少的功能。</p>\n<p>例如，当消费者中的应用逻辑出现错误时，应用可以在错误修复后回放某些消息。这对我们的数据仓库或Hadoop系统中的ETL数据加载特别重要。</p>\n<p>再比如，被消费的数据可能只是周期性地被刷新到一个持久化存储（例如，全文索引器）。</p>\n<p>如果消费者崩溃，未冲洗的数据就会丢失。在这种情况下，消费者可以检查未冲洗的消息的最小偏移量，并在重启时从该偏移量中重新消费。</p>\n<p>我们注意到，相比于推送模型，在拉动模型中支持消费者重新消费要容易得多。</p>\n<h2 id=\"3-2-分布式协调处理\"><a href=\"#3-2-分布式协调处理\" class=\"headerlink\" title=\"3.2 分布式协调处理\"></a>3.2 分布式协调处理</h2><p>现在我们来解释一下生产者和消费者在分布式环境中的执行方式。</p>\n<p>每个生产者可以向一个随机的或由分区key和分区函数语义决定的分区发布消息。我们将重点讨论消</p>\n<p>费者是如何与Broker互动的。</p>\n<p>Kafka有消费者组的概念。</p>\n<p>每个消费组由一个或多个消费者组成，共同消费一组被订阅的主题，也就是说，每条消息只传递给</p>\n<p>消费组内的一个消费者。</p>\n<p>不同的消费者组各自独立消费全套订阅的消息，不需要跨消费者组的协调机制。</p>\n<p>同一组内的消费者可以在不同的进程或不同的机器上。</p>\n<p>我们的目标是在不引入过多的协调开销的情况下，将存储在Broker中的消息平均分配给组中的所有</p>\n<p>消费者。</p>\n<p>我们的第一个决定是将一个主题内的分区作为最小的并行单元。</p>\n<p>这意味着，在任何时候一个分区的所有消息都只被每个消费组中的一个消费者消费。</p>\n<p>假设我们允许多个消费者同时消费一个分区，那么他们就必须协调谁消费什么消息，这就需要加锁和维护状态，会造成一定的额外开销。</p>\n<p>相反，在我们的设计中，消费进程只需要在消费者重新平衡负载时进行协调，正常来说这种情况不经常发生。</p>\n<p>为了使负载真正平衡，我们需要一个主题中的分区比每个消费组中的消费者多很多。</p>\n<p>我们可以通过对一个主题进行更多的分区来达到这个目的。</p>\n<p>我们做的第二个决定是不设立中心化的”主控 “节点，而是让消费者以去中心化的方式相互协调。</p>\n<p>增加一个主节点会使系统变得复杂化，因为我们不得不进一步担心主节点故障。</p>\n<p>为了方便协调，我们采用了一个高度可用的共识服务Zookeeper。</p>\n<p>Zookeeper有一个非常简单的、类似于文件系统的API。</p>\n<p>人们可以创建一个路径，设置一个路径的值，读取一个路径的值，删除一个路径的值，以及列出一个路径的子路径。</p>\n<p>它还可以做一些更有趣的事情。</p>\n<ul>\n<li>可以在路径上注册一个watcher，当路径的子路径或路径的值发生变化时，可以得到通知</li>\n<li>可以将路径创建为临时的（相对于持久性的），这意味着如果创建的客户端不在了，路径会被Zookeeper服务器自动删除</li>\n<li>zookeeper将数据复制到多个服务器上，这使得数据的可靠性和可用性很高。</li>\n</ul>\n<p>Kafka使用Zookeeper完成以下任务。</p>\n<ul>\n<li><p>检测Broker和消费者的添加和删除</p>\n</li>\n<li><p>当上述事件发生时，在每个消费者中触发一个再平衡过程</p>\n</li>\n<li><p>维护消费关系，并跟踪每个分区的消费偏移情况。</p>\n</li>\n</ul>\n<p>具体来说，当每个Broker或消费者启动时，它将其信息存储在Zookeeper中的Broker或消费者注册表中。</p>\n<p>Broker注册表包含Broker的主机名和端口，以及存储在其上的主题和分区。</p>\n<p>消费者注册表包括消费者所属的消费组，以及它所订阅的主题集合。</p>\n<p>每个消费组都与Zookeeper中的一个所有权注册表和一个偏移注册表相关联。</p>\n<p>所有权注册表对每个订阅的分区都有一个路径，路径值是当前从这个分区消费的消费者id（我们使用的术语是消费者拥有这个分区）。</p>\n<p>偏移注册表为每个订阅的分区存储了该分区中最后一个被消费的消息的偏移量。</p>\n<p>Broker注册表、消费者注册表和所有权注册表在 Zookeeper 中创建的路径都是临时的。</p>\n<p>偏移注册表中创建的路径是持久的。</p>\n<p>如果一个Broker服务器发生故障，其上的所有分区都会自动从Broker注册表中删除。</p>\n<p>消费者的故障会导致其在消费者注册表中的记录和所有权注册表中的所有分区记录丢失。</p>\n<p>每个消费者都会在Broker注册表和消费者注册表上注册一个Zookeeper的Watcher，每当Broker集合或消费者组</p>\n<p>发生变化时，都会收到通知。</p>\n<p><img src=\"/images/Kafka论文/3.png\" alt=\"image-20200507194132517\" style=\"zoom:50%;\"></p>\n<p>在消费者的初始启动过程中，或者当消费者通过Watcher收到关于Broker/消费者变更的通知时，消费者会启动一</p>\n<p>个重新平衡过程，以确定它应该消费的新分区。</p>\n<p>在算法1中描述了这个过程。</p>\n<p>通过从Zookeeper读取Broker和消费者注册表，消费者首先计算每个订阅主题T的可用分区集合（PT）和订阅T的消费者集合（CT）。</p>\n<p>对于消费者选择的每个分区，它在所有权注册表中写入自己作为该分区的新所有者。</p>\n<p>最后，消费者开始一个线程从拥有的分区中拉出数据，偏移量从存储在偏移注册表中的记录值开始。</p>\n<p>当消息从分区中拉出时，消费者会定期更新偏移注册表中的最新消耗的偏移量。</p>\n<p>当一个消费组内有多个消费者时，每个消费者都会收到Broker或消费者变更的通知。</p>\n<p>但是，通知到达每个消费者的时间上略有不同。</p>\n<p>因此，有可能是一个消费者试图夺取仍由另一个消费者拥有的分区的所有权。</p>\n<p>当这种情况发生时，第一个消费者只需释放其当前拥有的所有分区，等待一段时间，然后重新尝试重新平衡。</p>\n<p>在实践中，重新平衡过程通常只需重试几次就会稳定下来。</p>\n<p>当创建一个新的消费者组时，偏移注册表中没有可用的偏移量。</p>\n<p>在这种情况下，消费者将使用我们在Broker上提供的API，从每个订阅分区上可用的最小或最大的偏移量开始（取</p>\n<p>决于配置）。</p>\n<h2 id=\"3-3-传递保证\"><a href=\"#3-3-传递保证\" class=\"headerlink\" title=\"3.3 传递保证\"></a>3.3 传递保证</h2><p>一般来说，Kafka只保证至少一次交付语义。</p>\n<p>确切一次交付语义通常需要两阶段提交，对于我们的应用来说并不是必须的。</p>\n<p>大多数情况下，一个消息会准确地传递给每个消费组一次。</p>\n<p>但是，当一个消费组进程崩溃而没有干净关闭的情况下，新接管的消费进程可能会得到一些重复的消息，这些消息</p>\n<p>在最后一次偏移成功提交给zookeeper之后。</p>\n<p>如果一个应用程序关心重复的问题，那么它必须添加自己的去重复逻辑，要么使用我们返回给消费者的偏移量，要</p>\n<p>么使用消息中的一些唯一密钥。这通常是一种比使用两阶段提交更经济的方法。</p>\n<p>Kafka保证来自单个分区的消息按顺序传递给消费者。</p>\n<p>然而，对于来自不同分区的消息的顺序，Kafka并不保证。</p>\n<p>为了避免日志损坏，Kafka在日志中为每个消息存储一个CRC。</p>\n<p>如果Broker上有任何I/O错误，Kafka会运行一个恢复过程来删除那些具有不一致CRC的消息。</p>\n<p>在消息级别拥有CRC也允许我们在消息产生或消费后检查网络错误。</p>\n<p>如果一个Broker宕机，那么存储在其上的任何未被消费的信息都将不可用。</p>\n<p>如果一个Broker上的存储系统被永久损坏，任何未被消费的消息都会永远丢失。</p>\n<p>在未来，我们计划在Kafka中添加复制功能，以便在多个Broker上冗余存储每一条消息。</p>\n<h1 id=\"4-Kafka在LinkedIn的实践\"><a href=\"#4-Kafka在LinkedIn的实践\" class=\"headerlink\" title=\"4. Kafka在LinkedIn的实践\"></a>4. Kafka在LinkedIn的实践</h1><p>在本节中，我们将介绍我们如何在LinkedIn使用Kafka。</p>\n<p>图3显示了我们部署的简化版本。</p>\n<p>在每个运行面向用户服务的数据中心，我们都会部署一个Kafka集群。</p>\n<p>前端服务会生成各种日志数据，并分批发布到本地的Kafka的Broker中。</p>\n<p>我们依靠硬件负载均衡器将发布请求均匀地分配给Kafka的Broker。</p>\n<p>Kafka的在线消费者在同一数据中心内的服务中运行。</p>\n<p><img src=\"/images/Kafka论文/6.png\" alt=\"image-20200513201939870\" style=\"zoom:50%;\"></p>\n<p>我们还在每个数据中心单独部署了一个Kafka集群，用于离线分析，该集群在地理位置上靠近我们的Hadoop集群</p>\n<p>和其他数据仓库基础设施。</p>\n<p>这个Kafka实例运行一组嵌入式消费者，实时从数据中心的Kafka实例中拉取数据。</p>\n<p>然后，我们运行数据加载任务，将数据从这个Kafka的复制集群拉到Hadoop和我们的数据仓库中，在这里我们运</p>\n<p>行各种报表作业和数据分析处理。</p>\n<p>我们还使用这个Kafka集群进行原型开发，并有能力针对原始事件流运行简单的脚本进行实时查询。</p>\n<p>无需过多的调整，整个管道的端到端延迟平均约为10秒，足以满足我们的要求。</p>\n<p>目前，Kafka每天积累了数百G字节的数据和近10亿条消息。</p>\n<p>随着我们完成对遗留系统的迁移，我们预计这个数字将大幅增长。</p>\n<p>未来还会增加更多类型的消息。</p>\n<p>当运营人员启动或停止Broker进行软件或硬件维护时，再平衡过程能够自动重定向消费。</p>\n<p>我们的跟踪系统还包括一个审计系统，以验证整个管道中的数据没有丢失。</p>\n<p>为了方便起见，每条消息都带有时间戳和服务器名称。</p>\n<p>我们对每个生产者进行仪器化处理，使其定期生成一个监控事件，记录该生产者在固定时间窗口内为每个主题发布</p>\n<p>的消息数量。</p>\n<p>生产者将监控事件发布到Kafka的一个单独的主题中。</p>\n<p>然后，消费者可以统计他们从一个给定的主题中收到的消息数量，并将这些计数与监测事件进行验证，以验证数据</p>\n<p>的正确性。</p>\n<p>加载到Hadoop集群中是通过实现一种特殊的Kafka输入格式来完成的，该格式允许MapReduce作业直接从Kafka</p>\n<p>中读取数据。</p>\n<p>MapReduce作业加载原始数据，然后将其分组和压缩，以便将来进行高效处理。</p>\n<p>无状态的Broker和客户端存储消息偏移在这里再次发挥了作用，使得MapReduce任务管理（允许任务失败和重</p>\n<p>启）以自然的方式处理数据负载，而不会在任务重启时重复或丢失消息。</p>\n<p>只有在任务成功完成后，数据和偏移量才会存储在HDFS中。</p>\n<p>我们选择使用Avro作为我们的序列化协议，因为它是高效的，并且支持模式演化。</p>\n<p>对于每条消息，我们将其Avro模式的id和序列化的字节存储在有效payload中。</p>\n<p>这个模式允许我们执行一个约定，以确保数据生产者和消费者之间的兼容性。</p>\n<p>我们使用一个轻量级的模式注册服务来将模式id映射到实际的模式。</p>\n<p>当消费者得到一个消息时，它在模式注册表中查找，以检索该模式，该模式被用来将字节解码成对象（这种查找只</p>\n<p>需要对每个模式进行一次，因为值是不可更改的）。</p>\n<h1 id=\"5-实验结果\"><a href=\"#5-实验结果\" class=\"headerlink\" title=\"5. 实验结果\"></a>5. 实验结果</h1><p>我们进行了一项实验性研究，将Kafka与Apache ActiveMQ v5.4（一种流行的JMS开源实现）和以性能著称的消息</p>\n<p>系统RabbitMQ v2.4进行了比较。</p>\n<p>我们使用了ActiveMQ的默认持久化消息存储KahaDB。</p>\n<p>虽然这里没有介绍，但我们也测试了另一种AMQ消息存储，发现其性能与KahahaDB非常相似。</p>\n<p>只要有可能，我们尽量在所有系统中使用可比性设置。</p>\n<p>我们在2台Linux机器上进行了实验，每台机器都有8个2GHz核心，16GB内存，6个磁盘，带RAID 10。</p>\n<p>这两台机器用1Gb网络链路连接。其中一台机器作为Broker，另一台机器作为生产者或消费者。</p>\n<p><strong>Producer测试</strong>：</p>\n<p>我们将所有系统中的Broker配置为异步刷新消息到其持久化磁盘中。</p>\n<p>对于每个系统，我们运行了一个单一的生产者来发布总共1000万条消息，每条消息的大小为200字节。</p>\n<p>我们将Kafka生产者配置为以1和50的大小分批发送消息。</p>\n<p>ActiveMQ和RabbitMQ似乎没有一个简单的消息批处理方法，我们假设它使用的是1的批处理大小，结果如图4所示。</p>\n<p>x轴代表的是随着时间的推移向Broker发送的数据量，单位为MB，y轴对应的是生产者吞吐量，单位为每秒的消息量。</p>\n<p>平均而言，Kafka在批处理大小为1和50的情况下，Kafka可以以每秒5万条和40万条消息的速度分别发布消息。</p>\n<p>这些数字比ActiveMQ高了好几个数量级，而且至少是比RabbitMQ高2倍。</p>\n<p><img src=\"/images/Kafka论文/4.png\" alt=\"image-20200514202746023\" style=\"zoom:50%;\"></p>\n<p>Kafka的表现要好得多有几个原因。</p>\n<p>首先，Kafka生产者目前不等待Broker的回执，以Broker能处理的速度发送消息。</p>\n<p>这大大增加了发布者的吞吐量。</p>\n<p>在批处理量为50个的情况下，单个Kafka生产者几乎打满了生产者和Broker之间的1Gb带宽。</p>\n<p>这对于日志聚合的情况来说是一个有效的优化，因为数据必须异步发送，以避免在实时服务流量中引入任何延迟。</p>\n<p>同时我们注意到，broker在没有回送ack的情况下，不能保证producer每一条发布的消息都能被broker实际接收到。</p>\n<p>对于不同类型的日志数据，只要丢掉的消息数量相对较少，以持久化换取吞吐量是可取的。然而，我们确实计划在</p>\n<p>未来解决更多关键数据的持久化问题。</p>\n<p>其次，Kafka使用有更有效的存储格式。</p>\n<p>正常来说，在Kafka中，每个消息的开销是9个字节，而在ActiveMQ中则是144个字节。</p>\n<p>这意味着ActiveMQ比Kafka多用了70%的空间来存储同样的1000万条消息。</p>\n<p>ActiveMQ的一个开销来自于JMS所要求的沉重的消息头。</p>\n<p>另一个开销是维护各种索引结构的成本。</p>\n<p>我们观察到，ActiveMQ中最繁忙的线程之一花了大部分时间访问B-Tree来维护消息元数据和状态。</p>\n<p>最后，批处理通过摊销RPC开销，大大提高了吞吐量。在Kafka中，50条消息的批处理量几乎提高了一个数量级的</p>\n<p>吞吐量。</p>\n<p><strong>消费者测试</strong>：</p>\n<p>在第二个实验中，我们测试了消费者的性能。</p>\n<p>同样，对于所有系统，我们使用一个消费者来检索总共1000万条消息。</p>\n<p>我们对所有系统进行了配置，使每个拉取请求预取的数据量大致相同–最多1000条消息或约200KB。</p>\n<p>对于 ActiveMQ 和 RabbitMQ，我们将消费者确认模式设置为自动。</p>\n<p>由于所有的消息都适合在内存中，所以所有的系统都是从底层文件系统的页面缓存或一些内存中的缓冲区中提供数</p>\n<p>据。</p>\n<p>结果如图5所示。</p>\n<p><img src=\"/images/Kafka论文/5.png\" alt=\"image-20200514203355691\" style=\"zoom:50%;\"></p>\n<p>Kafka平均每秒消费22000条消息，是ActiveMQ和RabbitMQ的4倍多。</p>\n<p>我们可以想到几个原因。</p>\n<p>首先，由于Kafka有更有效的存储格式，所以消费者从Broker那里传输的字节数更少。</p>\n<p>其次，ActiveMQ和RabbitMQ中的Broker都必须维护每一条消息的传递状态。</p>\n<p>我们观察到ActiveMQ线程中的一个ActiveMQ线程在这个测试中忙于向磁盘写入KahaDB页面。</p>\n<p>相比之下，Kafka代理上没有任何磁盘写入活动。</p>\n<p>最后，通过使用sendfile API，Kafka降低了传输开销。</p>\n<p>在这一节的最后，我们要指出，实验的目的并不是为了表明其他的消息传递系统不如Kafka。</p>\n<p>毕竟，ActiveMQ和RabbitMQ都有比Kafka更多的功能。</p>\n<p>主要是为了说明一个定制的系统可能带来的性能提升。</p>\n<h1 id=\"6-总结与未来展望\"><a href=\"#6-总结与未来展望\" class=\"headerlink\" title=\"6. 总结与未来展望\"></a>6. 总结与未来展望</h1><p>我们提出了一个名为Kafka的新型系统，用于处理海量的日志数据流。</p>\n<p>与普通消息传递系统一样，Kafka采用了一种基于拉取的消费模型，允许应用程序以自己的速度消费数据，并在需</p>\n<p>要的时候随时倒带消费。</p>\n<p>通过专注于日志处理应用，Kafka实现了比传统消息系统更高的吞吐量。</p>\n<p>同时，它还提供了内置的分布式支持，并且可以进行扩展。我们已经在LinkedIn成功地将Kafka用于离线和在线应</p>\n<p>用。</p>\n<p>未来，我们有几个方向。</p>\n<p>首先，我们计划在多个Broker之间添加内置的消息复制功能，即使在机器故障无法恢复的情况下，我们也可以提</p>\n<p>供持久化和数据可用性保证。</p>\n<p>我们希望同时支持异步和同步复制模型，以允许在生产者延迟和所提供的保证强度之间进行一些权衡。</p>\n<p>一个应用可以根据自己对持久化、可用性和吞吐量的要求，选择合适的冗余级别。</p>\n<p>其次，我们希望在Kafka中加入一些流处理能力。</p>\n<p>在从Kafka中检索消息后，实时应用经常会执行类似的操作，例如基于窗口的计数，并将每条消息与二级存储中的</p>\n<p>记录或与另一个流中的消息连接起来。</p>\n<p>在最底层，在发布过程中，通过在join键上对消息进行语义上的分区来支持这种操作，这样，所有用特定键发送的</p>\n<p>消息都会进入同一个分区，从而到达一个单一的消费进程。</p>\n<p>这为在消费机集群中处理分布式流提供了基础。</p>\n<p>在此基础上，我们觉得一个有用的信息流实用程序库，如不同的窗口化函数或连接技术将对这类应用有利。</p>\n<h1 id=\"7-引用\"><a href=\"#7-引用\" class=\"headerlink\" title=\"7. 引用\"></a>7. 引用</h1><ol>\n<li><a href=\"http://activemq.apache.org/\" target=\"_blank\" rel=\"noopener\">http://activemq.apache.org/</a></li>\n<li><a href=\"http://avro.apache.org/\" target=\"_blank\" rel=\"noopener\">http://avro.apache.org/</a></li>\n<li>Cloudera’s Flume, <a href=\"https://github.com/cloudera/flume\" target=\"_blank\" rel=\"noopener\">https://github.com/cloudera/flume</a></li>\n<li><a href=\"http://developer.yahoo.com/blogs/hadoop/posts/2010/06/ena\" target=\"_blank\" rel=\"noopener\">http://developer.yahoo.com/blogs/hadoop/posts/2010/06/ena</a> bling_hadoop_batch_processi_1/</li>\n<li>Efficient data transfer through zero copy: <a href=\"https://www.ibm.com/developerworks/linux/library/j-\" target=\"_blank\" rel=\"noopener\">https://www.ibm.com/developerworks/linux/library/j-</a> zerocopy/</li>\n<li>Facebook’s Scribe, <a href=\"http://www.facebook.com/note.php?note_id=32008268919\" target=\"_blank\" rel=\"noopener\">http://www.facebook.com/note.php?note_id=32008268919</a></li>\n<li>IBM Websphere MQ: <a href=\"http://www-\" target=\"_blank\" rel=\"noopener\">http://www-</a> 01.ibm.com/software/integration/wmq/</li>\n<li><a href=\"http://hadoop.apache.org/\" target=\"_blank\" rel=\"noopener\">http://hadoop.apache.org/</a></li>\n<li><a href=\"http://hadoop.apache.org/hdfs/\" target=\"_blank\" rel=\"noopener\">http://hadoop.apache.org/hdfs/</a></li>\n<li><a href=\"http://hadoop.apache.org/zookeeper/\" target=\"_blank\" rel=\"noopener\">http://hadoop.apache.org/zookeeper/</a></li>\n<li><a href=\"http://www.slideshare.net/cloudera/hw09-hadoop-based-\" target=\"_blank\" rel=\"noopener\">http://www.slideshare.net/cloudera/hw09-hadoop-based-</a> data-mining-platform-for-the-telecom-industry</li>\n<li><a href=\"http://www.slideshare.net/prasadc/hive-percona-2009\" target=\"_blank\" rel=\"noopener\">http://www.slideshare.net/prasadc/hive-percona-2009</a></li>\n<li><a href=\"https://issues.apache.org/jira/browse/ZOOKEEPER-775\" target=\"_blank\" rel=\"noopener\">https://issues.apache.org/jira/browse/ZOOKEEPER-775</a></li>\n<li>JAVA Message Service: <a href=\"http://download.oracle.com/javaee/1.3/jms/tutorial/1_3_1-\" target=\"_blank\" rel=\"noopener\">http://download.oracle.com/javaee/1.3/jms/tutorial/1_3_1-</a> fcs/doc/jms_tutorialTOC.html.</li>\n<li>Oracle Enterprise Messaging Service: <a href=\"http://www.oracle.com/technetwork/middleware/ias/index-\" target=\"_blank\" rel=\"noopener\">http://www.oracle.com/technetwork/middleware/ias/index-</a> 093455.html</li>\n<li><a href=\"http://www.rabbitmq.com/\" target=\"_blank\" rel=\"noopener\">http://www.rabbitmq.com/</a></li>\n<li>TIBCO Enterprise Message Service: <a href=\"http://www.tibco.com/products/soa/messaging/\" target=\"_blank\" rel=\"noopener\">http://www.tibco.com/products/soa/messaging/</a></li>\n<li>Kafka, <a href=\"http://sna-projects.com/kafka/\" target=\"_blank\" rel=\"noopener\">http://sna-projects.com/kafka/</a></li>\n</ol>\n","categories":["论文翻译"],"tags":["Kafka"]},{"title":"业务思考-点赞列表怎么做","url":"https://blog.lovezhy.cc/2020/03/16/业务思考-点赞列表怎么做/","content":"<p>在小米有品的工作内容也算是和社交有点关系，会有类似微博的点赞，查看点赞列表的功能。<br>这个功能看起来简单，其实做起来一点都不容易。<br>为了避嫌，这里以微博为例，讲一讲自己的思考。<br>类似的，还有关注列表等。这里就简单思考点赞列表。</p>\n<a id=\"more\"></a>\n<h1 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h1><p>微博上，我们可以给一个具体的微博点赞，然后个人中心页面可以查看自己点赞的内容的历史<br>所以基本功能概括起来如下：</p>\n<ol>\n<li>给微博点赞/取消点赞</li>\n<li>查看是否给该微博点过赞</li>\n<li>查看历史点赞记录</li>\n</ol>\n<p>在要应对的数据量比较大情况下，要完全实现上面这三个功能也不容易。尤其是这种很典型的具体冷热属性的数据。<br>所以会有一些产品妥协策略：</p>\n<ol>\n<li>时间久远的微博，默认返回未点过赞  //这种产品可能会比较同意</li>\n<li>时间久远的微博，点赞记录中找不到  //这种一般不会同意的，放弃吧<br>为什么这么妥协会比较好做呢？下面再详细聊聊</li>\n</ol>\n<p>下面看看怎么实现</p>\n<h1 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h1><p>这个是最简单的实现方式<br>其实还有更简单的，就是只有Mysql，但是这种一般都不会使用的，除非自己写写应用。</p>\n<p>每个用户的点赞列表都存为一个ZSET<br><code>Key=weibo:like:${uid}</code><br><code>Value=${weiboId}，Score=${Time}</code></p>\n<ol>\n<li>点赞时加入到ZSET，取消点赞时从ZSET中删除</li>\n<li>查询是否点过赞使用zscore</li>\n<li>历史点赞记录用zrange</li>\n</ol>\n<h2 id=\"注意事项一\"><a href=\"#注意事项一\" class=\"headerlink\" title=\"注意事项一\"></a>注意事项一</h2><p>没问题吗？<br>是的，一般来说这么搞就行了，但是其实有个不小的瑕疵。<br>查询历史点赞记录用zrange。</p>\n<p>想象如下的例子：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request: &#123;</span><br><span class=\"line\">\tpage: 0,</span><br><span class=\"line\">\tpageSize: 10</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好，我们用<code>zrange(key, page, pageSize)</code>返回前十条</p>\n<p>我看到自己的前十个点赞记录，卧槽太傻比了，全部取消点赞<br>ok，我们zrem() * 10次，把zset中前10个记录删除了。</p>\n<p>再来请求下一页：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request: &#123;</span><br><span class=\"line\">\tpage: 1,</span><br><span class=\"line\">\tpageSize: 10</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们用<code>zrange(key, page, pageSize)</code>返回前十条</p>\n<p>发现问题了吗？<br>第二次zrange的10条，其实是最原始数据的20-30条。<br>中间有一页的点赞记录因为我们zrem的原因，加载不出来。</p>\n<p>这就是用zset做分页的普遍缺点。</p>\n<p>怎么解呢？<br>有个简单的方法，我们用<code>rangeByScore</code>方法，其实参数最大值，是上一页的最小的一个<code>Score</code>。<br>这样，前端每次的请求其实是带上上一页的最小的那个时间戳<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request: &#123;</span><br><span class=\"line\">\tpage: x,</span><br><span class=\"line\">\tpageSize: 10,</span><br><span class=\"line\">\tlastTime: 103232</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样就可以解决了。</p>\n<h2 id=\"注意事项二\"><a href=\"#注意事项二\" class=\"headerlink\" title=\"注意事项二\"></a>注意事项二</h2><p>但是还有个问题：<br>我点赞了微博id=23。<br>然后这条微博被用户删除了。<br>那我从zset中拉到这个id，组装数据时会发现id=23查找不到。</p>\n<p>这个时候其实有两种选择：</p>\n<ol>\n<li>告诉用户这个点赞内容被删除了，微博就是这么做的</li>\n<li>返回空</li>\n</ol>\n<p>返回空其实又带来一个问题<br>如果我很不巧，第4页的点赞微博都是一个人的，她清空了微博<br>那请求和响应就会变成这样：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request: &#123;</span><br><span class=\"line\">\tpage: 3,</span><br><span class=\"line\">\tpageSize: 10,</span><br><span class=\"line\">\tlastTime: 103232</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">response: &#123;</span><br><span class=\"line\">\t[]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>后端返回了一个空数据。</p>\n<p>如果这么定义的话，前端会以为已经请求空了，就会告诉用户已经没有数据了。</p>\n<p>这个时候其实就出BUG了。</p>\n<p>那这个怎么解呢？<br>很容易想到的就是：<br>response中带上total字段，前端判断后续有没有数据按照total来。<br>那其实和注意事项一又冲突了。不好。</p>\n<p>还有个解法：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response: &#123;</span><br><span class=\"line\">\t[],</span><br><span class=\"line\">\thasNext: true</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>用<code>hasNext</code>告诉前端有没有后续数据了<br><code>hasNext</code>怎么来呢？<br>我们从zset中range获取的时候，如果拉出来的个数小于pageSize，那么就是false。<br>如果等于pageSize，那么就是true。</p>\n<h2 id=\"妥协策略\"><a href=\"#妥协策略\" class=\"headerlink\" title=\"妥协策略\"></a>妥协策略</h2><p>全存Redis，当然会有问题，数据量太大怎么办？<br>对于妥协策略1，我们定时的扫我们的Key（或者查询时，插入时异步操作），如果发现有些点赞记录太久远，就把Value删除。<br>这样我们的Redis负担就小点，<br>但是对不起，这样其实把妥协策略2也做了，是行不通的。</p>\n<h1 id=\"类Redis数据库\"><a href=\"#类Redis数据库\" class=\"headerlink\" title=\"类Redis数据库\"></a>类Redis数据库</h1><p>但是又不想抛弃Redis，因为Redis实现起来确实简单啊。<br>那怎么办？<br>类Redis数据库来救场了。</p>\n<p>类Redis说白了就是兼容Redis的指令，但是存储上，不全存内存，会存到磁盘上。<br>目前市面上比较流行的类Redis数据库有Pika，SSDB这种<br>具体笔者也没使用过，就不做评价，简单介绍下<br>小公司可以自己搭建着玩玩，但是大公司可能就没这个场景了，需要懂这个的运维来支持。</p>\n<h2 id=\"Pika\"><a href=\"#Pika\" class=\"headerlink\" title=\"Pika\"></a>Pika</h2><h2 id=\"SSDB\"><a href=\"#SSDB\" class=\"headerlink\" title=\"SSDB\"></a>SSDB</h2><h1 id=\"Redis-Mysql\"><a href=\"#Redis-Mysql\" class=\"headerlink\" title=\"Redis + Mysql\"></a>Redis + Mysql</h1><p>这种比较少见其实，但是好歹这两数据库在公司都是标配。<br>主要是Redis存热数据，Mysql存冷数据。</p>\n<p>写的时候双写<br>查询的时候先查Redis，Redis查不到再去查Mysql<br>分页查询的时候，查Redis，过期了就去Mysql捞一部分，然后存回Redis，设置个过期时间。<br>太久的就直接查Mysql，没必要存Redis了。</p>\n<p>但是这里得考虑几个问题：</p>\n<ol>\n<li>这种行为数据，实时写数据库一般不会同意的，可以先写Redis，然后搞个消息队列慢慢写数据库</li>\n<li>查是否给该文章点赞过，先查Redis，如果空了，再查Mysql。可能会出问题，有点隐患，不过也不用太担心，因为在Mysql中的一般就是冷数据库，问题不大。Redis存的容量大一点。</li>\n<li>分页查询点赞历史，先查Redis，到底了去查Mysql，这里切换的衔接逻辑得好好想想。问题也不是很大。</li>\n</ol>\n<p>看起来很不错是不是，但是这种方案，最大的问题还是Mysql。<br>你想想这个表里的数据长啥样？<br>就几个字段：</p>\n<ol>\n<li>id：自增主键</li>\n<li>uid：用户id</li>\n<li>weiboId：微博id</li>\n<li>createTime：点赞时间</li>\n<li>del：是否删除了（这个看公司吧，有的只允许逻辑删除）</li>\n</ol>\n<p>这表数据太简单了，如果真到微博那种量级，增长速度会很快很快。<br>假设用户200w，每个人点赞2篇内容，那么一天增长400w条记录，一年就146000w，14亿。<br>这谁顶得住。</p>\n<p>这种其实硬要解还是有点方法：</p>\n<ol>\n<li>压缩表：把字段weiboId，改成weiboIds，一行记录多存几个点赞记录。数据行数可以缩小几个量级，但是插入，查询和Redis衔接起来就比较复杂了。<strong>同时删除几乎不好做了。</strong></li>\n<li>分库分表。其实我感觉分库分表意义不大。</li>\n</ol>\n<h2 id=\"妥协策略-1\"><a href=\"#妥协策略-1\" class=\"headerlink\" title=\"妥协策略\"></a>妥协策略</h2><p>来看看这种方案，如果产品妥协了，会不会简单点：<br>妥协策略1：查是否点过赞，Redis查不到，就默认未点赞，不用去查Mysql了。<br>妥协策略2：查完Redis，去查Mysql，可以支持。</p>\n<p>其实再拓展下，如果产品妥协了策略1，那么写入的时候，只写Redis，然后再在某个时间点，把冷数据同步到Mysql就行。<br>这样就不用双写数据库了，同时同步的时候可以批量查入。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>所以综合来看，功能上，对热点数据的点赞/取消点赞/查询是否点赞比较好<br>如果你压缩数据行：对冷数据（Mysql中的数据），取消点赞，分页查询点赞记录比较复杂。<br>如果你不压缩：数据量太大</p>\n<h1 id=\"Redis-Hbase\"><a href=\"#Redis-Hbase\" class=\"headerlink\" title=\"Redis + Hbase\"></a>Redis + Hbase</h1><p>Redis + Hbase算是比较终极的方案了。<br>其实笔者对Hbase也不是很了解。<br>了解了再说吧。</p>\n","categories":["业务思考"],"tags":["Redis","业务思考","Hbase","Pika","分库分表"]},{"title":"搞懂内存屏障-指令与JMM","url":"https://blog.lovezhy.cc/2020/03/14/搞懂内存屏障-指令与JMM/","content":"<p>前面讲了CPU的演进，提出了StoreBuffer和InvalidateQueue的设计，并且讲解了这两个设计会带来的问题。<br>解决这两个问题就是引入内存屏障：强制刷新StoreBuffer和InvalidateQueue。</p>\n<p>这里详细讲讲x86机器上的内存屏障指令与其他隐式的含有内存屏障的指令。<br>然后再聊一聊JMM与内存屏障的对应关系。</p>\n<a id=\"more\"></a>\n<h1 id=\"x86与内存屏障\"><a href=\"#x86与内存屏障\" class=\"headerlink\" title=\"x86与内存屏障\"></a>x86与内存屏障</h1><p>前面提到的StoreBuffer和InvalidateQueue并不是所有的CPU都会去实现。<br>其中x86的机器上，遵循的内存一致性协议叫TSO协议。<br>在这个协议中，有个叫WriteBuffer的东西，就是对应StoreBuffer。<br>但是并没有InvalidateQueue的存在。</p>\n<h1 id=\"内存屏障指令集\"><a href=\"#内存屏障指令集\" class=\"headerlink\" title=\"内存屏障指令集\"></a>内存屏障指令集</h1><p>上文中，提到了三个内存屏障的指令：</p>\n<ol>\n<li>lfence()：读屏障</li>\n<li>sfence()：写屏障</li>\n<li>mfence()：读写屏障</li>\n</ol>\n<p>那么在代码中是怎么定义的呢：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> barrier() __asm__ __volatile__(<span class=\"meta-string\">\"\"</span>: : :<span class=\"meta-string\">\"memory\"</span>) </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> mb() alternative(<span class=\"meta-string\">\"lock; addl $0,0(%%esp)\"</span>, <span class=\"meta-string\">\"mfence\"</span>, X86_FEATURE_XMM2) </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rmb() alternative(<span class=\"meta-string\">\"lock; addl $0,0(%%esp)\"</span>, <span class=\"meta-string\">\"lfence\"</span>, X86_FEATURE_XMM2)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> wmb() alternative(<span class=\"meta-string\">\"lock; addl $0,0(%%esp)\"</span>, <span class=\"meta-string\">\"sfence\"</span>, X86_FEATURE_XMM)   </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_SMP </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> smp_mb() mb() </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> smp_rmb() rmb() </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> smp_wmb() wmb() </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> smp_read_barrier_depends() read_barrier_depends() </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> set_mb(var, value) do &#123; (void) xchg(&amp;var, value); &#125; while (0) </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span> </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> smp_mb() barrier() </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> smp_rmb() barrier() </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> smp_wmb() barrier() </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> smp_read_barrier_depends() do &#123; &#125; while(0) </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> set_mb(var, value) do &#123; var = value; barrier(); &#125; while (0) </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure></p>\n<p>首先来看barrirer()的定义，这个是禁止编译器进行重排序的。<br>具体的解释可以参考笔者的另外一个文章：<a href=\"https://blog.lovezhy.cc/2020/03/08/volatile%E5%92%8C%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/\">volatile和内存屏障</a></p>\n<p>然后我们看CONFIG_SMP，如果定义了这个，说明该机器上不止一个Core，否则就是单核心的机器。<br>在单核心的机器上，所有的CPU的内存屏障指令都是空指令，只有禁止编译器重排序的作用。<br>这个也好理解，就不多做解释了。</p>\n<p>而在多核心的机器上，分别定义了:</p>\n<ol>\n<li>smp_mb()：读写屏障</li>\n<li>smp_rmb()：读屏障</li>\n<li>smp_wmb()：写屏障</li>\n</ol>\n<p>同时我们看具体的实现，也就是用到了我们上面提到了lfence，sfence，mfence。</p>\n<p>但是我们再仔细看看这句话：<br><code>#define rmb() alternative(&quot;lock; addl $0,0(%%esp)&quot;, &quot;lfence&quot;, X86_FEATURE_XMM2)</code></p>\n<p>如果CPU没有lfence指令，那么就用<code>lock; addl $0,0(%%esp)</code>代替。<br>为什么？难道<code>lock; addl $0,0(%%esp)</code>也能有内存屏障的语义吗？</p>\n<p>是的！<br>除了fence指令，还有很多的其他的指令也隐藏了内存屏障的语义。<br>下面笔者来总结一下：</p>\n<h2 id=\"常见的三种\"><a href=\"#常见的三种\" class=\"headerlink\" title=\"常见的三种\"></a>常见的三种</h2><p>x86/64系统架构提供了三种多核的内存屏障指令：(1) sfence; (2) lfence; (3) mfence</p>\n<ol>\n<li>sfence：在sfence指令前的写操作当必须在sfence指令后的写操作前完成。</li>\n<li>lfence：在lfence指令前的读操作当必须在lfence指令后的读操作前完成。</li>\n<li>mfence：在mfence指令前的读写操作当必须在mfence指令后的读写操作前完成。</li>\n</ol>\n<p>其实总结起来就是读屏障，写屏障，读写屏障。</p>\n<p>上述的是显式的会起到内存屏障作用的指令，但是还有许多指令带有异常的内存屏障的作用。</p>\n<h2 id=\"MMIO写屏障\"><a href=\"#MMIO写屏障\" class=\"headerlink\" title=\"MMIO写屏障\"></a>MMIO写屏障</h2><p>Linux 内核有一个专门用于 MMIO 写的屏障：<br><code>mmiowb()</code><br>笔者也不熟悉这个的作用，后续再补上</p>\n<h2 id=\"隐藏的内存屏障\"><a href=\"#隐藏的内存屏障\" class=\"headerlink\" title=\"隐藏的内存屏障\"></a>隐藏的内存屏障</h2><p>Linux 内核中一些锁或者调度函数暗含了内存屏障。</p>\n<p>锁函数：</p>\n<ul>\n<li>spin locks</li>\n<li>R/W spin locks</li>\n<li>mutexes</li>\n<li>semaphores</li>\n<li>R/W semaphores</li>\n</ul>\n<p>中断禁止函数：<br>启动或禁止终端的函数的作用仅仅是作为编译器屏障，所以要使用内存或者 I/O 屏障 的场合，必须用别的函数。</p>\n<p>SLEEP和WAKE-UP以及其它调度函数：<br>使用 SLEEP 和 WAKE-UP 函数时要改变 task 的状态标志，这需要使用合适的内存屏 障保证修改的顺序。</p>\n<h1 id=\"JMM\"><a href=\"#JMM\" class=\"headerlink\" title=\"JMM\"></a>JMM</h1><p>在JMM中，定义了4中内存可见性语义：</p>\n<ol>\n<li>LoadLoad</li>\n<li>LoadStore</li>\n<li>StoreStore</li>\n<li>StoreLoad</li>\n</ol>\n<p>但是这些指令对应到x86的机器上，并不是都需要实现的。<br>因为x86的核心问题是有StoreBuffer，一个值被Core0写入了StoreBuffer，另外一个Core可能读不到最新的值，除非Flush StoreBuffer。所以StoreLoad语义需要内存屏障来维持。</p>\n<p>例如以下的例子：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    x=<span class=\"number\">1</span>;  <span class=\"comment\">//S1</span></span><br><span class=\"line\">    r1=y;  <span class=\"comment\">//S2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bar</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    y=<span class=\"number\">1</span>;  <span class=\"comment\">//L1</span></span><br><span class=\"line\">    r2=x;<span class=\"comment\">//L2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在这个例子中，如果没有内存屏障，Core0执行foo，Core1执行bar，则r1和r2可能出现同时为0的情况。</p>\n<p>再具体的这个文章讲的很好：<a href=\"https://zhuanlan.zhihu.com/p/81555436\" target=\"_blank\" rel=\"noopener\">为什么在 x86 架构下只有 StoreLoad 屏障是有效指令？</a></p>\n<h2 id=\"更具体的例子\"><a href=\"#更具体的例子\" class=\"headerlink\" title=\"更具体的例子\"></a>更具体的例子</h2><p>下面我们看看代码，经过JIT编译后的指令<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> b = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">        add();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">        a++;</span><br><span class=\"line\">        b += <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果a没有被volatile修饰：<br><img src=\"/images/搞定内存屏障-指令与JMM/1.png\" alt=\"image-20200314152942448\"><br>可以看到a和b的操作分别对应：<br><code>inc %r9d</code><br><code>add $0x2, %r9d</code><br>中间没有任何内存屏障的指令</p>\n<p>如果我们加上volatile修饰呢？<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> b = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">        add();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">        a++;</span><br><span class=\"line\">        b += <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"/images/搞定内存屏障-指令与JMM/2.png\" alt=\"image-20200314153303884\"><br>可以很明显的看到两个<code>lock</code>指令。</p>\n","categories":["计算机基础"],"tags":["内存屏障"]},{"title":"搞懂内存屏障-CPU的演进","url":"https://blog.lovezhy.cc/2020/03/14/搞懂内存屏障-CPU的演进/","content":"<p>内存屏障是随着SMP系统的出现而出现的，也就意味着在单核的机器上，不需要任何的内存屏障。</p>\n<p>所以要想理解内存屏障的意义，我们需要知道CPU从单核到多核，究竟修改了什么，需要我们引入内存屏障</p>\n<a id=\"more\"></a>\n<h1 id=\"单核时代\"><a href=\"#单核时代\" class=\"headerlink\" title=\"单核时代\"></a>单核时代</h1><p>如果我们把CPU看做黑盒的话，简单的计算机中，除了CPU负责运算外，还需要存储系统进行存储。这个存储系统就是主存。<br><img src=\"/images/cpu演进/1.png\" alt=\"\"></p>\n<p>但是问题来了，我们知道cpu的速度其实是很快很快的，但是主存的写入和读取的速度过慢，如果这么运行的话，会导致cpu的很多时间都浪费了。</p>\n<p>如果在cpu和主存中间，加入了很多的cache系统，通常来说有L1，L2，L3等。<br><img src=\"/images/cpu演进/2.png\" alt=\"\"><br>cache的速度比主存快的多，这样会大大的提高性能。</p>\n<p>在单核的系统中，当然是没问题的，因为只有一个CPU，所有的读取和写入都是它。<br>虽然一个值可能在主存和Cache中都有，但是都以Cache中的为准就行了。</p>\n<h1 id=\"多核时代\"><a href=\"#多核时代\" class=\"headerlink\" title=\"多核时代\"></a>多核时代</h1><p>但是引入了SMP多核系统后，每个核心都有一个属于他自己的Cache。<br><img src=\"/images/cpu演进/3.png\" alt=\"\"></p>\n<p>这就导致了一个问题。<br>我们知道Cache中的值其实是主存中的拷贝。<br>对一个值的修改先写到Cache中，再写到主存中，具体写入延迟不定。<br>对一个值的读取也是先从主存中读取到Cache中，CPU再从Cache中读取，什么时候失效也是不定。</p>\n<p>多核的系统中，每个核心都有自己的Cache，并且是互相不可见的。<br>这就导致值的写入延迟和延迟失效都会导致数据不一致的问题。</p>\n<p>怎么解决呢？<br>这个时候其实有个简单的方案：</p>\n<ol>\n<li>每次写入Cache时，锁总线，同步再写入主存</li>\n<li>每次读取值时，锁总线，从主存中读。</li>\n</ol>\n<p>但是如果使用这种方案的话，那Cache基本就废了，毫无用处。</p>\n<p>那怎么办呢？<br>那就让CPU的Cache“互相可见”吧。<br>于是MESI协议就诞生了。</p>\n<h1 id=\"MESI协议\"><a href=\"#MESI协议\" class=\"headerlink\" title=\"MESI协议\"></a>MESI协议</h1><p>MESI协议，是一种缓存一致性协议，顾名思义，就是解决各个核心的Cache之间，对于同一个值的一致性问题。</p>\n<p>首先我们要知道，Cache其实是分块的，类似于磁盘的分页，Cache的每一块叫一个CacheLine，对于Cache的基本操作都是以CacheLine为基本单位。</p>\n<p>MESI协议定义每个CacheLine有4种状态：</p>\n<ol>\n<li>Modified：表示这个CacheLine对应的主存数据，只在当前核心中，并且已经被当前核心修改过，和主存中不一样。</li>\n<li>Exclusive：该CacheLine对应的主存数据只在当前核心中，当前核心还未修改该CacheLine。</li>\n<li>Shared：该CacheLine对应的主存数据，也会在别的核心中，但是大家都不能修改，相当于只读。</li>\n<li>Invalid：协议未使用</li>\n</ol>\n<p>同时定义了CPU之间可以互发的六种消息：</p>\n<ol>\n<li>Read：由某个cpu发出给其他的cpu和主存，包含要读的主存地址</li>\n<li>Read Response：由主存或者其他的cpu发出的对于Read的响应，收到响应后把CacheLine放入自己的核心缓存中</li>\n<li>Invalidate：请求中包含需要失效的数据地址，当收到Invalidate请求后，核心必须要删除这部分数据地址</li>\n<li>Invalidate Ack：当核心删除Invalidate请求的数据地址后，发送Ack给来源的CPU</li>\n<li>WriteBack：当CacheLine为Modify状态时，核心将该数据写回到主存时发出</li>\n</ol>\n<p>说到这里你可以明白了MESI大致的作用：<br>当某个核心想要修改某个CacheLine的数据时，由于该CacheLine可能也在其他的核心中，所以必须要发消息给其他的核心，先移除对应的CacheLine。<br>同时，如果其他的核心有对应的CacheLine，必须先从自己的Cache中移除。以免自己读到已经被修改过的数据。</p>\n<p>具体的操作流程有点复杂，估计读者也没耐心读完，这里就略过了。<br>想要详细了解的可以阅读本文的参考文章。</p>\n<h1 id=\"StoreBuffer和InvalidaQueue\"><a href=\"#StoreBuffer和InvalidaQueue\" class=\"headerlink\" title=\"StoreBuffer和InvalidaQueue\"></a>StoreBuffer和InvalidaQueue</h1><p>有了MESI协议，Cache还是派的上用场，但是每次写入都得通知其他的核心，同时接收到其他核心的写入，还得把自己的那部分CacheLine失效。<br>必然会拖慢很多的性能。</p>\n<p>比如说，当Core0想要修改a的值，但是发现a并不在CacheLine中，或者在CacheLine中，是Shared状态，这个时候他并不能直接修改a的值，他需要发消息给其他的Core， Invalidate这部分CacheLine，等所有的Core返回Ack的时候，他才能修改。<br>这部分时间cpu属于Stall状态。<br>那怎么办呢？<br>于是在写入Cache前，加入了一个Store Buffer。<br><img src=\"/images/cpu演进/4.png\" alt=\"\"></p>\n<p>当需要写入一个值的时候，如果这个值的CacheLine并不在当前核心，或者该CacheLine并不是Modified或者Exclusive状态，先写入StoreBuffer，等其他的CPU的Ack到来时候，再择机把StoreBuffer中的值写入Cache。<br>同时，由于对该核心而言，一个值可能已经被修改了，但是并不在Cache中，而是在StoreBuffer中，所以读取的时候，以StoreBuffer的为准。</p>\n<p>除了写入一个值时，需要进行等待，当收到Invalidate请求时，CPU也得放下手中的活，把CacheLine删除发送Ack才能继续。<br>这部分时间能不能缩减呢？<br>我们引入InvalidateQueue。<br><img src=\"/images/cpu演进/5.png\" alt=\"\"><br>当接收到其他的Invalidate请求时，我们将请求放在InvalidateQueue中，并立马返回Ack。<br>再择机把InvalidateQueue中标志到的需要失效的CacheLine移除。</p>\n<h1 id=\"StoreBuffer导致的问题\"><a href=\"#StoreBuffer导致的问题\" class=\"headerlink\" title=\"StoreBuffer导致的问题\"></a>StoreBuffer导致的问题</h1><p>我们首先看一段代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    a=<span class=\"number\">1</span>;  <span class=\"comment\">//S1</span></span><br><span class=\"line\">    b=<span class=\"number\">1</span>;  <span class=\"comment\">//S2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bar</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (b == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;  <span class=\"comment\">//L1</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span>(a == <span class=\"number\">1</span>);           <span class=\"comment\">//L2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果CPU0执行foo函数，CPU1执行bar函数。<br>同时a的值所在的CacheLine并不在CPU0中，b的值所在的CacheLine在CPU0中，并且是Exlusive状态。</p>\n<ol>\n<li>CPU0执行S1，发现a不在CacheLine中，发送Read Validate消息给主存和CPU1。同时把a=1的值放入StoreBuffer。</li>\n<li>CPU0执行S2，b值所在的CacheLine在CPU0中，并且是Exlusive状态，于是直接修改为1，放入CPU缓存。</li>\n<li>这个时候CPU1启动运行bar函数，发现b不在CacheLine中，于是广播Read，获取b的值</li>\n<li>CPU0得到这个Read b的消息，把b的值发送回去</li>\n<li>CPU1得到b的值为1，L1通过</li>\n<li>CPU1执行L2，a在CacheLine中并且是0，assert fail</li>\n<li>CPU1得到第1步的Read Validate消息，把a所在的CacheLine移除。</li>\n</ol>\n<p>步骤有点复杂，需要耐心阅读。<br>核心就是第1步的Read Validate消息，CPU1延迟到第7步才收到。</p>\n<p>那怎么避免这种情况呢？<br>我们能不能让StoreBuffer退化到没有之前的流程？<br>也就是把第一步中的操作中，写入StoreBuffer后，不允许执行后续的操作，直到收到Validate Ack消息。<br>于是我们引入sfence()函数，遇到这个函数时，必须等到所有的Validate Ack，并且把StoreBuffer全部Flush到Cache，清空StoreBuffer。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    a=<span class=\"number\">1</span>;  <span class=\"comment\">//S1</span></span><br><span class=\"line\">    sfence();</span><br><span class=\"line\">    b=<span class=\"number\">1</span>;  <span class=\"comment\">//S2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bar</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (b == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;  <span class=\"comment\">//L1</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span>(a == <span class=\"number\">1</span>);           <span class=\"comment\">//L2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"InvalidateQueue导致的问题\"><a href=\"#InvalidateQueue导致的问题\" class=\"headerlink\" title=\"InvalidateQueue导致的问题\"></a>InvalidateQueue导致的问题</h1><p>还是看这段代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    a=<span class=\"number\">1</span>;  <span class=\"comment\">//S1</span></span><br><span class=\"line\">    sfence();</span><br><span class=\"line\">    b=<span class=\"number\">1</span>;  <span class=\"comment\">//S2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bar</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (b == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;  <span class=\"comment\">//L1</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span>(a == <span class=\"number\">1</span>);           <span class=\"comment\">//L2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>InvalidateQueue导致的就是，将CacheLine的移除时机变得不可确定。即使这个指示需要移除该CacheLine的Invalidate消息已经在InvalidateQueue中了，CPU还是会可能会从自己的Cache中读到旧的值。</p>\n<p>比如例子中：<br>Core0执行foo函数，此时a在Core1中。<br>Core0发送Read Invalidate消息，Core1返回a的值，同时将Invalidate消息放入InvalidateQueue。<br>Core0将a=1推送到Cache中。<br>Core0执行b=1，放入缓存中。<br>Core1发送Read b的消息，Core0返回b=1；<br>L1执行成功，Core1获取a的值，由于移除该CacheLine的Invalidate消息还在InvalidateQueue中，所以发现a的值在Cache中，并且为0。<br>于是assert fail。</p>\n<p>于是我们引入lfence()函数，该函数强制刷新InvalidateQueue。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    a=<span class=\"number\">1</span>;  <span class=\"comment\">//S1</span></span><br><span class=\"line\">    sfence();</span><br><span class=\"line\">    b=<span class=\"number\">1</span>;  <span class=\"comment\">//S2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bar</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (b == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;  <span class=\"comment\">//L1</span></span><br><span class=\"line\">    lfence();</span><br><span class=\"line\">    <span class=\"keyword\">assert</span>(a == <span class=\"number\">1</span>);           <span class=\"comment\">//L2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>前文提到的sfence()和lfence()，便是内存屏障。<br>一个是写屏障，也就是同步刷新StoreBuffer<br>一个是读屏障，也就是同步刷新InvalidateQueue。<br>也有mfence()，既刷新StoreBuffer，也刷新InvalidateQueue。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://zhuanlan.zhihu.com/p/48157076\" target=\"_blank\" rel=\"noopener\">高并发编程–多处理器编程中的一致性问题(上)</a><br><a href=\"https://zhuanlan.zhihu.com/p/55767485\" target=\"_blank\" rel=\"noopener\">为什么需要内存屏障</a></p>\n","categories":["计算机基础"],"tags":["内存屏障"]},{"title":"搞懂内存屏障-CPU重排序","url":"https://blog.lovezhy.cc/2020/03/09/搞懂内存屏障-CPU重排序/","content":"<p>我决定写一个系列，从头到尾讲一讲我理解的内存屏障的起源。<br>要想真正理解内存屏障，其实要讲很多的东西。</p>\n<p>第一节，先来讲讲CPU的执行与重排序。</p>\n<a id=\"more\"></a>\n<h1 id=\"CPU的执行\"><a href=\"#CPU的执行\" class=\"headerlink\" title=\"CPU的执行\"></a>CPU的执行</h1><h2 id=\"流水线\"><a href=\"#流水线\" class=\"headerlink\" title=\"流水线\"></a>流水线</h2><p>当然我对CPU几乎没系统的学过，都是从网上看看博客学来的。</p>\n<p>CPU执行一条指令需要4个步骤（当然网上可能有其他说法，比如三个步骤或者五个步骤，不过没关系，不影响下面我们的结论）：</p>\n<ol>\n<li>取址：从内存中取出指令</li>\n<li>译码：翻译指令，生成响应的控制信号</li>\n<li>执行：使用CPU的逻辑处理单元计算</li>\n<li>回写：把结果写回到寄存器或者内存</li>\n</ol>\n<p>假设我们有三条指令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov $0x0, %esi</span><br><span class=\"line\">mov $0x0, %edi</span><br><span class=\"line\">and $0xf, %ebx</span><br></pre></td></tr></table></figure></p>\n<p>我们把这四个步骤都合并成一个组合逻辑去运行的话<br>架构图如下：<br><img src=\"/images/CPU重排序/1.png\" alt=\"\"></p>\n<p>那么我们需要的时间其实就是串行的，如下图：<br><img src=\"/images/CPU重排序/2.png\" alt=\"\"></p>\n<p>但是这样，太慢了。<br>于是CPU流水线技术就诞生了（大约在Intel 386里开始出现）。</p>\n<p>原理大概是把一个组合逻辑，拆分成多个小的组合逻辑：<br><img src=\"/images/CPU重排序/3.png\" alt=\"\"><br>这样，第一个指令进行组合逻辑B的时候，第二个指令就可以进行组合逻辑A了。<br>我们的时间消耗可以大大减少：<br><img src=\"/images/CPU重排序/4.png\" alt=\"\"></p>\n<h2 id=\"冒险\"><a href=\"#冒险\" class=\"headerlink\" title=\"冒险\"></a>冒险</h2><p>上面的例子中，流水线可以非常完美。因为我们的三个指令所需的数据都互不依赖。<br>但是如果指令是这样的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mov $0x0, %esi</span><br><span class=\"line\">Mov $0x0, %edi</span><br><span class=\"line\">Add %esi, %edi</span><br></pre></td></tr></table></figure></p>\n<p>第三个指令，是把第一个指令和第二个指令的结果进行相加<br>如果我们仍采用上述的流水线去运行，就会出问题：<br><img src=\"/images/CPU重排序/5.png\" alt=\"\"><br>CPU在执行Add指令时，依赖第二步中%edi的值。<br>但是指令3执行到第二个组合逻辑时，第二个指令还没写回到寄存器。<br>这样下去，指令3的Add用到的%edi，其实就不是0。<br>和预期的结果不符合。</p>\n<p>这个就叫冒险<br>其中冒险分为数据冒险和控制冒险，数据冒险就是我们上面提到的。<br>而控制冒险和数据冒险类似，不过一般涉及到跳转指令。</p>\n<p>如：<br><img src=\"/images/CPU重排序/6.png\" alt=\"\"><br>我们在执行JE的时候，依赖上一步的CMP的结果，导致正常的流水线执行就会有问题。</p>\n<h2 id=\"Bubble\"><a href=\"#Bubble\" class=\"headerlink\" title=\"Bubble\"></a>Bubble</h2><p>那怎么解决呢？<br>就是插入Nop指令。</p>\n<p><img src=\"/images/CPU重排序/7.png\" alt=\"\"><br>如上图所示，我们在第二个指令和第三个指令中间加入一个Nop指令，空转一个流水线。</p>\n<p>当然我们不需要编译器每次都进行加入Nop，CPU会自己加入。<br>这个就叫Bubble，而执行Bubble叫Stall。<br><img src=\"/images/CPU重排序/8.png\" alt=\"\"></p>\n<p>对于分支预测而言，CPU除了Bubble，还可能会随机选择一个分支先去执行，等CMP的结果出来，如果预测错了，就把执行结果丢弃掉：<br><img src=\"/images/CPU重排序/9.png\" alt=\"\"><br>分支预测失败当然是比较消耗性能的，Google的报告上指出了一次错误的分支预测的耗时：<br><img src=\"/images/CPU重排序/10.png\" alt=\"\"></p>\n<p><img src=\"/images/CPU重排序/11.png\" alt=\"\"></p>\n<h1 id=\"重排序\"><a href=\"#重排序\" class=\"headerlink\" title=\"重排序\"></a>重排序</h1><p>除了Bubble和分支预测的解决方案，还有一种解决方案，就是CPU的重排序。</p>\n<p>对于下面的指令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADD AX, BX;   </span><br><span class=\"line\">INC AX;         </span><br><span class=\"line\">MOV CX, DX;</span><br></pre></td></tr></table></figure></p>\n<p>ADD和INC操作都用到了AX，必然会导致Stall。<br>但是我们发现MOV指令和ADD和INC都没有关系，<br>那么我们能不能调换顺序：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADD AX, BX;  </span><br><span class=\"line\">MOV CX, DX; </span><br><span class=\"line\">INC AX;</span><br></pre></td></tr></table></figure></p>\n<p>在执行时使用这种次序呢？<br>毕竟这种次序，就不会产生Stall，性能必然会提升。</p>\n<p>这种就是CPU的重排序。</p>\n<h1 id=\"锅是谁的？\"><a href=\"#锅是谁的？\" class=\"headerlink\" title=\"锅是谁的？\"></a>锅是谁的？</h1><p>在x86的机器上，CPU会进行大量的指令重排序。<br>但是CPU重排序也不会想重排就重排的，而是需要遵守一定的规范，不然就会影响软件的正常运行。</p>\n<p>比如说下面这段经典的代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> x = <span class=\"number\">0</span>, y = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">0</span>, b = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">far</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    a=<span class=\"number\">1</span>;</span><br><span class=\"line\">    x=b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bar</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    b=<span class=\"number\">1</span>;</span><br><span class=\"line\">    y=a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果我们启动两个线程分别去执行far和bar函数。<br>正常的情况下，要么x=1，要么y=1，要么x=y=1;<br>但是也可能是x=y=0;</p>\n<p>怎么解释的呢？很多人是这么解释的，这里我找了一个博客的解释：</p>\n<blockquote>\n<p>这是处理器乱序执行的结果：<br>线程t1内部的两行代码之间不存在数据依赖<br>因此，可以将x = b乱序到a = 1前；<br>同时，线程t2中的y = a早于线程t1中的a = 1执行。<br>一个可能的执行序列如下：<br>t1: x = b<br>t2: b = 1<br>t2: y = a<br>t1: a = 1</p>\n</blockquote>\n<p>看起来非常的有道理，CPU乱序执行害死人。<br>但是事实确实如此吗？<br>这个锅真的是CPU重排序执行导致的吗？</p>\n<h1 id=\"真的能观测到CPU的重排序吗\"><a href=\"#真的能观测到CPU的重排序吗\" class=\"headerlink\" title=\"真的能观测到CPU的重排序吗\"></a>真的能观测到CPU的重排序吗</h1><p>我对CPU不熟悉，这里我就举几个网上的答案反驳吧。</p>\n<h2 id=\"反驳一\"><a href=\"#反驳一\" class=\"headerlink\" title=\"反驳一\"></a>反驳一</h2><p><a href=\"https://stackoverflow.com/questions/50307693/does-an-x86-cpu-reorder-instructions\" target=\"_blank\" rel=\"noopener\">Does an x86 CPU reorder instructions?</a><br>这个是英文回答，内容有点多，我从里面摘抄几个：</p>\n<blockquote>\n<p>Yes, all modern x86 chips from Intel and AMD aggressively reorder instructions across a window which is around 200 instructions deep on recent CPUs from both manufacturers</p>\n</blockquote>\n<p>肯定了x86的CPU会执行很多的指令重排序</p>\n<blockquote>\n<p>That should answer the titular question, but then your second question is about memory barriers. It contains, however, an incorrect assumption that instruction reordering necessarily causes (and is the only cause of) visible memory reordering</p>\n</blockquote>\n<p>这个其实超纲了，他提到了内存可见性的重排序。<br>否定了CPU的指令执行重排序一定会导致内存可见性问题。</p>\n<blockquote>\n<p>At the same time, x86 defines quite a strict memory model, which bans most possible reorderings<br>So actually most memory re-orderings are not allowed</p>\n</blockquote>\n<p>重点来了，x86定义了一个严格的内存模型，这个内存模型禁止了大多数可能的重排序<br>后续的文章中，我会提到这个内存模型。</p>\n<blockquote>\n<p>So it is possible to define an ISA that doesn’t allow any re-ordering at all, but under the covers do re-ordering but carefully check that it isn’t observed</p>\n</blockquote>\n<p>注意看这个词，<strong>observed</strong>。<br>是的，CPU确实会做指令的重排序，但是如果出现了重排序可以被observe的情况，就是BUG。<br>这里我们假定CPU不会出BUG。</p>\n<h2 id=\"反驳二\"><a href=\"#反驳二\" class=\"headerlink\" title=\"反驳二\"></a>反驳二</h2><p><a href=\"https://www.zhihu.com/question/53761499\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/53761499</a><br>有人问：</p>\n<blockquote>\n<p>如何辨识代码是否被CPU的乱序执行优化了？</p>\n</blockquote>\n<p>一个是<code>中央处理器 (CPU) 话题的优秀回答者</code>的回答：</p>\n<blockquote>\n<p>看不到，也无法控制，ROB存在的目的就是让上层程序员看到的执行结果回归顺序。有一些memory model带来的重排序是可以被上层检测到的，比如x86的TSO模型可以通过精心设计的load store序列检测到访存的乱序。</p>\n</blockquote>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>总而言之，我们记得一个词就够了：<code>observed</code>。<br>CPU确实会进行重排序，但是这种重排序是无法被我们观测到和控制的。<br>如果CPU没有BUG的话（基本上没听过CPU出现BUG），那么程序出现与预期不一致的行为，和CPU的重排序没半点关系。</p>\n<p>插一句，什么内存屏障之类的，和CPU的重排序也没有关系。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://uestc-dpz.github.io/blog/2016/11/17/Reordering.html\" target=\"_blank\" rel=\"noopener\">指令重排序</a><br><a href=\"https://www.zhihu.com/question/53761499\" target=\"_blank\" rel=\"noopener\">如何辨识代码是否被CPU的乱序执行优化了</a><br><a href=\"https://www.cs.utexas.edu/~lin/cs380p/Free_Lunch.pdf\" target=\"_blank\" rel=\"noopener\">https://www.cs.utexas.edu/~lin/cs380p/Free_Lunch.pdf</a><br><a href=\"https://monkeysayhi.github.io/2017/12/28/%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/\" target=\"_blank\" rel=\"noopener\">https://monkeysayhi.github.io/2017/12/28/%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/</a><br><a href=\"https://stackoverflow.com/questions/50307693/does-an-x86-cpu-reorder-instructions\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/50307693/does-an-x86-cpu-reorder-instructions</a></p>\n","categories":["计算机基础"],"tags":["内存屏障","CPU重排序"]},{"title":"volatile和内存屏障","url":"https://blog.lovezhy.cc/2020/03/08/volatile和内存屏障/","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>事实上，我很多次以为我懂了volatile的原理，最终都是错误的。<br>关于重排序，CPU，缓存一致性，内存可见性的话题，其实非常复杂。</p>\n<p>这篇文章较为混乱，较为详细的可以看笔者的一个系列：</p>\n<p><a href=\"https://blog.lovezhy.cc/2020/03/09/%E6%90%9E%E6%87%82%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C-CPU%E9%87%8D%E6%8E%92%E5%BA%8F/\">搞懂内存屏障-CPU重排序</a></p>\n<p><a href=\"https://blog.lovezhy.cc/2020/03/14/%E6%90%9E%E6%87%82%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C-CPU%E7%9A%84%E6%BC%94%E8%BF%9B/\">搞懂内存屏障-CPU的演进</a></p>\n<p><a href=\"https://blog.lovezhy.cc/2020/03/14/%E6%90%9E%E6%87%82%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C-%E6%8C%87%E4%BB%A4%E4%B8%8EJMM/\">搞懂内存屏障-指令与JMM</a><br><a id=\"more\"></a></p>\n<p>很多文章提到的关于volatile的例子：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> data[<span class=\"number\">5</span>] = &#123; <span class=\"number\">9</span>, <span class=\"number\">9</span>, <span class=\"number\">9</span>, <span class=\"number\">9</span>, <span class=\"number\">9</span> &#125;;</span><br><span class=\"line\">bool is_ready = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init_data</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>( <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; ++i )</span><br><span class=\"line\">    data[i] = i;</span><br><span class=\"line\">  is_ready = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sum_data</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>( !is_ready )</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>( <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i &lt;<span class=\"number\">5</span>; ++i )</span><br><span class=\"line\">    sum += data[i];</span><br><span class=\"line\">  printf( <span class=\"string\">\"%d\"</span>, sum );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>如果我们启动两个线程，线程1执行init_data()，另外一个线程不断执行sum_data()<br>正常的结果应该是0+1+2+3+4，但是由于重排序和内存可见性的问题，得到的结果是不一定的。</p>\n</blockquote>\n<p>其实我们很多人没有思考过一个问题：</p>\n<blockquote>\n<p>在这个例子中，是因为内存可见性的问题造成的，还是重排序的问题造成的？还是两个一起造成的</p>\n</blockquote>\n<p>太长不看：</p>\n<ol>\n<li>CPU对指令进行重排序的条件非常苛刻，在这个例子中，完全不存在CPU会将指令重排序的问题。这个代码运行出现的问题，完全是内存可见性的问题。</li>\n<li>其实关于Volatile的所有问题都是内存可见性的问题，只不过看起来像是CPU重排序了。</li>\n<li>内存屏障指令分编译器级别和CPU级别，内存屏障和CPU重排序没半点关系。</li>\n<li>CPU的厂家使用的协议和CPU具体实现不尽相同，JVM定义的4种内存屏障指令，在x86的机器上，其实只有一种有用，其他的都是空指令。</li>\n<li>JMM定义的”CPU缓存，主存“只是一种抽象，真正的CPU缓存实现，CPU之间在一定程度上是<strong>互相可见</strong>的。</li>\n</ol>\n<h1 id=\"我的思考\"><a href=\"#我的思考\" class=\"headerlink\" title=\"我的思考\"></a>我的思考</h1><p>上面的例子有点复杂，我们再举个简单的例子：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    a=<span class=\"number\">1</span>;  <span class=\"comment\">//S1</span></span><br><span class=\"line\">    b=<span class=\"number\">1</span>;  <span class=\"comment\">//S2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bar</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (b == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;  <span class=\"comment\">//L1</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span>(a == <span class=\"number\">1</span>);           <span class=\"comment\">//L2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>执行的流程和上面的例子一样，我们把步骤拆成了4个，分别为S1，S2，L1，L2。</p>\n<h2 id=\"正常流程\"><a href=\"#正常流程\" class=\"headerlink\" title=\"正常流程\"></a>正常流程</h2><p>正常流程应该是：<br><code>S1 &gt; S2 &gt; L1 &gt; L2</code><br>也就是说，在执行L2的时候，a=1已经执行过了，所以这个断言是正确的。</p>\n<h2 id=\"内存可见性导致的问题\"><a href=\"#内存可见性导致的问题\" class=\"headerlink\" title=\"内存可见性导致的问题\"></a>内存可见性导致的问题</h2><p>在JMM模型中，每个CPU都有自己的缓存，写入时，先写自己的缓存，然后再同步到主存中。<br>在这个例子中，如果还是<code>S1 &gt; S2 &gt; L1 &gt; L2</code>的执行顺序<br>但是S1执行结束后，a其实存在于三个地方，这三个地方的可能值为：</p>\n<ol>\n<li>foo线程所在的CPU缓存中，这个地方a=1</li>\n<li>bar线程所在的CPU缓存中，这个地方a=0或者a=1</li>\n<li>主存中，这个地方a=0或者a=1</li>\n</ol>\n<p>同样的S2执行结束后，b也存在于三个地方。</p>\n<p>如果在bar线程中，b的值为1，但是a的值还是0，那么断言还是失败的。</p>\n<p>这个时候有人会告诉你使用volatile<br>被volatile修饰的变量，每次写入时，会实时同步到主存中，每次读取时，实时从主存中读取<br>这个就会导致S1和S2执行完之后，L1和L2步骤的a和b的值都是最新的。<br>没毛病，说得通对吧。</p>\n<h2 id=\"重排序导致的问题\"><a href=\"#重排序导致的问题\" class=\"headerlink\" title=\"重排序导致的问题\"></a>重排序导致的问题</h2><p>CPU在执行中会对指令进行重排序<br>比如S1和S2这两个操作，在CPU看来没有任何数据依赖顺序，所以它可以乱序执行<br>这下执行顺序可能就变成<code>S2 &gt; L1 &gt; L2 &gt; S1</code>。<br>也会导致断言失败。<br>这个时候Volatile也会保证执行的时候不会导致重排序。<br>也没毛病。</p>\n<h2 id=\"内存屏障\"><a href=\"#内存屏障\" class=\"headerlink\" title=\"内存屏障\"></a>内存屏障</h2><p>Volatile的具体是怎么实现的呢？<br>实现就是插入内存屏障。<br>内存屏障是什么东西？<br>简单的说：保证内存屏障前的读写指令必须在屏障后的读写指令之前执行，通知被Volatile修饰的值，每次读取都从主存中读取，每次写入都同步写入主存（锁总线）。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>从这个例子中看到，其实重排序和内存可见性的问题都会导致程序产生和我们预期不一致的行为，<br>而Volatile恰好能解决这两个问题。</p>\n<h1 id=\"内存屏障底层指令\"><a href=\"#内存屏障底层指令\" class=\"headerlink\" title=\"内存屏障底层指令\"></a>内存屏障底层指令</h1><p>其实正常来说，一般的Java开发者能理解到上面的层次就行了。<br>但是我还想理解的更多，比如这个重排序其实是CPU级别的，我们的Volatile关键词，肯定会映射成汇编指令，那么是哪些汇编指令呢？</p>\n<p>我们先来了解一下<code>barrier()</code>函数。</p>\n<h2 id=\"编译器重排序\"><a href=\"#编译器重排序\" class=\"headerlink\" title=\"编译器重排序\"></a>编译器重排序</h2><p>对于指令重排序，我一直以为只有CPU才会进行重排序，其实编译器也会对我们的指令进行重排序。<br>举个例子：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> x, y, r;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    x = r;</span><br><span class=\"line\">    y = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果我们直接编译源文件：<code>g++ -S test.cpp</code><br>会得到这样的汇编文件：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">movl    r(%rip), %eax</span><br><span class=\"line\">movl    %eax, x(%rip)</span><br><span class=\"line\">movl    $<span class=\"number\">1</span>, y(%rip)</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，这个结果并没有进行重排序</p>\n<p>但是如果我们指定优化级别：<code>g++ -O2 –S test.cpp</code><br>得到的汇编指令如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">movl    r(%rip), %eax</span><br><span class=\"line\">movl    $<span class=\"number\">1</span>, y(%rip)</span><br><span class=\"line\">movl    %eax, x(%rip)</span><br></pre></td></tr></table></figure></p>\n<p>看，两个指令的顺序反了。<br>这也就是编译器的重排序。</p>\n<p>那么怎么避免呢？<br>这个时候<code>barrier()</code>函数就派上用场了。</p>\n<p>我们修改我们的代码：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> x, y, r;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t\tx = r;</span><br><span class=\"line\">\t\tbarrier();</span><br><span class=\"line\">    y = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个时候我们再进行编译，会发现顺序并没有颠倒。</p>\n<h2 id=\"内存屏障-1\"><a href=\"#内存屏障-1\" class=\"headerlink\" title=\"内存屏障\"></a>内存屏障</h2><p>我们从内核的代码中找出：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> barrier() __asm__ __volatile__(<span class=\"meta-string\">\"\"</span>: : :<span class=\"meta-string\">\"memory\"</span>) </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> mb() alternative(<span class=\"meta-string\">\"lock; addl $0,0(%%esp)\"</span>, <span class=\"meta-string\">\"mfence\"</span>, X86_FEATURE_XMM2) </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rmb() alternative(<span class=\"meta-string\">\"lock; addl $0,0(%%esp)\"</span>, <span class=\"meta-string\">\"lfence\"</span>, X86_FEATURE_XMM2)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_SMP </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> smp_mb() mb() </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> smp_rmb() rmb() </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> smp_wmb() wmb() </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> smp_read_barrier_depends() read_barrier_depends() </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> set_mb(var, value) do &#123; (void) xchg(&amp;var, value); &#125; while (0) </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span> </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> smp_mb() barrier() </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> smp_rmb() barrier() </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> smp_wmb() barrier() </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> smp_read_barrier_depends() do &#123; &#125; while(0) </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> set_mb(var, value) do &#123; var = value; barrier(); &#125; while (0) </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure></p>\n<p>别急，我们慢慢来看<br>内存屏障指令，大致有3个</p>\n<ol>\n<li><code>smp_mb</code></li>\n<li><code>smp_rmb</code></li>\n<li><code>smp_wmb</code></li>\n</ol>\n<p>但是看这个<code>#ifdef CONFGIG_SMP</code><br>SMP就是表示多核的意思。</p>\n<blockquote>\n<p>内存屏障指令，在单核和多核的系统中的实现定义是不一样的</p>\n</blockquote>\n<p>我们可以看到，如果计算机是单核的，那么其实所有的内存屏障指令都是编译器级别的，实际的实现都是<code>barrier()</code>函数，在CPU级别都是空操作。</p>\n<h2 id=\"我的疑惑\"><a href=\"#我的疑惑\" class=\"headerlink\" title=\"我的疑惑\"></a>我的疑惑</h2><p>其实不对啊，既然CPU会进行重排序，那为什么单核中并没有使用任何CPU的指令避免重排序呢？</p>\n<p>我们再回到那个例子：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    a=<span class=\"number\">1</span>;  <span class=\"comment\">//S1</span></span><br><span class=\"line\">    b=<span class=\"number\">1</span>;  <span class=\"comment\">//S2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bar</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (b == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;  <span class=\"comment\">//L1</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span>(a == <span class=\"number\">1</span>);           <span class=\"comment\">//L2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>假设这个程序是单核中执行的，也就是没有多核中的可见性的问题，但是CPU重排序的问题依然存在。<br>如果CPU进行重排序：<br><code>S2 &gt; L2 &gt; L2 &gt; S1</code><br>那不是仍然会出问题吗？</p>\n<p>黑人问号？</p>\n<p>带着这个问题，我继续开始了我的资料搜寻。</p>\n<h1 id=\"内存一致性\"><a href=\"#内存一致性\" class=\"headerlink\" title=\"内存一致性\"></a>内存一致性</h1><blockquote>\n<p>主要内容来自<a href=\"https://zhuanlan.zhihu.com/p/48157076\" target=\"_blank\" rel=\"noopener\">高并发编程–多处理器编程中的一致性问题(上)</a><br>很多东西这个文章解释的很好，建议先读一读，有的我就直接略讲了</p>\n</blockquote>\n<p>我产生上述疑惑的前提其实就是默认CPU会对指令进行重排序。<br>很多书中对Volatile也提到了这一点，问题源头都是CPU会对指令重排序。<br>这个时候我们可能会觉得CPU厂家不给力，把这个锅丢给了开发者去解决。</p>\n<p>其实不是的。</p>\n<blockquote>\n<p>那么为了保证不会出现这种超出预期的行为，我们就需要一种规则来约束这种行为不能出现。这个任务就是memory consistency需要保证的（这里指的是强一致性模型：SC/TSO， XC的memory consistency并不能保证这点）</p>\n</blockquote>\n<p>CPU的理论中，其实有一系列协议约束CPU的执行不能出现上述行为。<br>也就是memory consistency，内存一致性。或者也叫<code>Memory Model</code>。<br>中文资料关于这个话题确实很少被提到，这个知乎问答提到了哪儿可以去学习。<br><a href=\"https://www.zhihu.com/question/23572082\" target=\"_blank\" rel=\"noopener\">如何系统的学习 Memory Model?</a><br>其实这个话题也分理论与工业实现，就跟操作系统一样。</p>\n<p>笔者了解的也不多，这里就简单提一下。<br>关于内存一致性的问题，其实和分布式的精髓略相似，有强弱之分，不同的CPU架构上实现的强弱程度不同。</p>\n<h2 id=\"Sequential-Consistency\"><a href=\"#Sequential-Consistency\" class=\"headerlink\" title=\"Sequential Consistency\"></a>Sequential Consistency</h2><p>在理论上，不得不提一个人，Lamport，就是Paxos理论的那个教授。<br>他提出了<code>Sequential Consistency</code>，就是顺序一致性，硬件层面的一致性。</p>\n<p>在解释SC的理论之前，还得了解<code>Program Order</code>和<code>Memory Order</code></p>\n<blockquote>\n<p>Program Order: 就是我们写的代码的顺序，这个是静态的也是每个CPU core各自拥有的。<br>Memory Order: 就是代码执行的顺序，这个是全局的，每个CPU core对共享内存的执行都会出现在Memory order中。<br>用&lt;p 表示Program order的先于顺序，&lt;m表示Memory order的先于顺序。</p>\n</blockquote>\n<p>SC的形式化定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">If L(a) &lt;p L(b) ⇒ L(a) &lt;m L(b) /* Load→Load */</span><br><span class=\"line\">If L(a) &lt;p S(b) ⇒ L(a) &lt;m S(b) /* Load→Store */</span><br><span class=\"line\">If S(a) &lt;p S(b) ⇒ S(a) &lt;m S(b) /* Store→Store */</span><br><span class=\"line\">If S(a) &lt;p L(b) ⇒ S(a) &lt;m L(b) /* Store→Load */</span><br></pre></td></tr></table></figure></p>\n<p>在SC的理论中，这4种关系不允许被Reorder。<br>好了，根据这个理论，我们再看一看上面的代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    a=<span class=\"number\">1</span>;  <span class=\"comment\">//S1</span></span><br><span class=\"line\">    b=<span class=\"number\">1</span>;  <span class=\"comment\">//S2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bar</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (b == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;  <span class=\"comment\">//L1</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span>(a == <span class=\"number\">1</span>);           <span class=\"comment\">//L2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在foo函数中，a的Store在程序顺序中是大于b的Store的，所以a=1的MemoryOrder是必须要大于b=1的MemoryOrder的。</p>\n<p>也就说，如果CPU实现了SC协议，那么其实<code>S2 -&gt; S1</code>这个重排序是不允许的。</p>\n<h2 id=\"Total-Store-Order\"><a href=\"#Total-Store-Order\" class=\"headerlink\" title=\"Total Store Order\"></a>Total Store Order</h2><p>当然理论归理论，实现不一定按照理论来。<br>前面提到了SC的理论，在SC理论的指导下，一切都是按照顺序来的，对CPU重排序的条件非常苛刻。</p>\n<p>SC的问题：</p>\n<blockquote>\n<p>SC严格定义了对于共享内存的load和store操作，loadload，storestore，loadstore，storeload四种执行顺序是不允许reorder的。当下CPU的执行速度已经甩DRAM（memory）好几个量级，如果每次store，load操作都从DRAM读取会拖慢CPU的执行速度，在这个极度压榨硬件性能的时代，是不能接受这种行为的。因此在x86的架构实现中引入了TSO。</p>\n</blockquote>\n<p>简单说，就是CPU厂家觉得SC太严格，不利于性能提升，所以几乎没人用SC，而X86而言，他自己定义了一个叫Total Store Order的内存模型。</p>\n<p>在讲TSO之前，在提一嘴前面提到的，内存一致性的协议有强弱之分，就像分布式协议中的强一致性，最终一致性一样。<br>SC显然是强一致性，但是TSO的一致性就略微弱与SC。</p>\n<p>具体体现在哪儿呢：</p>\n<blockquote>\n<p>TSO在CPU与memory之间引入了write buffer。CPU写入的时候先写入write buffer然后就返回了，这样就将cpu与memory之间的差距隐藏了。</p>\n</blockquote>\n<p>引入了write buffer后，这里其实就是一个内存可见性的隐藏问题，在write buffer中的值，到memory中其实需要一段时间的，这个时间是不定的。</p>\n<p>所以还是会导致一些其他的问题出现：</p>\n<p>比如我们看这个例子：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    x=<span class=\"number\">1</span>;  <span class=\"comment\">//S1</span></span><br><span class=\"line\">    r1=y;  <span class=\"comment\">//L1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bar</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    y=<span class=\"number\">1</span>;  <span class=\"comment\">//S2</span></span><br><span class=\"line\">    r2=x;<span class=\"comment\">//L2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>还是上面这个例子，S1将x=1放到了core C1的write buffer中，S2将y=1放到了C2的write buffer中，那么在执行L1,L2的时候，r1与r2这时候从memory读到是0。这个是违背了SC的，但是这样的设计确实带来了性能的提升。</p>\n</blockquote>\n<p>怎么解决这个问题呢？</p>\n<p>可能你想到了，就是我们使用某种指令，让CPU去同步Flush这个write buffer中的值。<br>这个指令就是我们提到的内存屏障。</p>\n<p>在详细介绍内存屏障的指令前，我们在TSO模型下，看看我们之前举的例子，到底是什么原因导致的：<br>还是前面的例子：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    a=<span class=\"number\">1</span>;  <span class=\"comment\">//S1</span></span><br><span class=\"line\">    b=<span class=\"number\">1</span>;  <span class=\"comment\">//S2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bar</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (b == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;  <span class=\"comment\">//L1</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span>(a == <span class=\"number\">1</span>);           <span class=\"comment\">//L2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在TOS的引入了write buffer后，我们再来看看上面的例子还会出现问题吗？<br>如果a=1，b=1先后被写入write buffer，并没有写入memory。但是如果把write buffer中的值flush到内存，b=1这个可见性的时间 &gt;= a=1的可见性。<br>所以如果bar中，读到b=1了，那么a肯定也已经读到等于1了。<br>就不会出现上面的问题。</p>\n<p>这个时候，我们可以解答我的疑惑了<br>为什么单核的情况下，仅仅需要禁止编译器的重排序就行了？<br>答案就是在TSO模型下，在上面的例子中，CPU不会进行指令的重排序。</p>\n<h2 id=\"内存屏障指令\"><a href=\"#内存屏障指令\" class=\"headerlink\" title=\"内存屏障指令\"></a>内存屏障指令</h2><p>让我们再回到这个代码：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> barrier() __asm__ __volatile__(<span class=\"meta-string\">\"\"</span>: : :<span class=\"meta-string\">\"memory\"</span>) </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> mb() alternative(<span class=\"meta-string\">\"lock; addl $0,0(%%esp)\"</span>, <span class=\"meta-string\">\"mfence\"</span>, X86_FEATURE_XMM2) </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rmb() alternative(<span class=\"meta-string\">\"lock; addl $0,0(%%esp)\"</span>, <span class=\"meta-string\">\"lfence\"</span>, X86_FEATURE_XMM2)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> wmb() alternative(<span class=\"meta-string\">\"lock; addl $0,0(%%esp)\"</span>, <span class=\"meta-string\">\"sfence\"</span>, X86_FEATURE_XMM)   </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_SMP </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> smp_mb() mb() </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> smp_rmb() rmb() </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> smp_wmb() wmb() </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> smp_read_barrier_depends() read_barrier_depends() </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> set_mb(var, value) do &#123; (void) xchg(&amp;var, value); &#125; while (0) </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span> </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> smp_mb() barrier() </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> smp_rmb() barrier() </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> smp_wmb() barrier() </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> smp_read_barrier_depends() do &#123; &#125; while(0) </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> set_mb(var, value) do &#123; var = value; barrier(); &#125; while (0) </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"常见的三种\"><a href=\"#常见的三种\" class=\"headerlink\" title=\"常见的三种\"></a>常见的三种</h3><p>x86/64系统架构提供了三种多核的内存屏障指令：(1) sfence; (2) lfence; (3) mfence</p>\n<ol>\n<li>sfence：在sfence指令前的写操作当必须在sfence指令后的写操作前完成。</li>\n<li>lfence：在lfence指令前的读操作当必须在lfence指令后的读操作前完成。</li>\n<li>mfence：在mfence指令前的读写操作当必须在mfence指令后的读写操作前完成。</li>\n</ol>\n<p>其实总结起来就是读屏障，写屏障，读写屏障。</p>\n<p>上述的是显式的会起到内存屏障作用的指令，但是还有许多指令带有异常的内存屏障的作用。</p>\n<h3 id=\"MMIO写屏障\"><a href=\"#MMIO写屏障\" class=\"headerlink\" title=\"MMIO写屏障\"></a>MMIO写屏障</h3><p>Linux 内核有一个专门用于 MMIO 写的屏障：<br><code>mmiowb()</code><br>笔者也不熟悉这个的作用，后续再补上</p>\n<h3 id=\"隐藏的内存屏障\"><a href=\"#隐藏的内存屏障\" class=\"headerlink\" title=\"隐藏的内存屏障\"></a>隐藏的内存屏障</h3><p>Linux 内核中一些锁或者调度函数暗含了内存屏障。</p>\n<p>锁函数：</p>\n<ul>\n<li>spin locks</li>\n<li>R/W spin locks</li>\n<li>mutexes</li>\n<li>semaphores</li>\n<li>R/W semaphores</li>\n</ul>\n<p>中断禁止函数：<br>启动或禁止终端的函数的作用仅仅是作为编译器屏障，所以要使用内存或者 I/O 屏障 的场合，必须用别的函数。</p>\n<p>SLEEP和WAKE-UP以及其它调度函数：<br>使用 SLEEP 和 WAKE-UP 函数时要改变 task 的状态标志，这需要使用合适的内存屏 障保证修改的顺序。</p>\n<h1 id=\"MESI缓存一致性\"><a href=\"#MESI缓存一致性\" class=\"headerlink\" title=\"MESI缓存一致性\"></a>MESI缓存一致性</h1><p>写不动了，缓存一致性的内容还是大家自己百度吧<br>其实简单点可以这么理解：</p>\n<ol>\n<li>JMM中的主存其实在实现上，包含了CPU的缓存</li>\n<li>JMM中的CPU的缓存在x86机器上可以理解为write buffer。</li>\n</ol>\n<h1 id=\"JMM\"><a href=\"#JMM\" class=\"headerlink\" title=\"JMM\"></a>JMM</h1><p>写到这儿，基本把开头的一些结论说清楚了，但是还有一个：<br>JVM定义的4种内存屏障指令，在x86的机器上，其实只有一种有用，其他的都是空指令。</p>\n<p>我们先来看JMM中的定义，根据Store和Load的操作，JMM分成了4中：</p>\n<ol>\n<li>LoadLoad</li>\n<li>LoadStore</li>\n<li>StoreStore</li>\n<li>StoreLoad</li>\n</ol>\n<p>这4中都是为了禁止重排序的<br>这里的Load就是从主存中获取值，Store就是把值同步写入主存。</p>\n<p>按照读屏障，写屏障，读写屏障划分的话，和fence的对应关系如下：</p>\n<ol>\n<li>LoadLoad -&gt; lfence</li>\n<li>LoadStore -&gt; mfence</li>\n<li>StoreStore -&gt; sfence</li>\n<li>StoreLoad -&gt; mfence</li>\n</ol>\n<p>当然了解这些还是不够的，我们还需要JMM对应了哪种CPU模型。<br>在x86中，我们除了内存，还了解到有write buffer的存在。<br>然而事实上，CPU的实现中，还有一个东西的存在叫<code>invalidate queue</code></p>\n<p>具体的演进与作用可以参照这篇文章：<br><a href=\"https://zhuanlan.zhihu.com/p/66085562\" target=\"_blank\" rel=\"noopener\">内存屏障Memory Barrier: a Hardware View</a></p>\n<p>StoreBuffer就是对应WriteBuffer<br>而Invalidate queue在x86的CPU上是不存在的。</p>\n<p>再回到我们提到的例子：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    x=<span class=\"number\">1</span>;  <span class=\"comment\">//S1</span></span><br><span class=\"line\">    r1=y;  <span class=\"comment\">//S2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bar</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    y=<span class=\"number\">1</span>;  <span class=\"comment\">//L1</span></span><br><span class=\"line\">    r2=x;<span class=\"comment\">//L2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在这个例子中，我们需要哪一种屏障呢？<br>就是StoreLoad屏障<br>按照TSO的协议解释，也就是我们读取y的值的之前，必须flush writebuffer。<br>这样，r1和r2就不会出现同时等于0的情况。</p>\n<p>再具体的这个文章讲的很好：<a href=\"https://zhuanlan.zhihu.com/p/81555436\" target=\"_blank\" rel=\"noopener\">为什么在 x86 架构下只有 StoreLoad 屏障是有效指令？</a></p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://mortoray.com/2010/11/18/cpu-reordering-what-is-actually-being-reordered/\" target=\"_blank\" rel=\"noopener\">cpu-reordering-what-is-actually-being-reordered</a><br><a href=\"http://lday.me/2017/11/04/0016_what_is_memory_barriers/\" target=\"_blank\" rel=\"noopener\">什么是内存屏障(Memory Barriers)</a><br><a href=\"https://www.linuxidc.com/Linux/2011-10/44623.htm\" target=\"_blank\" rel=\"noopener\">Linux内核中的内存屏障</a><br><a href=\"https://quant67.com/post/linux/memory-barriers/memory-barriers.html#sec-2-6\" target=\"_blank\" rel=\"noopener\">内存屏障</a><br><a href=\"https://zhuanlan.zhihu.com/p/33626920\" target=\"_blank\" rel=\"noopener\">为什么我们需要内存屏障？</a><br><a href=\"https://blog.csdn.net/muxiqingyang/article/details/6615199\" target=\"_blank\" rel=\"noopener\">《大话处理器》Cache一致性协议之MESI</a><br><a href=\"https://paulcavallaro.com/blog/x86-tso-a-programmers-model-for-x86-multiprocessors/\" target=\"_blank\" rel=\"noopener\">x86 TSO: A Programmer’s Model for x86 Multiprocessors</a><br><a href=\"https://stackoverflow.com/questions/51292687/if-i-dont-use-fences-how-long-could-it-take-a-core-to-see-another-cores-write\" target=\"_blank\" rel=\"noopener\">If I don’t use fences, how long could it take a core to see another core’s writes?</a><br><a href=\"https://blog.csdn.net/automan12138/article/details/104682093\" target=\"_blank\" rel=\"noopener\">深入理解内存屏障</a><br><a href=\"https://www.cnblogs.com/aquester/p/10328479.html\" target=\"_blank\" rel=\"noopener\">C和C++中的volatile、内存屏障和CPU缓存一致性协议MESI</a><br><a href=\"https://mp.weixin.qq.com/s?__biz=MzUzMDk3NjM3Mg==&amp;mid=2247483755&amp;idx=1&amp;sn=50f80e73f46fab04d8a799e8731432c6&amp;chksm=fa48da70cd3f5366d9658277cccd9e36fca540276f580822d41aef7d8af4dda480fc85e3bde4&amp;token=1910810820&amp;lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener\">从 Java 内存模型看内部细节</a><br><a href=\"https://www.zhihu.com/question/296949412/answer/864851230\" target=\"_blank\" rel=\"noopener\">既然CPU有缓存一致性协议（MESI），为什么JMM还需要volatile关键字？</a></p>\n","categories":["计算机基础"],"tags":["内存屏障","volatile"]},{"title":"Kafka指南-分区副本详解","url":"https://blog.lovezhy.cc/2020/03/03/Kafka指南-分区副本/","content":"<p>分区副本是Kafka中重要的概念。<br>下面我们来详细谈一谈副本相关的概念。</p>\n<a id=\"more\"></a>\n<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><p>Kafka中，每个Topic，可能有多个分区，同时为了提高每个分区的可用性，每个分区会有多个冗余备份，这个备份就叫副本（Replica），Kafka集群会将一个分区的不同副本分配在不同的Broker上，这样即使一个Broker系统宕机，也不会影响该分区的可用性。</p>\n<p>这也是分布式系统中常见的高可用实现方式。</p>\n<p>但是Kafka中的关于副本，还有几个比较重要的概念。</p>\n<h2 id=\"Leader副本，Follower副本\"><a href=\"#Leader副本，Follower副本\" class=\"headerlink\" title=\"Leader副本，Follower副本\"></a>Leader副本，Follower副本</h2><p>Leader副本，Follower副本：<br>虽然有多个副本，但是只会有一个Leader副本接收客户端的读写操作，其他的副本都叫Follower副本，Follower副本只做一件事，就是同步Leader副本的日志。</p>\n<h2 id=\"AR（Assigned-Replica）\"><a href=\"#AR（Assigned-Replica）\" class=\"headerlink\" title=\"AR（Assigned Replica）\"></a>AR（Assigned Replica）</h2><p>AR（Assigned Replica）：<br>就是某分区所有副本的统称，包括Leader副本和Follower副本。</p>\n<h2 id=\"优先副本（Preferred-Replica）\"><a href=\"#优先副本（Preferred-Replica）\" class=\"headerlink\" title=\"优先副本（Preferred Replica）\"></a>优先副本（Preferred Replica）</h2><p>优先副本（Preferred Replica)，也叫Preferred Leader：<br>Leader副本也不是随意选出的，前面提到过Leader副本是接收客户端的读写请求的，所有的Leader副本都集中在一个Broker上，那设立多个Broker进行负载均衡的意义就没有了。<br>所有控制器会选出每个分区的优先副本是那个，然后使用一些手段让优先副本变成Leader副本。</p>\n<p>注意：不是每个Partition的优先副本都等于Leader副本，如果中途进行了Leader副本切换，Broker重启等事件，Leader副本就会变化，这种情况，有脚本可以手动操作。</p>\n<h2 id=\"ISR（In-Sync-Replica\"><a href=\"#ISR（In-Sync-Replica\" class=\"headerlink\" title=\"ISR（In-Sync Replica)\"></a>ISR（In-Sync Replica)</h2><p>ISR（In-Sync Replica):<br>前面提到，所有的Follower副本，只做一件事，就是同步Leader副本的日志。<br>但是每个副本的同步进度有快有慢，我们将与Leader副本保持一定同步的Follower副本，包括Leader副本自己，叫In-Sync Replica。</p>\n<p>那么你可能要问了，这个“保持一定同步”的标准是什么？<br>落后日志小于X条？</p>\n<p>猜的没错，确实，在Kafka的0.9版本之前，有个参数叫<code>replica.lag.max.messages</code>，默认值是4000。如果一个Follower副本落后Leader副本4000条消息，那么就会被移出ISR集合。</p>\n<p>你可能会注意到，这个是在0.9版本之前，那么在之后被改掉了，为什么呢？<br>因为这个参数很难设置。<br>如果业务系统的流量一直比较平稳也就算了，但是正常的业务流量难免有波动，高的时候可能QPS就超过了这个参数，很容易就触发，低的时候每秒就1条消息，那得4000s才能发现，那也没啥意义。<br>所以这个参数，很难设置。</p>\n<p>从Kafka的0.9版本开始，Broker端有个参数叫<code>replica.lag.time.max.ms</code>，默认值是10000，Broker会启动一个参数定时的检查每个Follower副本上次和Leader副本日志完全一致的时间（注：并不完全等于上次通信时间），如果距离现在已经过去了10000ms，那么就会把这个Follower副本从ISR集合中移除。</p>\n<h1 id=\"分区Leader\"><a href=\"#分区Leader\" class=\"headerlink\" title=\"分区Leader\"></a>分区Leader</h1><h2 id=\"Leader副本的产生\"><a href=\"#Leader副本的产生\" class=\"headerlink\" title=\"Leader副本的产生\"></a>Leader副本的产生</h2><p>一般来说，当我们创建一个Topic，进行分区的时候，Kafka控制器会决定分区分在哪些Broker上，同时也会决定那个副本是Leader副本，并且把这个信息写入ZK。同时通过Http请求通知其他的Broker。</p>\n<h2 id=\"Leader副本的重新选取\"><a href=\"#Leader副本的重新选取\" class=\"headerlink\" title=\"Leader副本的重新选取\"></a>Leader副本的重新选取</h2><p>我们知道，每个Broker启动的时候，都会在ZK的目录下注册一个临时节点。<br>Kafka控制器对这个目录注册监听事件，当发生Broker断开，或者Broker新增的时候，就会触发一些响应的逻辑。</p>\n<p>返回到我们的Leader副本，什么情况下Leader副本会不可用呢？通常来说就是Leader副本所在的Broker整个挂掉了。<br>Kafka控制器感应到这个事件后，就会重新指定一个副本为Leader副本。<br>到底指定哪一个呢？这里面有大文章。<br>我们慢慢来说。</p>\n<p>在Raft中，重新选举一个Leader的条件就是谁的日志最新，谁就可以当Leader。<br>这样可以避免消息丢失。<br>在Kafka中类似，但是没有Raft中那么严格，Broker会从ISR集合中<strong>随机</strong>选取一个。<br>是的，随机选举一个当Leader。<br>我们知道，ISR集合中的副本，可不一定与Leader副本的日志完全一致的。<br><img src=\"/images/Kafka指南-分区/选举.png\" alt=\"\"><br>如上图所示，Leader副本如果挂掉，Follower1和2都属于ISR集合的话，虽然Follower1的日志比Follower2更新，但是Follower2也可以被选举为Leader。<br>当Follower2被选举为Leader后，Follower1的2003和2004的日志，都要被<strong>删除</strong>。</p>\n<h2 id=\"分区的可用性，AP还是CP\"><a href=\"#分区的可用性，AP还是CP\" class=\"headerlink\" title=\"分区的可用性，AP还是CP\"></a>分区的可用性，AP还是CP</h2><p>分布式系统，有个著名的理论就是CAP理论，这里有个A就是可用性。<br>那么Kafka作为一个分布式的系统，其实也是遵循这个理论的。<br>那么你会问了，Kafka是个AP系统还是个CP系统。</p>\n<p>说到这里，不得不提一个共识性算法，叫Raft，Raft协议其实是为了构建一个CP系统，它的A属性，是保证不能挂掉一半以上的节点。<br>而共识性算法中，有个微软的协议叫PacificA，kafka其实和这个系统相近。</p>\n<p>不兜圈子了，直接明说，Kafka系统到底是AP还是CP其实是可以配置的。<br>在Raft中，一个数据的提交，Leader节点必须要接收到一半以上（包括自己）的节点的成功响应，才能告诉客户端，说你这条消息，提交成功，我们保证，肯定不会丢失了。</p>\n<p>把这个概念移到Kafka中，我们的Producer的发送的数据，Leader副本自己Append后，要同步给多少节点才能响应成功呢？<br>这个是个参数，可以配置。<br><code>acks</code>：指明分区中必须要有多少个副本收到这条消息，Broker才能响应成功。</p>\n<ol>\n<li><code>acks=1</code>。这也是默认值，生产者发送消息后，只要分区的Leader成功写入，就会收到成功的响应。显然，这种是不能保证数据不被丢失的。万一写完，Leader副本就挂了，Follower副本还没来得及同步。</li>\n<li><code>acks=0</code>：这个比等于1还夸张，完全随缘的，不关心服务端。一般不这么设置。</li>\n<li><code>acks=-1,acks=all</code>：这个参数，要保证所有的ISR副本都写入成功，才可以返回成功。结合前面我们提到的ISR的概念，会发现，单独设置这个参数其实没啥用，因为ISR集合中副本的个数你根本不知道。所以这个选项，还需要我们设置出ISR集合中，至少有几个副本：<code>min.insync.replicas</code>。</li>\n</ol>\n<p>如果我们需要我们的Kafka是像Raft一样的CP系统，那么我们需要配置：</p>\n<ol>\n<li><code>acks=all</code></li>\n<li><code>min.insync.replicas=${f/2 + 1}</code></li>\n<li><code>unclean.leader.election.enable=false</code><br>显然这种，性能肯定不咋地，可用性也会大大折扣。</li>\n</ol>\n<p>如果我们需要我们的Kafka系统是AP系统，那么我们需要把</p>\n<ol>\n<li><code>min.insync.replicas=1</code></li>\n<li><code>unclean.leader.election.enable=true</code><br>这样我们可以容忍最多（f-1）个副本失效。<br>但是会丢失数据。</li>\n</ol>\n<p>默认值：当然大部分人肯定没关心过这两个参数，其实从参数的设计来看，Kafka其实偏向于一个AP系统，<code>acks</code>的默认值为1，<code>min.insync.replicas</code>的默认值也是1，<code>unclean.leader.election.enable</code>的默认值是false。<br>这么配置的话，如果ISR集合中，某一时间只有Leader副本，同时恰好宕机了，那么整个分区就不可用了。</p>\n<h1 id=\"ISR更新\"><a href=\"#ISR更新\" class=\"headerlink\" title=\"ISR更新\"></a>ISR更新</h1><p>对于ISR流程的更新，笔者也画了一些示意图，当然其实流程大家心里应该也清楚了。</p>\n<h2 id=\"流程一\"><a href=\"#流程一\" class=\"headerlink\" title=\"流程一\"></a>流程一</h2><p><img src=\"/images/Kafka指南-分区/副本上下线1.png\" alt=\"\"><br>如上图所示，我们有3个Broker。<br>对于Topic=Hello而言，我们假设他有10个Partition，其中每个Partition有3个副本。<br>图中所示的是Partition5的副本分布情况。</p>\n<blockquote>\n<p>Leader副本，也就是Replica-0，在Broker-0节点上。</p>\n<p>这个时候，ISR集合有[0,1,2]。</p>\n</blockquote>\n<p>在Kafka控制器和Zookeeper中都记录了该信息。<br>对于ZK而言，在<code>/state/Hello/5</code>节点中记录了该信息。<br>并且<code>/Isr_notification/</code>节点下，没有子节点。<br>图中没有标明的一点是：KafkaController监听了<code>/Isr_notification/</code>节点。</p>\n<h2 id=\"流程二\"><a href=\"#流程二\" class=\"headerlink\" title=\"流程二\"></a>流程二</h2><p><img src=\"/images/Kafka指南-分区/副本上下线2.png\" alt=\"\"></p>\n<p>渐渐的，副本2同步日志出现了落后，被Leader副本检测到了，下面Leader副本需要更新ISR集合。</p>\n<h2 id=\"流程三\"><a href=\"#流程三\" class=\"headerlink\" title=\"流程三\"></a>流程三</h2><p><img src=\"/images/Kafka指南-分区/副本上下线3.png\" alt=\"\"></p>\n<p>Leader副本所在的Broker0，会连接ZK，做两个操作：</p>\n<ol>\n<li>修改<code>/state/Hello/5/</code>的值，把ISR集合中的2移除</li>\n<li>在<code>/Isr_notification/</code>下新增一个节点，表示Hello的Partition的ISR集合发生了变化</li>\n</ol>\n<h2 id=\"流程四\"><a href=\"#流程四\" class=\"headerlink\" title=\"流程四\"></a>流程四</h2><p><img src=\"/images/Kafka指南-分区/副本上下线4.png\" alt=\"\"><br>ZK会通知Kafka控制器</p>\n<h2 id=\"流程五\"><a href=\"#流程五\" class=\"headerlink\" title=\"流程五\"></a>流程五</h2><p><img src=\"/images/Kafka指南-分区/副本上下线5.png\" alt=\"\"><br>Kafka控制器会做两个操作：</p>\n<ol>\n<li>更新自己的元数据，将副本2从ISR集合中删除</li>\n<li>通知其他所有的Broker，更新其元数据。</li>\n</ol>\n","categories":["Kafka指南"],"tags":["Kafka"]},{"title":"Kafka指南-模块与职能划分","url":"https://blog.lovezhy.cc/2020/02/29/Kafka指南-模块与职能划分/","content":"<p>Kafka的是个复杂的系统，除了基本的Producer，Consumer，Broker外，为了实现完备的功能，Kafka中有许多重要的模块，本文梳理一下这些模块的划分，与他们负责的功能。</p>\n<a id=\"more\"></a>\n<h1 id=\"运行组件\"><a href=\"#运行组件\" class=\"headerlink\" title=\"运行组件\"></a>运行组件</h1><p>基本上来说，正常的一个运行Kafka的业务，都需要4个组件：</p>\n<ol>\n<li>Broker。也就是Kafka服务器。</li>\n<li>Producer。也就是消息的生产者，负责把消息传入Broker。</li>\n<li>Consumer。消息的消费者，负责从Broker拉取消息。</li>\n<li>Zookeeper。Broker的运行需要Zookeeper保存一些元数据。</li>\n</ol>\n<p>这四大组件的关系如下图所示：<br><img src=\"../images/Kafka-模块划分/组件.png\" alt=\"\"></p>\n<p>流程也不用我多介绍了。<br>这里要提的一点就是，<strong>Consumer端不再感知Zookeeper了</strong><br>这个其实是演进出来的，之前的Offset保存的方式导致了Consumer端必须要感知ZK的地址。<br>但是使用了新的Offset提交方式后，Consumer没有必要感知Zookeeper了，所以在新版本的启动参数中仅仅需要使用<code>--bootstrap-server</code>指定任意一个Broker地址就行了。</p>\n<p>当然这个问题我也去搜集了一下答案：<br><a href=\"https://segmentfault.com/q/1010000015795614\" target=\"_blank\" rel=\"noopener\">新版kafka消费者、生产者配置为何使用bootstrap-servers而不是zookeeper服务器地址？</a></p>\n<p>答案中提到了一个Kafka的提案，就是要取代Zookeeper。也是值得看一看的。</p>\n<h1 id=\"控制器\"><a href=\"#控制器\" class=\"headerlink\" title=\"控制器\"></a>控制器</h1><p>控制器，也叫Kafka Controller。<br>我们知道Kafka集群中，会有多个Broker，这些Broker并不是对等的关系，和Raft协议一样，其中一个Broker会被选举为Leader，也就是控制器，KafkaController。</p>\n<p>为什么需要一个Leader呢？这个在我看来其实有两个原因。</p>\n<ol>\n<li>Zookeeper的性能有限。</li>\n<li>避免复杂的逻辑。</li>\n</ol>\n<p>在早期的Kafka版本中，其实没有控制器这个概念，所有的Broker都是对等的，很多复杂的逻辑难以解决，以及对ZK会造成很大的负载，笔者列举几个：</p>\n<ol>\n<li>分区的ISR集合变更。每个分区的ISR集合，属于元数据，需要保存到每个Broker上的。分区的Leader副本所在的Broker会首先感知到该分区的ISR变更，它会把这个事件发布上ZK上，然后其他的Broker会监听到这个事件，更新自己的元数据。</li>\n<li>Leader副本出现问题。当一个分区的Leader副本出现问题时，需要重新选举出新的Leader副本，这个事件也是通过注册ZK的监听器实现的。</li>\n<li>Topic的分区分配，分区迁移，优先副本的选举：这是为了负载均衡的分布在不同的Broker上，如果没有Leader，随机的让这些决策由任意一个Broker去完成，会比较复杂。</li>\n</ol>\n<p>所有加入KafkaController后，这个被选为Leader的Broker需要做很多事：</p>\n<ol>\n<li>注册ZK的监听器，事件触发后，将信息传递给其他的Broker。</li>\n<li>对集群的配置进行决策和任务发放</li>\n</ol>\n<p>再具体一点：</p>\n<ol>\n<li>分区Leader副本出现故障，选举出新的Leader副本</li>\n<li>ISR集合变更，通知给其他的Broker</li>\n<li>Topic的新增，删除，分区分配，分区迁移，副本管理</li>\n<li>监听其他的Broker的变化，新增，删除等。</li>\n</ol>\n<h1 id=\"消费者协调器，组协调器\"><a href=\"#消费者协调器，组协调器\" class=\"headerlink\" title=\"消费者协调器，组协调器\"></a>消费者协调器，组协调器</h1><p>消费者协调器（ConsumerCoordinator），组协调器（GroupCoordinator）是为了解决旧版本的消费者再均衡问题而诞生的。</p>\n<p>首先让我们思考一下消费组需要解决的问题。<br>通常来说，一个Topic会有多个分区，而每个分区，都会指派给一个Consumer会消费。<br><img src=\"../images/Kafka-模块划分/分区分配.png\" alt=\"\"><br>如上图所示，这个Topic共有4个partition，有3个Consumer。<br>Consumer0分配了P0和P1给它，Consumer1和Consumer2分别分配了P2和P3。</p>\n<p>这样很美好，但是美好的事情总是不稳定。<br>如果Consumer0挂了呢？<br>那么我们需要把P0和P1分配给Consumer1和Consumer2。<br>如果多了一个Consumer加入，我们需要把P0分配给它。</p>\n<p>这些就是消费者再均衡问题。<br>怎么解决这个问题呢？<br>旧版的Kafka中同样使用了很多的ZK的监听器去完成，很复杂。<br>问题有2：</p>\n<ol>\n<li>ZK负载较大。</li>\n<li>ZK本身的脑裂问题，会导致各个消费者拿到的消费组的状态不一致，产生问题。</li>\n</ol>\n<p>解决这个问题的关键和Kafka的控制器的思路一致，我们需要引入Leader来完成重分配。<br>于是有了组协调器</p>\n<h2 id=\"组协调器（GroupCoordinator）\"><a href=\"#组协调器（GroupCoordinator）\" class=\"headerlink\" title=\"组协调器（GroupCoordinator）\"></a>组协调器（GroupCoordinator）</h2><blockquote>\n<p>组协调器：Kafka将全部的消费组分成了多个子集，每个消费组的子集在服务端对应一个GroupCoordinator对其进行管理</p>\n</blockquote>\n<p>组协调器是在服务端的，由某一个Broker担任。<br>有了组协调器后，某消费组中的所有消费者定时的向其发送心跳包，这样组协调器就能感知该消费组的消费者的个数变更，从而触发分区重分配。</p>\n<p>好像解决重分配的问题，只要有了组协调器就行了？<br>是的，确实是的。</p>\n<p>那么消费者协调器是干什么用的？<br>别急，等我慢慢道来。</p>\n<h2 id=\"消费者协调器\"><a href=\"#消费者协调器\" class=\"headerlink\" title=\"消费者协调器\"></a>消费者协调器</h2><p>说到这个其实不能不提一个概念，<strong>分区分配规则</strong>。<br>X个分区，Y个消费者，怎么分配分区给消费者呢？<br>当然我们可以轮询着来，但是作为一个完备的框架，这一层分配策略是需要抽象出来的，甚至可以由用户自定义的。</p>\n<p>Kafka提供了消费者参数<code>partition.assignment.strategy</code>来进行配置，可选值如下：</p>\n<ol>\n<li>RangeAssignor：按照消费者总数和分区总数进行整除运算来获得一个跨度，然后将分区按照跨度进行平均分配，也是默认的分配策略。</li>\n<li>RoundRobinAssignor：轮询分配</li>\n<li>StickyAssignor：前面两种分配方式，都没有考虑分区和Consumer的状态，消费情况，以及之前的分配情况，这种分配结合前面两种状态来决定分配方式。</li>\n</ol>\n<p>当然也可以进行自定义分配方式，需要我们在Consumer代码里进行编写。</p>\n<p>所以问题来了，为什么配置是在Consumer端？<br>你可能想到了，<strong>灵活配置！</strong>。</p>\n<p>写到这儿，消费者协调器的存在就可以理解了，真正的分配其实并不是组协调器进行的，而是组协调器会在所有的Consumer中指定一个Leader，这个Leader就叫消费者协调器，真正的分配结果由这个Consumer来执行，消费者协调器把分配结果告诉组协调器，组协调器再通知给所有的消费者结果。</p>\n","categories":["Kafka指南"],"tags":["Kafka"]},{"title":"Kafka指南-源码导入Idea","url":"https://blog.lovezhy.cc/2020/02/23/Kafka指南-源码导入Idea/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>虽然网上教程很多，但是我依然要写系列<br>因为我踩到的坑有的是网上没有遇到过的</p>\n<a id=\"more\"></a>\n<h2 id=\"详细步骤\"><a href=\"#详细步骤\" class=\"headerlink\" title=\"详细步骤\"></a>详细步骤</h2><h3 id=\"克隆源码\"><a href=\"#克隆源码\" class=\"headerlink\" title=\"克隆源码\"></a>克隆源码</h3><p><code>git clone https://github.com/apache/kafka.git</code></p>\n<p><strong>这个时候切记不能先用idea直接打开项目！</strong><br><strong>这个时候切记不能先用idea直接打开项目！</strong><br><strong>这个时候切记不能先用idea直接打开项目！</strong></p>\n<h3 id=\"打包环境\"><a href=\"#打包环境\" class=\"headerlink\" title=\"打包环境\"></a>打包环境</h3><p>kafka自带了一些Gradle的Task，可以生成出导入Eclipse或者Idea配置。<br>在Kafka目录下执行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./gradlew jar</span><br><span class=\"line\">./gradlew idea</span><br></pre></td></tr></table></figure>\n<p>这个时候目录下会出现一个文件叫<code>kafka.ipr</code><br>在finder中双击这个文件，idea会自动打开并导入项目。<br><strong>注：也就是这个时候才会打开Idea</strong></p>\n<h3 id=\"配置Gradle\"><a href=\"#配置Gradle\" class=\"headerlink\" title=\"配置Gradle\"></a>配置Gradle</h3><p>一般Idea打开会，右下角会弹出一个框，大致意思是：</p>\n<blockquote>\n<p>我们检测出这个是Gradle项目，需要导入Gradle的配置吗？</p>\n</blockquote>\n<p>这个时候，点击确认就行。</p>\n<p>如果打开Idea啥也没发生，那么就需要我们自己打开文件<code>build.gradle</code><br>然后进行刷新之类的操作，具体我也忘了怎么操作的。</p>\n<h3 id=\"修改配置\"><a href=\"#修改配置\" class=\"headerlink\" title=\"修改配置\"></a>修改配置</h3><p>一些配置的修改是比较重要的</p>\n<ol>\n<li>文件build.gradle<br>第一处修改：<br>找到<code>tasks.withType(ScalaCompile) {</code>这一行<br>修改<code>scalaCompileOptions.additionalParameters</code>的配置<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    scalaCompileOptions.additionalParameters = [</span><br><span class=\"line\">      <span class=\"string\">\"-nowarn\"</span>,  <span class=\"comment\">//新增</span></span><br><span class=\"line\">      <span class=\"string\">\"-deprecation\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"-unchecked\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"-encoding\"</span>, <span class=\"string\">\"utf8\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"-Xlog-reflective-calls\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"-feature\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"-language:postfixOps\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"-language:implicitConversions\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"-language:existentials\"</span>,</span><br><span class=\"line\"><span class=\"comment\">//      \"-Xlint:constant\",  //注释</span></span><br><span class=\"line\"><span class=\"comment\">//      \"-Xlint:delayedinit-select\",</span></span><br><span class=\"line\"><span class=\"comment\">//      \"-Xlint:doc-detached\",</span></span><br><span class=\"line\"><span class=\"comment\">//      \"-Xlint:missing-interpolator\",</span></span><br><span class=\"line\"><span class=\"comment\">//      \"-Xlint:nullary-override\",</span></span><br><span class=\"line\"><span class=\"comment\">//      \"-Xlint:nullary-unit\",</span></span><br><span class=\"line\"><span class=\"comment\">//      \"-Xlint:option-implicit\",</span></span><br><span class=\"line\"><span class=\"comment\">//      \"-Xlint:package-object-classes\",</span></span><br><span class=\"line\"><span class=\"comment\">//      \"-Xlint:poly-implicit-overload\",</span></span><br><span class=\"line\"><span class=\"comment\">//      \"-Xlint:private-shadow\",</span></span><br><span class=\"line\"><span class=\"comment\">//      \"-Xlint:stars-align\",</span></span><br><span class=\"line\"><span class=\"comment\">//      \"-Xlint:type-parameter-shadow\",</span></span><br><span class=\"line\"><span class=\"comment\">//      \"-Xlint:unused\"</span></span><br><span class=\"line\">    ]</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>第二处修改：<br>还有<code>tasks.withType(JavaCompile) {</code>这一行<br>修改为<br><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  tasks.withType(JavaCompile) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">options</span>.encoding = <span class=\"string\">'UTF-8'</span></span><br><span class=\"line\"><span class=\"comment\">//    options.compilerArgs &lt;&lt; \"-Xlint:all\"</span></span><br><span class=\"line\">    <span class=\"comment\">// temporary exclusions until all the warnings are fixed</span></span><br><span class=\"line\"><span class=\"comment\">//    options.compilerArgs &lt;&lt; \"-Xlint:-rawtypes\"</span></span><br><span class=\"line\"><span class=\"comment\">//    options.compilerArgs &lt;&lt; \"-Xlint:-serial\"</span></span><br><span class=\"line\"><span class=\"comment\">//    options.compilerArgs &lt;&lt; \"-Xlint:-try\"</span></span><br><span class=\"line\"><span class=\"comment\">//    options.compilerArgs &lt;&lt; \"-Werror\"</span></span><br><span class=\"line\">    <span class=\"comment\">// --release is the recommended way to select the target release, but it's only supported in Java 9 so we also</span></span><br><span class=\"line\">    <span class=\"comment\">// set --source and --target via `sourceCompatibility` and `targetCompatibility`. If/when Gradle supports `--release`</span></span><br><span class=\"line\">    <span class=\"comment\">// natively (https://github.com/gradle/gradle/issues/2510), we should switch to that.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (JavaVersion.current().isJava9Compatible())</span><br><span class=\"line\">      <span class=\"keyword\">options</span>.compilerArgs &lt;&lt; <span class=\"string\">\"--release\"</span> &lt;&lt; minJavaVersion</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>上面两个修改主要是为了Idea启动时编译，会把一堆warn当做Error报出来，Gradle不给启动</strong></p>\n<p>第三处修改：<br>找到<code>project(&#39;:core&#39;) {</code>这一行<br>下面会有一堆<br><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">compile</span> <span class=\"keyword\">project</span>(<span class=\"string\">':clients'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">compile</span> libs.jacksonDatabind</span><br><span class=\"line\">  <span class=\"keyword\">compile</span> libs.jacksonModuleScala</span><br><span class=\"line\">~~~</span><br></pre></td></tr></table></figure></p>\n<p>这种配置<br>在<code>compileOnly libs.log4j</code>这一行的下面，加上<br><code>compile libs.slf4jlog4j</code></p>\n<p><strong>这个修改主要是终端启动Kafka的时候日志打印不出来的问题</strong></p>\n<blockquote>\n<p>很多的网上的答案都是让自己把两个依赖加进去，但是我发现其实Kafka配置了两个依赖，但是却没有Compile，所以不需要自己加进去，只要加上这行配置就行</p>\n</blockquote>\n<ol>\n<li>配置log4j文件<br>第一步：把config目录下的log4j.properties文件复制到core/src/main/resources目录下<br>需要创建rescources目录<br>如图所示：<br><img src=\"/images/Kafka源码导入Idea/log4j1.png\" alt=\"\"></li>\n</ol>\n<p><strong>并不是很多网上说的复制到/scala目录下</strong></p>\n<p>第二步：修改log4j.properties文件<br>主要是把很多的<code>${kafka.logs.dir}</code>这种变量去掉，换成自己电脑上的绝对路径</p>\n<h2 id=\"启动配置\"><a href=\"#启动配置\" class=\"headerlink\" title=\"启动配置\"></a>启动配置</h2><p>下面就是启动配置了，这个网上都有，我就直接复制一下</p>\n<p><strong>首先得自己启动一个Zookeeper进程</strong></p>\n<h3 id=\"Broker\"><a href=\"#Broker\" class=\"headerlink\" title=\"Broker\"></a>Broker</h3><p><img src=\"/images/Kafka源码导入Idea/Kafka.png\" alt=\"\"></p>\n<h3 id=\"Consumer\"><a href=\"#Consumer\" class=\"headerlink\" title=\"Consumer\"></a>Consumer</h3><p><strong>Program arguments可根据自己的情况修改</strong><br><img src=\"/images/Kafka源码导入Idea/consumer.png\" alt=\"\"></p>\n<h3 id=\"produer\"><a href=\"#produer\" class=\"headerlink\" title=\"produer\"></a>produer</h3><p><strong>Program arguments可根据自己的情况修改</strong><br><img src=\"/images/Kafka源码导入Idea/producer.png\" alt=\"\"></p>\n","categories":["Kafka指南"],"tags":["Kafka"]},{"title":"Kafka指南-时间轮实现","url":"https://blog.lovezhy.cc/2020/01/11/Kafka指南-时间轮实现/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Kafka延迟任务的实现</p>\n<a id=\"more\"></a>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>延迟任务的实现，一般是利用有序队列，按照执行时间的顺序排列，然后有个线程不断的去取第一个元素，如果到了需要执行的时间，就去执行。</p>\n<p>伪代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Delay</span> </span>&#123;</span><br><span class=\"line\">    Queue&lt;Comparable&gt; taskQueue;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\">func <span class=\"title\">add</span><span class=\"params\">(Comparable task)</span> </span>&#123;</span><br><span class=\"line\">        taskQueue.add(task);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\">func <span class=\"title\">pollAndRun</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                var task = taskQueue.peek();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (task.expireTime &lt;= System.currentTime) &#123;</span><br><span class=\"line\">                    run(taskQueue.poll());</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(task.expireTime - System.currentTime);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意：这里的伪代码不完善，在add方法中，一般来说在某种情况下要interrupt执行pollAndRun的线程。</strong></p>\n<p>目前聚焦的主要问题是Queue是怎么个实现法。<br>在Java中有优先权队列可以进行排序，底层是基于最小堆做的，插入和删除的时间复杂度是O(logn)</p>\n<p>当然正常情况下，这种实现可以了，Java中的标准实现也是这样。</p>\n<p>但是呢，Kafka中有大量的<strong>低延迟</strong>的任务，如果都用最小堆去做，难免性能不太好<br>所以Kafka中实现了时间轮的算法，将插入和删除的时间复杂度降低到了O(1)。</p>\n<p>下面细讲下实现：</p>\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><p>源码路径在：<code>package kafka.utils.timer</code>下。</p>\n<h3 id=\"TimerTask\"><a href=\"#TimerTask\" class=\"headerlink\" title=\"TimerTask\"></a>TimerTask</h3><p>Task是队列中的执行元素</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">trait TimerTask extends Runnable &#123;</span><br><span class=\"line\">    val delayMs: Long </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现了Runnable接口，delayMs是指的需要被执行的时间戳，不是相对时间</p>\n<h3 id=\"TimerTaskList\"><a href=\"#TimerTaskList\" class=\"headerlink\" title=\"TimerTaskList\"></a>TimerTaskList</h3><p>看名字就知道是存储Task的集合类</p>\n<p>但是其实它的定义并没有我开始想的那么简单</p>\n<p>TimerTask在TimerTaskList内部的存储形式是双向链表</p>\n<p>所以TimerTask其实被TimerTaskEntry的类包装了一层，增加了Prev和Next指针。</p>\n<p><img src=\"/images/Kafka时间轮/TimerTaskList.png\"></p>\n<p>但是注意哦，这里虽然TimerTask实现了Comparable接口，但是TimerTaskList内部其实就是个简单的双向列表，并不会根据TimerTask的expireTime进行排序。</p>\n<p>恰恰相反，TimerTaskList也实现了Comparable接口。</p>\n<p>在TimerTaskList内部，有一个变量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span>[<span class=\"keyword\">this</span>] val expiration = <span class=\"keyword\">new</span> AtomicLong(-<span class=\"number\">1L</span>)</span><br></pre></td></tr></table></figure>\n<p>从名字中看出其实是存放的是到期时间，TimerTask有过期时间我们可以理解，那么为什么TimerTaskList也有个过期时间？</p>\n<p>这个过期时间是怎么定的，有什么用？</p>\n<h3 id=\"TimingWheel\"><a href=\"#TimingWheel\" class=\"headerlink\" title=\"TimingWheel\"></a>TimingWheel</h3><p>来了，时间轮最主要的数据结构来了。</p>\n<p><img src=\"/images/Kafka时间轮/TimerWheel.png\"></p>\n<p>首先，看图中，模仿了一个钟表的运行图。<br>每tick一下，就把当前指针指向下一个格子。<br>其中每个格子对应着一个TimerTaskList</p>\n<p>格子在Kafka中叫bucket<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val buckets = Array.tabulate[TimerTaskList](wheelSize) &#123; _ =&gt; <span class=\"keyword\">new</span> TimerTaskList(taskCounter) &#125;</span><br></pre></td></tr></table></figure></p>\n<p>每一格代表的时间叫TickMs，整个表最长的跨度叫Interval。</p>\n<p>如果TickMs=5，Bucket=4，就表示这个时间轮有4个格子，总共能执行20ms内的延迟任务，同时TickMs也就是该时间轮保证的延迟任务的延迟执行的单位。</p>\n<p>什么意思呢？就是说如果一个任务是2ms后执行，一个是4ms后执行，但是整个时间轮的TickMs是5ms，那么这两个任务在时间轮看来其实是没区别，是同时执行。</p>\n<p>所以时间轮的TickMs最小，时间就越精确。</p>\n<p>如果延迟时间超过了该时间轮的Interval怎么办？</p>\n<p>比如执行50ms后才运行的任务，则需要建立跨度更大的时间轮。</p>\n<p>而Kafka中会自动建立跨度更大的时间轮，叫overflowWheel，<strong>更大的时间轮的TickMs是下一层的Interval</strong>。</p>\n<p>看到这里，其实可以解答TimerTaskList中的expiration有什么用了。</p>\n<p>这里的expiration其实就是整个TimerTaskList的过期时间，是TickMs的整数倍</p>\n<p>与在TimerTaskList中每个Task的具体延迟时间关系是</p>\n<p><code>TimerTaskList.expiration &lt;= Task.expiration &lt;= TimerTaskList.expiration + TickMs</code></p>\n<p>在Kafka中，默认的时间轮配置TickMs=1，Bucket=20，也就是20MS内的延迟任务。</p>\n<h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><p>讲完了数据结构，下面需要讲怎么运行了。<br>TimingWheel的运行，交给了Timer来操作。<br>Timer有两个方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//往时间轮中加入任务</span></span><br><span class=\"line\"><span class=\"function\">def <span class=\"title\">add</span><span class=\"params\">(timerTask: TimerTask)</span></span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">//驱动时间轮向前Tick</span></span><br><span class=\"line\"><span class=\"function\">def <span class=\"title\">advanceClock</span><span class=\"params\">(timeoutMs: Long)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"菜鸡的猜想方案\"><a href=\"#菜鸡的猜想方案\" class=\"headerlink\" title=\"菜鸡的猜想方案\"></a>菜鸡的猜想方案</h3><p>让我们暂时脱离源码，猜猜时间轮怎么运行的。</p>\n<p><img src=\"/images/Kafka时间轮/tick.png\" alt=\"\"></p>\n<p>正常来说，我们把任务分到具体的Bucket中，每隔一个TickMs，将当前的指针向下运行一格。</p>\n<p>找到这一格中的TimerTaskList，将里面的任务全部拿出来run一遍。</p>\n<p>伪代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;TimerTaskList&gt; buckets;</span><br><span class=\"line\"><span class=\"keyword\">int</span> nextBucket;</span><br><span class=\"line\"><span class=\"function\">func <span class=\"title\">tick</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  var timerTaskList = buckets.get(nextBucket % buckets.length)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (timerTaskList.expiration &lt;= System.currentTime) &#123;</span><br><span class=\"line\">    timerTaskList.timerTaskEntrys.foreach(entry -&gt; entry.run()));</span><br><span class=\"line\">    timerTaskList.timerTaskEntrys.foreach(TimerTaskList::remove);</span><br><span class=\"line\">    nextBucket++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在add元素的时候，先需要判断当前的时间轮是否能承载延迟时间，如果不能，则建立overflowWheel，加到overflowWheel中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;TimerTaskList&gt; buckets;</span><br><span class=\"line\"><span class=\"function\">func <span class=\"title\">add</span><span class=\"params\">(taskEntry)</span> </span>&#123;</span><br><span class=\"line\">  var targetBucketId = (taskEntry.expiration - System.time) / tickMs + nextBucket;</span><br><span class=\"line\">  var timerTaskList = buckets.get(targetBucketId % buckets.length)</span><br><span class=\"line\">  timerTaskList.add(taskEntry);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看起来非常完美，但是问题来了，这个tick函数，怎么个运行策略呢？</p>\n<p>如果要要跑的非常精确的话，必须要有个线程去单独驱动是肯定的，线程里还得这么跑</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"function\">func <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">    timer.tick()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"function\">func <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">    timer.tick()</span><br><span class=\"line\">    sleep(timer.tickms)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有方案1和方案2两种，第二种肯定是有问题的，如果出现了FullGC的情况，那么整个时间轮就不准了。</p>\n<p>只能选择第一种方案，那么第一种肯定是不行的，这样CPU就是100%了，即使时间轮中没有任何任务，很多时间都是无用功，太浪费CPU了。</p>\n<p>其实这里还有个很严重的问题，我们没有考虑overflowWheel。</p>\n<p>正常情况下，在overflowWheel中的任务，如果已经到了下一层TimingWheel的interval范围内，是需要手动放到下一层的。</p>\n<p>如果是这种实现的话，对于overflowWheel的处理会更加的复杂。</p>\n<h3 id=\"Kafka中的实现\"><a href=\"#Kafka中的实现\" class=\"headerlink\" title=\"Kafka中的实现\"></a>Kafka中的实现</h3><p>菜鸡的猜想方案是不行的，面试都是直接挂的节奏。</p>\n<p>所以这种思路是不成立的，那么我们能不能换个思路呢？</p>\n<p>我们沿用最基本的最小堆来实现延迟任务的思路，建立一个优先权队列</p>\n<p>但是队列中的元素不再是TimerTask了，而是TimerTaskList，相比较最原始的方案，队列中的元素少了一个数量级。</p>\n<p>这样，每次单独的线程进行Tick的时候，选出最早需要执行的TimerTaskList，如果还没到执行时间，就可以进行Sleep，而不是占满CPU。</p>\n<p>所以在TimingWheel中增加一个数据结构</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var queue = <span class=\"keyword\">new</span> PriorityQueue&lt;TimerTaskList&gt;()</span><br></pre></td></tr></table></figure>\n<p>每次进行add时，除了把TaskEntry添加到TimerTaskEntry中，还将TimerTaskList添加到queue中。</p>\n<p>这样线程的驱动函数就是这么写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">func <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">    var timerTaskList = timer.queue.poll();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timerTaskList.expiration &lt; System.time) &#123;</span><br><span class=\"line\">      sleep(System.time - timerTaskList.expiration);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>虽然也使用了插入是O(logn)的最小堆结构，但是堆中元素不再是全量的Task了，而是TaskList，所以时间复杂度其实类似于O(1)了。</p>\n<p>那么对于overflowWheel里面的Task怎么处理呢？</p>\n<p>很简单，和第一层的timingWheel一样，将overFlowWheel中的TimerTaskList也加到queue中</p>\n<p>但是从Queue取出的时候，就不是立即执行了，而是再走一遍add程序</p>\n<p>下面是源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//类似于源代码中nextBuckets的作用，这里是绝对时间，startMs是时间轮的开始的绝对时间，这里计算成tickMs的整数倍</span><br><span class=\"line\">private[this] var currentTime = startMs - (startMs % tickMs)</span><br><span class=\"line\"></span><br><span class=\"line\">//向时间轮中加入任务</span><br><span class=\"line\">def add(timerTaskEntry: TimerTaskEntry): Boolean = &#123;</span><br><span class=\"line\">   val expiration = timerTaskEntry.expirationMs</span><br><span class=\"line\">   if (timerTaskEntry.cancelled) &#123;</span><br><span class=\"line\">     //如果任务已经取消，添加失败，可以直接实行</span><br><span class=\"line\">     false</span><br><span class=\"line\">   &#125; else if (expiration &lt; currentTime + tickMs) &#123;</span><br><span class=\"line\">     //如果已经到执行时间，那么也是可以直接执行</span><br><span class=\"line\">     false</span><br><span class=\"line\">   &#125; else if (expiration &lt; currentTime + interval) &#123;</span><br><span class=\"line\">           //这里其实还挺难理解的，如果我们按照钟表的概念，指针每隔一段时间去转动一下，就很难理解下面的代码</span><br><span class=\"line\">           //这里其实就是每隔tickMs，指针不转，整个表顺时针转tickMs圈</span><br><span class=\"line\">     val virtualId = expiration / tickMs</span><br><span class=\"line\">     val bucket = buckets((virtualId % wheelSize.toLong).toInt)</span><br><span class=\"line\">     bucket.add(timerTaskEntry)</span><br><span class=\"line\"></span><br><span class=\"line\">     if (bucket.setExpiration(virtualId * tickMs)) &#123;</span><br><span class=\"line\">       //如果Bucket的失效时间设置成功，就把这个TimerTaskList加入到queue中</span><br><span class=\"line\">       queue.offer(bucket)</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     true</span><br><span class=\"line\">   &#125; else &#123;</span><br><span class=\"line\">     //放不下，建立overflowWheel，overflowWheel和当前timingWheel公用一个queue</span><br><span class=\"line\">     if (overflowWheel == null) addOverflowWheel()</span><br><span class=\"line\">     overflowWheel.add(timerTaskEntry)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>timingWheel的advanceClock代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def advanceClock(timeMs: Long): Unit = &#123;</span><br><span class=\"line\">  if (timeMs &gt;= currentTime + tickMs) &#123;</span><br><span class=\"line\">    currentTime = timeMs - (timeMs % tickMs)</span><br><span class=\"line\">    if (overflowWheel != null) overflowWheel.advanceClock(currentTime)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>主要就是调整下currentTime，其实currentTime在有了queue之后，就没有其他作用了，主要就是在add方法中拦住即将过期或者已经过期的任务</p>\n<p>下面是伪代码中的run方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def advanceClock(timeoutMs: Long): Boolean = &#123;</span><br><span class=\"line\">   var bucket = delayQueue.poll(timeoutMs, TimeUnit.MILLISECONDS)</span><br><span class=\"line\">   if (bucket != null) &#123;</span><br><span class=\"line\">     writeLock.lock()</span><br><span class=\"line\">     try &#123;</span><br><span class=\"line\">       while (bucket != null) &#123;</span><br><span class=\"line\">         timingWheel.advanceClock(bucket.getExpiration())</span><br><span class=\"line\">         //这里不能把bucket中的任务全部执行，因为可能是overFlowWheel中的TimerTaskList，还没到执行时间，直接再走一遍add程序</span><br><span class=\"line\">         bucket.flush(reinsert)</span><br><span class=\"line\">         bucket = delayQueue.poll()</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     &#125; finally &#123;</span><br><span class=\"line\">       writeLock.unlock()</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     true</span><br><span class=\"line\">   &#125; else &#123;</span><br><span class=\"line\">     false</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>注意一下这里的delayQueue，其中poll方法返回的是过期的任务，并不是集合中第一个元素。</p>\n<p>也就是说，即使queue中元素，但是没有元素要过期，返回的也是null。</p>\n<p>当时作者在哪儿晕了半天。</p>\n","categories":["Kafka指南"],"tags":["kafka","TimeWheel","时间轮"]},{"title":"HotSpot原理指南-分层编译","url":"https://blog.lovezhy.cc/2020/01/04/HotSpot原理指南-分层编译/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>HotSpot的初衷是将运行环境分为Client和Server，并且为他们定制了不同的JIT策略以及不同的JIT编译器（C1和C2）。</p>\n<p>设计出ClientMode的年代，个人PC的性能还比较低，无论是CPU资源还是内存资源都比较稀少且价格较高，所以C1节约资源的快速编译是很有必要的。</p>\n<p>随着时代的发展，个人计算机的配置在慢慢升级，同时价格也在慢慢降低，在这种环境下，ClientMode并不是那么适用了，所以HotSpot也就慢慢放弃了ClientMode，在个人计算机上默认采用Server模式。</p>\n<a id=\"more\"></a>\n<h2 id=\"Oracle的想法\"><a href=\"#Oracle的想法\" class=\"headerlink\" title=\"Oracle的想法\"></a>Oracle的想法</h2><p>所有的场景都默认使用Server模式自然是没有什么问题的，但是Oracle并不甘心（作者脑补的），主要不甘心在两个方面：</p>\n<ul>\n<li>默认使用Server模式，那么相当于放弃了开发了很久的C1编译器</li>\n<li>由于Server模式JIT编译策略问题，会导致应用的Warm-Up时间较长</li>\n</ul>\n<p>那么有没有什么方法可以结合C1和C2呢？</p>\n<p>比如用C1解决Warm-Up时间过长的问题。</p>\n<h2 id=\"分层编译\"><a href=\"#分层编译\" class=\"headerlink\" title=\"分层编译\"></a>分层编译</h2><p>前面提到过，Oracle想用C1解决Server模式中Warm-Up时间过长的问题，于是引入了分层编译的概念。</p>\n<p>如下图所示：</p>\n<p><img src=\"/images/HotSpot原理指南-分层编译/c1c2.png\" alt=\"\"></p>\n<p>解释阶段主要是为了收集运行时Profile，Profile收集的越多，对JIT编译出的代码性能帮助越大。</p>\n<p>先看上半部分图，如果我们采用传统的ServerMode运行，在一段时间X内，只能收集300份Profile，然后将这些Profile丢给C2去进行编译。</p>\n<p>我们可以减少解释模式的运行时间，尽快用C1把字节码编译成机器码，用机器码去收集Profile。这就如下半部分图所示：</p>\n<p>收集了100份Profile后，运行C1编译后的代码，在一段时间内，可以收集到更多的Profile。</p>\n<p>上面是限制了收集Profile的时间是一定的，如果我们反过来，<strong>收集Profile的样本数是一定的</strong>：</p>\n<ul>\n<li>传统的Server模式，可能需要花费更多的时间进行收集到指定次数的样本</li>\n<li>先利用C1进行代码编译，提升方法的运行速度，相对可以花费更少的时间进行收集</li>\n</ul>\n<p>如上的思想就是引入C1解决传统的ServerMode热身时间较少的问题，也就是分层编译：先采用C1进行编译，再采用C2进行编译。</p>\n<p>具体的时间对比如下两张图所示：只使用C2 VS 分层编译</p>\n<p><img src=\"/images/HotSpot原理指南-分层编译/only-c2.png\" alt=\"\"><br><img src=\"/images/HotSpot原理指南-分层编译/tier.png\" alt=\"\"></p>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><p>分层编译在JDK7中就引入了，但是默认是不开启的</p>\n<p>如果运行环境还是JDK7，可以使用<code>-XX:+TieredCompilation</code>开启</p>\n<p>在JDK8中，分层编译就默认开启了，如果要关闭它，可以使用<code>-XX:-TieredCompilation</code>关闭</p>\n<h2 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><p>正常的话，只要理解到上面就够了，分层大概分为两层，先是C1，然后是C2。</p>\n<p>但是事实上，我们如果查看以Tier开头的HotSpot参数的话，会发现其包含的参数很多很多</p>\n<p><img src=\"/images/HotSpot原理指南-分层编译/参数.png\" alt=\"\"></p>\n<p>笔者第一次搜索出来时，实在是吃了一惊。<br>经过研究，其实发现分层编译，并不是分了两层，而是足足分了<strong>4</strong>层。</p>\n<ul>\n<li>第0层：解释阶段</li>\n<li>第1-3层：C1编译<ul>\n<li>第1层：C1编译出的<strong>不收集任何Profile</strong>的机器码</li>\n<li>第2层：C1编译出的<strong>仅仅收集方法调用计数</strong>的机器码</li>\n<li>第3层：C1编译出的<strong>收集全部Profile</strong>的机器码</li>\n</ul>\n</li>\n<li>第4层：C2编译</li>\n</ul>\n<p>可以看到，在C1编译的阶段，还拆分成了三个小的阶段。<br>同时，对于这三个小的阶段，需要理解的是，<strong>运行上并不是递进关系</strong>，也就是说并不是先运行第1层，再运行第2层，再运行第3层。具体怎么运行，其实和很多因素有关。<br>我们先看看有哪些经典的分层流程：</p>\n<p><img src=\"/images/HotSpot原理指南-分层编译/4个阶段.png\" alt=\"\"><br>如上图所示。</p>\n<ul>\n<li>流程1：正常的方法的编译流程，先是解释执行，然后直接跳到第3阶段，也就是C1编译出的收集全部Profile的机器码。然后再跳到第4层，也就是C2编译。深色的框表示是编译的终止阶段。</li>\n<li>流程2：但是，如果第3层的等待队列太长，可能就先提交到第2层进行编译，等待一段时间后，再提交给第3层</li>\n<li>流程3：如果该方法比较简单，是个Trivial方法，比如Getter方法，这种方法去收集Profile其实没有什么Profile，给C2去进行编译纯属于浪费资源，所以提交给第3层后，直接给第1层，然后终止。</li>\n<li>流程4：同样也是Trivial方法，如果在解释阶段就发现其比较简单，也可以直接提交给第1层编译</li>\n</ul>\n<p>以上是一些经典的流程，还有一些流程，比如从解释阶段可以直接提交给C2等。</p>\n<p>所以，虽说是分层编译，但是具体的编译流程是不确定的，这个各个编译器的状态以及方法的属性有关。</p>\n<h2 id=\"C1和C2编译线程数\"><a href=\"#C1和C2编译线程数\" class=\"headerlink\" title=\"C1和C2编译线程数\"></a>C1和C2编译线程数</h2><p>各个编译的状态，最简单的就是负责编译的线程数<br>HotSpot分配给C1和C2编译器的线程数，和<strong>指定的启动参数</strong>以及<strong>机器的核心数</strong>有关。</p>\n<p>启动参数：影响线程数的参数有CICompilerCount和CICompilerCountPerCPU两个，默认值如下，一般不会去改这些<br><img src=\"/images/HotSpot原理指南-分层编译/启动参数.png\" alt=\"\"></p>\n<p>有了参数之后，具体的分配代码如下：<br><img src=\"/images/HotSpot原理指南-分层编译/启动参数2.png\" alt=\"\"></p>\n<p>简单聊聊分配策略：</p>\n<ul>\n<li>C1+C2的总的线程数：log2(log2(CoreNum)) * 3 / 2</li>\n<li>C1 / C2 = 1 / 2</li>\n<li>C1和C2至少有一个线程</li>\n</ul>\n<p>下面表格简单显示了一些常见情况</p>\n<table>\n<thead>\n<tr>\n<th>CPU Core</th>\n<th>C1</th>\n<th>C2</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>4</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>8</td>\n<td>1</td>\n<td>3</td>\n</tr>\n<tr>\n<td>16</td>\n<td>4</td>\n<td>8</td>\n</tr>\n<tr>\n<td>32</td>\n<td>5</td>\n<td>10</td>\n</tr>\n<tr>\n<td>64</td>\n<td>6</td>\n<td>12</td>\n</tr>\n</tbody>\n</table>\n","categories":["HotSpot"],"tags":["Java","HotSpot","JIT","JVM"]},{"title":"HotSpot原理指南-JIT触发条件","url":"https://blog.lovezhy.cc/2019/12/14/HotSpot原理指南-JIT触发条件/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>通过前面我们知道，对于每个方法，HotSpot都维护两个计数器</p>\n<ul>\n<li>Invocation Counter：方法被调用次数，每被调用一次都会+1</li>\n<li>BackEdge Counter：专业的说法就是字节码在执行时的回跳次数。通俗点说就是，在For或者While循环中，每执行一次，都会+1。</li>\n</ul>\n<p>并且我们知道对于一个方法，JIT有两种不同的编译方式</p>\n<ul>\n<li>完整的原方法编译，就是把原本的方法逻辑进行编译。入参和运行结果和解释运行都是一致的。</li>\n<li>OSR编译，OSR后的方法入参以及运行流程和原方法有较大差异。</li>\n</ul>\n<p>很自然得我们就会想到，其实计数器和编译方式之间是有对应关系的。</p>\n<ul>\n<li>Invocation Counter -&gt; 完整的原方法编译</li>\n<li>BackEdge Counter  -&gt; OSR编译</li>\n</ul>\n<p>当对应的方法计数器达到一定的次数，就会触发响应的编译</p>\n<a id=\"more\"></a>\n<h2 id=\"编译流程图\"><a href=\"#编译流程图\" class=\"headerlink\" title=\"编译流程图\"></a>编译流程图</h2><p>完整的编译流程如下：</p>\n<p><img src=\"/images/HotSpot原理指南-JIT触发条件/编译流程.png\" alt=\"\"></p>\n<p><strong>注：该图引自R大的JVM分享PPT，如有侵权，请联系我删除</strong></p>\n<p>图中的流程非常的清晰，这里提几个小点：</p>\n<ul>\n<li><p>问：对于同一方法，是否两种编译方式都可能会执行？</p>\n<p>答：是的，而且两种代码可能同时被运行，但是正常情况下，只要运行的够久，都会运行完整的原方法编译后的代码。</p>\n</li>\n<li><p>问：具体哪种编译方式先触发？</p>\n<p>答：其实无法确定，看哪个计数器先达到阈值</p>\n</li>\n</ul>\n<h2 id=\"触发阈值\"><a href=\"#触发阈值\" class=\"headerlink\" title=\"触发阈值\"></a>触发阈值</h2><p>可能你还想更直观的了解下两个计数器的触发阈值到底是多少。</p>\n<p>在HotSpot源码中，有这样两个参数：</p>\n<ul>\n<li><blockquote>\n<p>intx CompileThreshold = 10000</p>\n<p>globals.hpp &gt; ”number of interpreted method invocations before (re-)compiling” </p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>intx BackEdgeThreshold = 100000</p>\n<p>globals.hpp &gt; “Interpreter Back edge threshold at which an OSR compilation is invoked”</p>\n</blockquote>\n</li>\n</ul>\n<p>数值可能根据不同的发行版本略有不同，上面的数值是JDK7版本中的。</p>\n<p>那么你可能以为</p>\n<ul>\n<li>当Invocation Counter &gt; Compile Threshold时，就会触发原来方法的JIT</li>\n<li>当BackEdge Counter &gt; BackEdge Threshold时，就会触发方法的OSR编译</li>\n</ul>\n<p>但是事实并不是如此。</p>\n<p>问题出在哪儿呢？难道官方的定义还会有错吗？</p>\n<p>是的，问题出在BackEdgeThreshold上，虽然HotSpot中确实定义了该参数，描述中似乎也证实了该参数的作用，但是这个参数并没有实际使用过。</p>\n<p>对于BackEdgeThreshold的计算，是另外一套公示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (ProfileInterpreter) &#123;</span><br><span class=\"line\">  InterpreterBackwardBranchLimit = </span><br><span class=\"line\">                 (CompileThreshold * (OnStackReplacePercentage - InterpreterProfilePercentage)) / <span class=\"number\">100</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  InterpreterBackwardBranchLimit = </span><br><span class=\"line\">                ((CompileThreshold * OnStackReplacePercentage) / <span class=\"number\">100</span>) &lt;&lt; number_of_noncount_bits;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先解释下<code>ProfileInterpreter</code>参数，这个参数也是在HotSpot中定义的，之前在文章<code>HotSpot原理指南-C1和C2介绍</code>中也讲解过，就是是否在运行时收集方法的Profile信息，这个字段在Server模式默认是开启的。</p>\n<p>所以大部分情况下，除非你的计算机比较老，都会根据第一个公示进行计算</p>\n<p><code>(CompileThreshold * (OnStackReplacePercentage - InterpreterProfilePercentage)) / 100</code></p>\n<p>其中<strong>OnStackReplacePercentage</strong>默认值是140，<strong>InterpreterProfilePercentage</strong>默认值是33。</p>\n<p>由此我们可以计算出真实的BackEdge Invocation阈值大概是10700左右。</p>\n<h2 id=\"衰减\"><a href=\"#衰减\" class=\"headerlink\" title=\"衰减\"></a>衰减</h2><p>假如方法计数器不会根据时间进行衰减的话，那么只要服务器运行的时间足够长，再罕见被调用的函数，也会触发到阈值，然后被JIT编译。</p>\n<p>这显然是不合理的，因为我们知道JIT后的机器码数据，还是会保存在内存中的，这样相当于一段逻辑在内存中又保存了字节码，又保存了一份机器码，十分的浪费内存。</p>\n<p>所以对于Invocation Counter而言，经过一段时间，个数就会进行减少。</p>\n<p>具体的减少逻辑，读者有兴趣的可以自己去探索。</p>\n<p>但是注意：对于BackEdge Counter，是不会作衰减的。</p>\n","categories":["HotSpot"],"tags":["Java","HotSpot","JIT"]},{"title":"HotSpot原理指南-OSR是什么","url":"https://blog.lovezhy.cc/2019/11/30/HotSpot原理指南-OSR是什么/","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>前面我们讲解了C1和C2的基本知识，但是我们还未触及一个核心的策略，就是<strong>什么时候触发即使编译</strong>，也就是<strong>when</strong>的问题。</p>\n<p>对于when的问题，相信大家多多少少都大概知道，每个方法都会有一个调用次数的计数器，当这个计数器的次数到达一定的次数时，就会被认为是热点方法，继而触发JIT编译。</p>\n<p>但是本文要科普另外一种触发条件，和方法计数器类似。</p>\n<a id=\"more\"></a>\n<h2 id=\"方法计数器的问题\"><a href=\"#方法计数器的问题\" class=\"headerlink\" title=\"方法计数器的问题\"></a>方法计数器的问题</h2><p>大部分人看来，维护一个方法被调用次数计数器当然是一个很完美的方案</p>\n<p>但是有一类方法，即使在我们认知范围内，属于热点方法，但是却无法享受到这个计数器的好处。</p>\n<p>如下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OSRExample</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">200000</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//do a lot of things</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(sum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在Main函数中，有一个循环，在循环中并没有调用某个方法，而是一直在线性执行一些逻辑。</p>\n<p>假如我们把循环中的逻辑看做一个函数，这个函数肯定是热点函数，需要进行JIT编译的，但是在这种场景下，并不是一个函数，也就是无法进行JIT。</p>\n<p>如果JIT无法处理这种情况，将是非常可惜的。</p>\n<h2 id=\"Hot-Loop优化\"><a href=\"#Hot-Loop优化\" class=\"headerlink\" title=\"Hot Loop优化\"></a>Hot Loop优化</h2><p>但是如果我们构造一个上面的代码的情况，并且使用计数器给每次循环的执行时间进行计时。</p>\n<p>会发现下面这张时间和次数的图</p>\n<p><img src=\"/images/HotSpot原理指南-OSR是什么/hotLoop耗时.png\" alt=\"\"></p>\n<p>从图中我们可以看出，大概在150次的时候，整个Loop的耗时突发的大大降低。</p>\n<p>说明在HotSpot的JIT中，是可以处理这种情况的。</p>\n<p>那么HotSpot究竟是怎么做的呢？</p>\n<p>前面我们提到过，如果在Loop中调用的是方法，将不会存在上述的问题，但是实际的情况并不是调用的方法。</p>\n<p>那么，我们能不能，把它包装成一个函数呢？</p>\n<p>举个例子，原方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OSRExample</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20000</span>; i++) &#123;</span><br><span class=\"line\">            sum += i;</span><br><span class=\"line\">          \tsum *= sum;</span><br><span class=\"line\">          \tsum |= sum;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(sum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们把它改成如下的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OSRExample</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20000</span>; i++) &#123;</span><br><span class=\"line\">\t\t\t\t\tsum = doLoop(sum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(sum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  \t</span><br><span class=\"line\">  \t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">doLoop</span><span class=\"params\">(<span class=\"keyword\">int</span> sum)</span> </span>&#123;</span><br><span class=\"line\">      \tsum += i;</span><br><span class=\"line\">      \tsum *= sum;</span><br><span class=\"line\">      \tsum |= sum;</span><br><span class=\"line\">      \t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样可以不可以呢？</p>\n<p>当然是可以的。</p>\n<p>但是！这是作者的猜测，HotSpot真实的情况并不是这样。</p>\n<p>事实上，这种割裂整个main方法，动态把一部分代码进行修改的操作似乎消耗太大了，性价比并不高。</p>\n<p>HotSpot并不会把Loop的内容动态生成一个函数，然后对该函数进行JIT。</p>\n<p>而是对包含这个Loop的<strong>整个方法进行了JIT</strong>。</p>\n<p>什么？对整个方法进行JIT？</p>\n<p>要知道，这个方法在运行中啊，可能再也不会运行第二次，对整个方法进行JIT有什么意义呢？</p>\n<p>稍安勿躁，虽然对整个方法进行了JIT，但是JIT后的代码和原来的函数其实还是有区别的。</p>\n<p>如果我们需要将运行到一半的函数，从一个源代码替换到另外一个源代码，遇到的问题是什么呢？</p>\n<p>首先，这个方法的循环执行到一半，这个i的具体数值肯定不是0了，是一个不可预测的值。</p>\n<p>同时这个sum的值，肯定也是一个不好预测的值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20000</span>; i++) &#123;</span><br><span class=\"line\">\t\tsum = doLoop(sum);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果要进行替换，需要把替换时的i和sum的值记录下来，那么替换后的源代码大概就长这样</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main#jit(int i, int sum) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (; i &lt; <span class=\"number\">20000</span>; i++) &#123;</span><br><span class=\"line\">        sum += i;</span><br><span class=\"line\">      \tsum *= sum;</span><br><span class=\"line\">      \tsum |= sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(sum);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>没错！把运行中动态的值作为参数传给JIT后的函数，就是HotSpot的JIT对于这种HotLoop的优化。</p>\n<h2 id=\"OSR\"><a href=\"#OSR\" class=\"headerlink\" title=\"OSR\"></a>OSR</h2><p>OSR的全称是On-Stack-Replacement。也就是栈上替换。</p>\n<p>从上一节我们了解的可以知道，对于main函数，JIT进行编译的时候，直接把运行中的main函数源代码进行了替换，替换成了修改后的main函数。那么之前的main函数栈帧其实就完全失效了，被替换成了新的函数的栈帧。</p>\n<p>这种JIT编译的方式就叫OSR编译。</p>\n<p>这种栈上替换的方式其实并不是HotSpot独有的，很多其他的语言中也有这样的优化，如V8。</p>\n<h2 id=\"后续问题\"><a href=\"#后续问题\" class=\"headerlink\" title=\"后续问题\"></a>后续问题</h2><p>OSR能够解决HotLoop的优化问题，但是其实在HotSpot中还是有几个值得深究的点。</p>\n<ol>\n<li><p>如果这个main函数方法非常大，Loop只是很小的一部分，那么把整个函数进行JIT编译的性价比就值得商榷了。核心问题其实是，为什么必须要编译整个方法呢？</p>\n<p>这个问题R大也给了我们解释，详细看文章</p>\n<p><a href=\"https://github.com/AdoptOpenJDK/jitwatch/wiki/Understanding-the-On-Stack-Replacement-(OSR)-optimisation-in-the-HotSpot-C1-compiler\" target=\"_blank\" rel=\"noopener\">https://github.com/AdoptOpenJDK/jitwatch/wiki/Understanding-the-On-Stack-Replacement-(OSR)-optimisation-in-the-HotSpot-C1-compiler</a></p>\n</li>\n<li><p>OSR其实并不是完美的解决方案，在某些场景下它会生成非常丑陋的代码，如果有多个Loop或者Loop进行嵌套的方法。</p>\n<p>HotSpot在一篇文章中进行了解释，有兴趣可以看文章</p>\n<p><a href=\"https://www.h2o.ai/blog/what-the-heck-is-osr-and-why-is-it-bad-or-good/\" target=\"_blank\" rel=\"noopener\">What ths heck is osr and why is it bad or good?</a></p>\n</li>\n</ol>\n","categories":["HotSpot"],"tags":["Java"]},{"title":"银行报考指北","url":"https://blog.lovezhy.cc/2019/11/30/银行报考指北/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>看到标题，你可能会疑问，为什么我会去报考银行，我不是在互联网公司上班吗？难道是想逃离互联网回家养老去了？</p>\n<a id=\"more\"></a>\n<p>当然，这个是个多因一果的事情。我确实报考了银行，并且顺利拿到了Offer。但是我并不是想逃离互联网，而是一次尝试，很大程度上只是去看看，顺便敷衍一下我妈。</p>\n<p>当我说到敷衍我妈时，其实我比较伤心的，因为我妈一直觉得做技术太苦了，天天加班，不仅压力大，而且到了35岁会面临辞退的危险，所以希望我回家安安稳稳的过日子。</p>\n<p>讲道理，我也有这种疑虑，但是目前并没有回家养老的意思，所以还是会继续留在南京上班。</p>\n<p>扯了一堆，这次报考流程也算是踩了一次坑，这里记录下来，留给后人参考。</p>\n<h2 id=\"报名\"><a href=\"#报名\" class=\"headerlink\" title=\"报名\"></a>报名</h2><p>一般我不会关注银行的招聘的，但是消息是我妈发给我的</p>\n<p><a href=\"http://www.yinhangzhaopin.com/yzrcb/2019/0929/85386.html\" target=\"_blank\" rel=\"noopener\">http://www.yinhangzhaopin.com/yzrcb/2019/0929/85386.html</a></p>\n<p>后来我才发现原来有个网站专门就是收集各种银行招聘的信息。</p>\n<p>报名在51Job上报名，上去填写一些资料就行了。</p>\n<p>然后它会审核你的资料，算是一个初审，初审过了之后，会再发一封邮件给你告诉你初审过了，可以去缴费了。</p>\n<p><img src=\"/images/银行报考指北/资料审核通过.png\" alt=\"\"></p>\n<p>但是这个缴费网站，要到一定时间才会开通。</p>\n<p>等到开通之后，登录到这个网站，付报名费，大概100块左右，然后选择考场。</p>\n<p>这个考场并不是你报哪儿就必须去哪儿考试的。</p>\n<p>比如我在南京，但是我报的是扬州的农商行，并不是一定要去扬州考试。他在每个城市都会有考点的。</p>\n<p>在南京有4个考点，我记得有林业大学考点，金陵科技学院考点，还有两个记不得了。</p>\n<p>我报的是金陵科技学院的考点。</p>\n<p>好消息就是它考试是在周末考，这样如果是上学或者是上班的话，就不用请假了。</p>\n<p>交完费之后，它还会给你一封邮件，让你准备笔试。</p>\n<p><img src=\"/images/银行报考指北/笔试通知.png\" alt=\"\"></p>\n<h2 id=\"考试\"><a href=\"#考试\" class=\"headerlink\" title=\"考试\"></a>考试</h2><p>周末那一天考试是从9：00到11：30。时间还是挺长的。</p>\n<p>准考证需要提前打印好，然后考试带自己身份证就行了。也可以带一支笔，因为题目可能有数学题。</p>\n<p>写到这个章节，你可能最想知道的是考试考什么题目。</p>\n<p>题目其实是分岗位的，通用岗的我不是很清楚，我报的是科技岗，而且可能各个银行之间又不太一样。</p>\n<p>首先题量很大。题型主要分为：</p>\n<ul>\n<li>找病句</li>\n<li>句子排序</li>\n<li>数学题。比如一排数字，让你找规律那种，那种题基本看一会儿看不出来就过吧</li>\n<li>图形题。和公务员那种差不多，给三个奇怪的组合图形，然后让你选下一个和他们属性一致的图形是什么，这个看一会儿看不出来也过吧</li>\n<li><p>材料题。给一些数据的图标，然后给4个选择题，让你从图标中找答案。还挺难找的。题量少。</p>\n</li>\n<li><p>英语题，缺词填空那种。大概有20道</p>\n</li>\n<li>计算机专业的题目。设计网络，操作系统，Java等。大概有80题。</li>\n<li>考验智商的。比如给你个矩阵，会随机出现几个图形，5秒后消失，然后让你点击刚才出现的图形的位置。</li>\n</ul>\n<p>总而言之，有几点值得关注</p>\n<ul>\n<li>题量大。如果每道题都细做肯定来不及的，有点数学题不会就直接瞎选的。</li>\n<li>不需要专业知识。我考之前有人和我说要很多经济学知识的，其实发现并不需要。</li>\n</ul>\n<p>我当时高估了自己，再加上其实去的意愿不高，做了一个半小时就赶紧溜了去上班了。</p>\n<p>大概百分之60的题目，我都是瞎选的。</p>\n<h2 id=\"面试\"><a href=\"#面试\" class=\"headerlink\" title=\"面试\"></a>面试</h2><p>其实我笔试考完觉得自己肯定挂了，但是过了两天打电话告诉我过了。</p>\n<p>过了就过了吧，大概就是通知我去面试了。</p>\n<p>让我周六去扬州交材料，周日面试。</p>\n<p>我正好有朋友在扬州，所以就打算去顺便找他玩一下。</p>\n<p>交材料的话，需要毕业证的复印件。身份证的正反面复印件，学信网的电子备案表的打印件。</p>\n<p>周六去交了材料，顺便问了我的成绩。</p>\n<p>傍晚的时候发短信通知我明天中午去面试。</p>\n<p>我中午到的时候，发现大家都是穿正装来的，就我穿的花里胡哨的。心想大概率是凉了。</p>\n<p>哈哈，所以这里提醒大家最好穿正装去面试，没有正装也穿个黑色的衣服去。</p>\n<p>然后就是签到。</p>\n<p>到了时间又让我们做了一个半小时的题目，题目大概和笔试的差不多，不知道这个是什么套路。</p>\n<p>这个题目并不包括计算机的题目，我估计通用的和科技岗的都一样。</p>\n<p>做完题目，需要把手机交上去，然后排队去面试。</p>\n<p>流程是这样的，一个一个进去面试，当一个人进去时，后面一个人去等候区，等候区就一个人，有张桌子，上面有张纸，记着三个题目，有人给你计时4分钟，你看完题目想想怎么回答。</p>\n<p>然后前一个出来时，你进去，然后对面三个面试官，面试官不会多对你说什么，你就把三个问题的答案说一遍就行。每个题目计时2分钟，说完也没有其他的问题，你就可以直接走了。</p>\n<p>具体的题目其实和计算机的关系不大，属于需要总结概括的题目，需要的话可能私聊我。</p>\n<p>面完就直接回去了，也没管什么。</p>\n<h2 id=\"体检\"><a href=\"#体检\" class=\"headerlink\" title=\"体检\"></a>体检</h2><p>其实我面完之后感觉自己肯定差不多挂了，下面应该没后续流程了。</p>\n<p>然后过了两天，大概是周二的时候，银行打电话告诉我过了面试。</p>\n<p>下面的流程是体检，而且就在明天，银行的人问我能不能去。</p>\n<p>我一想这也太突然了，我今天就得再去扬州，这也不太可能啊，所以我直接拒绝了。</p>\n<p>以为这个机会就没了，但是她告诉我明天不去，那就等下一批的通知吧。</p>\n<p>感情原来体检还是分批来的，我说好的。</p>\n<p>其实我比较奇怪的地方是为什么直接去体检了，而不是先谈工资待遇啥的，这是明摆着面试通过了大家就肯定先去吗？</p>\n<p>然后我问了在银行工作的同学，似乎他们都是这样的，都不知道具体的待遇什么的，都是上了一个月的班才知道具体的工资是多少。</p>\n<p>这就有点坑了。</p>\n<p>我回去也和我爸妈商量了下，我说我其实不太想回去。我爸妈也表示明白。</p>\n<p>然后下一次打电话来的时候，我就直接拒绝了。</p>\n<p>我以为银行的人会问问为什么，结果她直接说好的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这次的银行面试经历就是如上了，我顺利的度过了笔试和面试，中间决定不去了。</p>\n<p>整体上的体验一般般，流程拉的太长了，而且面试和体检都是在固定的地方，所以导致体验不会太好。</p>\n","categories":["我的生活"],"tags":["生活"]},{"title":"HotSpot原理指南-内联","url":"https://blog.lovezhy.cc/2019/11/28/HotSpot原理指南-内联/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>内联是编程语言编译器中常规的优化操作，几乎所有的语言在编译时或者在执行时都会有内联操作。</p>\n<p>内联的本质是把几个方法合并成一个方法</p>\n<p>从一方面讲，内联减少了函数调用的栈帧创建和销毁的时间消耗</p>\n<p>从另一方面讲，内联为很多其他的优化方法提供了更多的可能，比如逃逸分析，无用代码消除，虚函数优化等，这也是内联被叫做<strong>优化之母</strong>（The Mother Of All Optimization）的原因。</p>\n<a id=\"more\"></a>\n<h2 id=\"HotSpot-JIT\"><a href=\"#HotSpot-JIT\" class=\"headerlink\" title=\"HotSpot-JIT\"></a>HotSpot-JIT</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>对于HotSpot的JIT而言，内联是一个渐进的过程，这个渐进表现在两方面</p>\n<ul>\n<li>C1和C2两个JIT编译器的内联策略不同，C2可能更加激进一些</li>\n<li>内联策略和很多因素有关<ul>\n<li>内联发起函数大小，被内联函数大小</li>\n<li>被内联函数的调用次数</li>\n<li>内联深度</li>\n<li>中间表示的NodeCount</li>\n<li>函数方法签名</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"初步体验\"><a href=\"#初步体验\" class=\"headerlink\" title=\"初步体验\"></a>初步体验</h3><p>先看一段代码，初步的了解下HotSpot的内联，以下代码的执行参数<code>-XX:CompileCommand=exclude,Inline.main</code></p>\n<p>这个参数的意义是禁止<code>main</code>函数内联<code>inline</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inline</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">static</span> Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">1000000</span>; i++) &#123;</span><br><span class=\"line\">            inline();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">inline</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> add(random.nextInt(), </span><br><span class=\"line\">               random.nextInt());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/HotSpot原理指南-内联/inline.png\" alt=\"inline\"></p>\n<p>上图中展示了经过C2编译后，整个<code>inline</code>函数的内联状态</p>\n<p>可以看到不仅仅内联了<code>random.nextInt()</code>方法，还将<code>nextInt</code>方法中的<code>next</code>方法等等好几个再下层的方法也内联了进来</p>\n<h3 id=\"HotSpot参数\"><a href=\"#HotSpot参数\" class=\"headerlink\" title=\"HotSpot参数\"></a>HotSpot参数</h3><p><code>java -XX:+PrintFlagsFinal | grep &quot;Inlin&quot;</code></p>\n<p><img src=\"/images/HotSpot原理指南-内联/内联参数.png\" alt=\"内联参数\"></p>\n<p>可以看到HotSpot可以控制内联的参数很多很多，从侧面也表示HotSpot的内联策略是非常复杂的。</p>\n<p>笔者也无法精通所有的内联策略，所以只挑选出比较重要的几个参数来讲解。</p>\n<p>主要讲解如下几个参数</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>MaxTrivialSize</td>\n<td>6</td>\n</tr>\n<tr>\n<td>MaxInlineSize</td>\n<td>35</td>\n</tr>\n<tr>\n<td>FreqInlineSize</td>\n<td>350</td>\n</tr>\n<tr>\n<td>MinInliningThreshold</td>\n<td>250</td>\n</tr>\n<tr>\n<td>InlineSmallCode</td>\n<td>1000(No-Tier)  2000(Tier)</td>\n</tr>\n<tr>\n<td>MaxInlineLevel</td>\n<td>9</td>\n</tr>\n<tr>\n<td>MaxRecursiveInlineLevel</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"内联策略\"><a href=\"#内联策略\" class=\"headerlink\" title=\"内联策略\"></a>内联策略</h2><h3 id=\"MaxTrivialSize\"><a href=\"#MaxTrivialSize\" class=\"headerlink\" title=\"MaxTrivialSize\"></a>MaxTrivialSize</h3><p>对于Trivial方法，在HotSpot中有着严格的定义</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> SimpleThresholdPolicy::is_trivial(Method* method) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (method-&gt;is_accessor() ||</span><br><span class=\"line\">      method-&gt;is_constant_getter()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (method-&gt;has_loops() || method-&gt;code_size() &gt;= <span class=\"number\">15</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  MethodData* mdo = method-&gt;method_data();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mdo != <span class=\"literal\">NULL</span> &amp;&amp; !mdo-&gt;would_profile() &amp;&amp;</span><br><span class=\"line\">      (method-&gt;code_size() &lt; <span class=\"number\">5</span>  || (mdo-&gt;num_blocks() &lt; <span class=\"number\">4</span>))) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的代码可以看出，常见的Getter方法，肯定是trivial方法</p>\n<p>而函数中有循环，或者函数大小超过15bytes，则不是trivial方法</p>\n<p>对于trivial方法，如果它的函数字节码小于<strong>MaxTrivialSize</strong>，那么即使它在调用方至今一次也没有被执行过，HotSpot也会将它内联进来。</p>\n<p>这是对于C1而言，对于C2而言，则不会进行内联，而是会生成<code>UnCommon Trap</code></p>\n<h3 id=\"MaxInlineSize\"><a href=\"#MaxInlineSize\" class=\"headerlink\" title=\"MaxInlineSize\"></a>MaxInlineSize</h3><p>我们了解了MaxTrivialSize，那么对于MaxInlineSize则很容易理解。</p>\n<p>对于调用方至少执行过一次的方法，如果它的大小小于MaxInlineSize，那么就会考虑将它内联进去</p>\n<h3 id=\"FreqInlineSize和MinInliningThreshold\"><a href=\"#FreqInlineSize和MinInliningThreshold\" class=\"headerlink\" title=\"FreqInlineSize和MinInliningThreshold\"></a>FreqInlineSize和MinInliningThreshold</h3><p>了解了以上两个参数后，你可能会问，如果被调用的函数既不符合Trivial方法，大小也大于MaxInlineSize，但是这个方法非常的Hot，就没有机会被内联了吗</p>\n<p>并不是，FreqInlineSize和MinInliningThreshold这两个参数就是为这种方法设置的。</p>\n<p>当一个方法既不是Trivial方法，而且大于MaxInlineSize，如果他的调用次数大于MinInliningThreshold，也就是250次，且它的大小小于FreqInlineSize，那么它也会被内联</p>\n<h3 id=\"InlineSmallCode\"><a href=\"#InlineSmallCode\" class=\"headerlink\" title=\"InlineSmallCode\"></a>InlineSmallCode</h3><p>我们知道，调用方进行方法内联的时候，函数本身的大小会越来越大。</p>\n<p>这时候你又会问了，那调用方内联可以无限内联吗，内联后的大小肯定会有限制的吧。</p>\n<p>对的！InlineSmallCode就是限制的大小</p>\n<p>如果是非分层编译的环境，阈值是1000bytes</p>\n<p>如果是分层编译的环境，那么阈值是2000bytes</p>\n<h3 id=\"MaxInlineLevel\"><a href=\"#MaxInlineLevel\" class=\"headerlink\" title=\"MaxInlineLevel\"></a>MaxInlineLevel</h3><p>对于一个函数进行其他函数的内联，除了内联后的大小限制，内联的深度也是有限制的。</p>\n<p>在HotSpot中，默认的内联最大深度是MaxInlineLevel控制，也就是9层。</p>\n<p>为什么要限制内联的最大深度呢？</p>\n<p>在stackoverflow上有个我认为比较中肯的答案</p>\n<p><a href=\"https://stackoverflow.com/questions/32503669/why-does-the-jvm-have-a-maximum-inline-depth\" target=\"_blank\" rel=\"noopener\">Why does the JVM have a maximum inline depth?</a></p>\n<blockquote>\n<p>Not exactly, but I guess the basic reason is to keep things simple. Unlimited inlining depth would increase complexity, the compilation time and memory usage might be less predictable (that is OK for AOT compilers, but not for JIT). Also mind that compiled code should keep track of the whole inlining tree at run-time (to be able to unwind and deoptimize). Though I think the default value of 9 is outdated. It has not been changed for ages, but nowadays, with much more resources available, with streams and lamdas in mind, there is definitely a place for improvement</p>\n</blockquote>\n<p>总结一下答案：</p>\n<ul>\n<li>为了保持内联的简单性。无限制的内联会增加复杂度。</li>\n<li>内联后的编译代码，需要记录整个内联树。</li>\n<li>编译时间和内存消耗会变得不可预测。</li>\n</ul>\n<p>当然，作者也认为默认值9已经很久没有改动了，随着计算机资源变得不再那么昂贵，完全可以适当调大这个值。</p>\n<h3 id=\"MaxRecursiveInlineLevel\"><a href=\"#MaxRecursiveInlineLevel\" class=\"headerlink\" title=\"MaxRecursiveInlineLevel\"></a>MaxRecursiveInlineLevel</h3><p>对于递归的方法，它内联自己最多只能内联MaxRecursiveInlineLevel层，也就是1次。</p>\n<h2 id=\"查看内联结果\"><a href=\"#查看内联结果\" class=\"headerlink\" title=\"查看内联结果\"></a>查看内联结果</h2><p>如果想要知道我们的代码在编译时，内联了哪些方法，那么可以加上参数</p>\n<p><code>java -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining</code></p>\n<p>对于上面的inline.java的结果输出如下</p>\n<p><img src=\"/images/HotSpot原理指南-内联/内联输出结果.png\" alt=\"内联输出结果\"></p>\n","categories":["HotSpot"],"tags":["HotSpot","JVM","内联"]},{"title":"HotSpot原理指南-C1和C2编译流程","url":"https://blog.lovezhy.cc/2019/11/27/HotSpot原理指南-C1和C2编译流程/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前文讲述了C1和C2的功能定位，以及引出了Client和Server模式的区别。</p>\n<p>这回抛开功能和定位的角度，简单看看从设计与实现角度的区别。</p>\n<a id=\"more\"></a>\n<h2 id=\"前导知识\"><a href=\"#前导知识\" class=\"headerlink\" title=\"前导知识\"></a>前导知识</h2><p>要讲解设计与实现角度的区别，需要了解很多的编译原理知识。</p>\n<p>😄编译原理是科班必学的一门课，当时作者上的迷迷糊糊的，觉得没什么用，也没怎么听。</p>\n<p>现在看到C1和C2的东西，真的是一筹莫展。</p>\n<p>相信很多科班和非科班的人也是。</p>\n<p>不过大家不用担心，作者水平有限，更是不会瞎写自己根本不会的东西，所以涉及到编译原理的东西讲的都很简单。</p>\n<h3 id=\"IR\"><a href=\"#IR\" class=\"headerlink\" title=\"IR\"></a>IR</h3><p>IR，中文中间表示，全称是intermediate representation。</p>\n<p>其实它和中间语言的定义类似，但是中间语言的定义更加狭义，只规定必须是某种语言，而中间表示则扩宽了范围，可以是树类型或者是图类型的表示。</p>\n<p>在维基百科上，中间语言的定义是</p>\n<blockquote>\n<p><strong>中间语言</strong>（英语：Intermediate language），在计算机科学中，是指一种应用于抽象机器（abstract machine）的编程语言，它设计的目的，是用来帮助我们分析计算机程序。这个术语源自于编译器，在编译器将源代码编译为目的码的过程中，会先将源代码转换为一个或多个的中间表述，以方便编译器进行最佳化，并产生出目的机器的机器语言</p>\n</blockquote>\n<p>其实更简单的定义，我觉得就是源代码的另一种表达形式。</p>\n<p>比如Java代码，会被编译成字节码，字节码也是一种IR，是Java代码的中间表示。</p>\n<p>IR在编译原理中的作用个人理解其实起到两种：</p>\n<ul>\n<li>统一后端语言。比如JRuby，Scala，Kotlin等，他们的解释器其实都是JVM。但是他们的源代码都是不一样的。倘若对于每种语言的处理都是不一样的，那其实JVM的实现就没什么意义了，所以将所有语言的源代码都编译成同一种IR，然后JVM不用关心源语言是什么，只要符合该IR定义的都可以执行。</li>\n<li>方便优化。很多的优化技术，其实人眼可以简单看出的，很难归一化到程序去理解。但是通过一些IR的表示，使用特定的规则，就可以进行优化。就行我们在拼魔方时的公式一样。那为什么有这么多种IR呢，很大一个程度的区别就是他们在解决一些特定优化时各有优势。比如SSA在进行复制传播时就很方便。</li>\n</ul>\n<h3 id=\"寄存器分配\"><a href=\"#寄存器分配\" class=\"headerlink\" title=\"寄存器分配\"></a>寄存器分配</h3><p>一个解释器执行的程序和以机器码执行的程序的一个很大的区别就是对于系统寄存器的使用。</p>\n<p>比如对于下面的函数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = i + j;</span><br><span class=\"line\">    k += <span class=\"number\">2</span>;</span><br><span class=\"line\">    k *= <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i + j;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果是以解释的形式而言，则需要把k存在内存的变量中，然后再进行运算，每一步的运算都要把k的值写回到内存中。</p>\n<p>但是如果是C++的话，完全可以给k分配一个寄存器，把k放到寄存器中，然后直接对寄存器中的值进行运算就行。</p>\n<p>所以，如果能够很好的利用系统现有的寄存器，那么程序执行的性能将提升一个档次。</p>\n<p>对于寄存器的分配算法，有很多论文可以参考，作者水平有限，还没能学会一种。</p>\n<p>读者有兴趣可以自己去搜索相关论文进行了解。</p>\n<h2 id=\"C1流程\"><a href=\"#C1流程\" class=\"headerlink\" title=\"C1流程\"></a>C1流程</h2><p><img src=\"/images/HotSpot原理指南-C1和C2流程/C1流程.png\" alt=\"\"></p>\n<p>C1的流程较为简单，如上图所示。</p>\n<p>首先，字节码会经过转换，变成HIR，也就是High Level的IR，高级中间表示。</p>\n<p>在HIR中，会进行一些优化，比如</p>\n<ul>\n<li>GVN优化</li>\n<li>基本块优化</li>\n<li>null检查消除</li>\n<li>…</li>\n</ul>\n<p>经过HIR优化之后，转换成LIR，也就是Low-Level的IR，低级中间表示。</p>\n<p>这个阶段的IR其实已经很接近机器码了</p>\n<p>在LIR时，进行</p>\n<ul>\n<li>寄存器分配。这里的寄存器分配算法是线性扫描，时间消耗短，但是分配效果有限</li>\n<li>窥孔优化</li>\n</ul>\n<p>在LIR的优化过后，就是机器码的生成。</p>\n<p>对于C1的更详细的流程，笔者也从网上找到了当时作者的一个PPT，有兴趣的可以自行下载</p>\n<p><a href=\"http://compilers.cs.uni-saarland.de/ssasem/talks/Christian.Wimmer.pdf\" target=\"_blank\" rel=\"noopener\">http://compilers.cs.uni-saarland.de/ssasem/talks/Christian.Wimmer.pdf</a></p>\n<p>同时，如果有人对线性扫描寄存器分配算法有兴趣，也可以参照论文</p>\n<p><a href=\"http://web.cs.ucla.edu/~palsberg/course/cs132/linearscan.pdf\" target=\"_blank\" rel=\"noopener\">http://web.cs.ucla.edu/~palsberg/course/cs132/linearscan.pdf</a></p>\n<h2 id=\"C2流程\"><a href=\"#C2流程\" class=\"headerlink\" title=\"C2流程\"></a>C2流程</h2><p>通过前面我们已经知道C2相对于C1编译过程，更加的耗时，这个耗时可以体现在两方面</p>\n<ul>\n<li>比C1有更多的优化</li>\n<li>同一种优化使用的算法不同，C2的结果更好</li>\n</ul>\n<p>对于C2而言，它的IR只有一种，叫<code>Sea Of Nodes</code></p>\n<p>就笔者了解到的知识来看，这个IR非常的牛逼，在V8引擎中，也是使用的这种IR。</p>\n<p>不过这种IR的资料似乎非常少，笔者也仅仅是搜到了论文，没什么更深层次的讲解。</p>\n<p>如果有人想要了解Sea Of Nodes的原理，那么大家可以从网上搜集资料来看。</p>\n<p><strong>比C1拥有更多的优化</strong></p>\n<p>相比较于C1，C2几乎会做所有的经典优化。如下图所示</p>\n<p><img src=\"/images/HotSpot原理指南-C1和C2流程/C2优化.png\" alt=\"\"></p>\n<p><strong>同一种优化使用不同的算法</strong></p>\n<p>这个体现在寄存器分配算法上，我们知道对于C1而言，使用的较为简单的线性扫描的分配算法，执行较快。</p>\n<p>而C2使用了叫图染色的算法，消耗的时间更久，但是产生的解法比线性扫描更优。</p>\n<p>对于图染色算法，在经典的编译原理书中都有解答。</p>\n<p>笔者这里就不赘述了（其实是笔者也没看懂）</p>\n","categories":["HotSpot"],"tags":["Java","HotSpot","JVM","C1和C2"]},{"title":"HotSpot原理指南-C1和C2介绍","url":"https://blog.lovezhy.cc/2019/11/24/HotSpot原理指南-C1和C2介绍/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>HotSpot是一款Java虚拟机的实现，除了基本的解释功能以外，该虚拟机还拥有将字节码编译成机器码的并执行的能力，我们知道，直接执行机器码肯定比解释更快。</p>\n<p>HotSpot最初会通过解释的方式执行程序，当它发现某个方法运行得特别频繁时，就会将这些热点（Hot Spot）代码进行编译，编译成平台相关的机器码。这个过程也叫做JIT（Just In Time），与之相对的是AOT（Ahead Of Time），比较典型的是C和C++语言。</p>\n<p>HotSpot进行JIT编译的编译器有两个，分别叫做<strong>C1</strong>和<strong>C2</strong>，或者也可以叫做<strong>Client Compiler</strong>和<strong>Server Compiler</strong>。这两种编译器编译策略不同，运用在不同的场景，下面会详细的说明。</p>\n<a id=\"more\"></a>\n<h2 id=\"JIT编译\"><a href=\"#JIT编译\" class=\"headerlink\" title=\"JIT编译\"></a>JIT编译</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Add</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">200</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> start = System.nanoTime();</span><br><span class=\"line\">            add();</span><br><span class=\"line\">            <span class=\"keyword\">long</span> end = System.nanoTime();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">            sum += i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面这段代码，我们有一个<code>add</code>方法，如果我们对改方法进行时间统计，我们会得到下面的曲线。</p>\n<p>X轴是次数，Y轴是时间的log2。</p>\n<p><img src=\"/images/HotSpot原理指南-C1和C2/add.png\" alt=\"\"></p>\n<p>从这个曲线我们可以看出，在第大概100次的时间，时间消耗会下滑，也就是性能提升了一个档次。</p>\n<p>由此我们可以猜到，前100次的add方法是由解释执行的，在100次后，执行的是由JIT编译器编译过的机器码。所以性能会有较大的提升。</p>\n<h2 id=\"Profile\"><a href=\"#Profile\" class=\"headerlink\" title=\"Profile\"></a>Profile</h2><p>在详细讲述C1和C2之前，我们还有一个内容需要科普，就是方法的Profile信息。</p>\n<p>除了最基本的用于判定某个方法是否是HotSpot的方法调用次数（Invocation Counter）信息外，对于某个方法，还有一些信息是会在运行时进行收集的。</p>\n<p>比如我们看下面这段代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">record</span><span class=\"params\">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (list != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\tlist.add(<span class=\"string\">\"大骚包卢布\"</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    log.warn(<span class=\"string\">\"我不是大骚包\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>record</code>函数的功能很简单，入参是一个List，如果List不为空，那么就把<code>大骚包卢布</code>这个字符串传递进去。不然的话就打出一个warn级别的日志<code>我不是大骚包</code>。</p>\n<p>那么在调用这个方法的时候，HotSpot还会记录哪些信息呢</p>\n<ul>\n<li>List的真实类。因为List在Java中是一个接口，具体的传入可能是ArrayList或者LinkedList或者其他的。HotSpot需要记录具体的类为了以后的优化。</li>\n<li>Log的真实类，理由和List一样。</li>\n<li>进入if的次数，以及进入else的次数，更通俗的说是条件选择的实际情况。</li>\n</ul>\n<p>有人可能会问统计这些Profile有什么用。</p>\n<p>举个最简单的例子，如果我们需要对<code>list.add</code>做内联，那么我们到底内联那个实现呢，这个就需要我们收集list的真实实现是什么。</p>\n<h2 id=\"C1和C2\"><a href=\"#C1和C2\" class=\"headerlink\" title=\"C1和C2\"></a>C1和C2</h2><table>\n<thead>\n<tr>\n<th></th>\n<th>C1</th>\n<th>C2</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>编译时间</td>\n<td>快</td>\n<td>慢（x4）</td>\n</tr>\n<tr>\n<td>执行时间</td>\n<td>慢</td>\n<td>快（30%）</td>\n</tr>\n<tr>\n<td>输出代码</td>\n<td>多</td>\n<td>少</td>\n</tr>\n</tbody>\n</table>\n<p>上表是C1和C2在编译时间，执行时间，输出代码的区别</p>\n<ul>\n<li>编译时间：同样一段代码，C1需要时间比C2短，也就是需求的CPU资源较少</li>\n<li>执行时间：C1编译时间短，通常意味着优化不如C2，所以C2编译出的机器码执行效率较高</li>\n<li>输出代码：C1编译时间短，最终也就导致输出的机器码占用的内存要比C2多的</li>\n</ul>\n<p>总结：同一段代码，C1消耗的CPU资源较少，但是输出的代码质量不如C2。但是毋庸置疑的事，无论是C1还是C2输出的机器码，执行效率肯定都比解释快的。</p>\n<p>C1又称<strong>Client Compiler</strong>，C2又称<strong>Server Compiler</strong>，不是没有历史渊源的。</p>\n<p>或许我们都听过java在启动的时候可以执行是<code>client</code>模式还是<code>server</code>模式。</p>\n<p>当我们使用client模式时，一般运行的是应用程序，比如java swing，awt之类的图形软件，对于这些桌面软件，作为使用者而言，并不希望哪个桌面应用占用大量的CPU，所以非常适合C1的场景</p>\n<ul>\n<li>编译速度快</li>\n<li>占用CPU资源少</li>\n</ul>\n<p>而对于Server模式而言，一般是公司的服务器上跑的稳定的服务应用，服务器的资源一般较为丰富，同时一个应用并不会像桌面应用一样频繁的开关，一般都要跑几周或者几个月甚至几年。这种应用，当然速度越快越好。所以非常适合C2的场景</p>\n<ul>\n<li>编译消耗更多的CPU资源</li>\n<li>代码质量更高，也就是性能更好</li>\n</ul>\n<h2 id=\"C1和C2和Profile\"><a href=\"#C1和C2和Profile\" class=\"headerlink\" title=\"C1和C2和Profile\"></a>C1和C2和Profile</h2><p>前面提到过的Profile信息，你可能会疑惑这个和C1和C2有什么联系。</p>\n<p>其实我们需要先明白一个概念，就是收集那些Profile不仅仅会占用程序以外的更多的内容，而且会占用很多的CPU消耗。同样一段代码，插入了收集Profile逻辑和没有插入收集Profile逻辑，执行性能是不同的。</p>\n<p>结合我们提到的C1和C2的使用场景的区别，可以得出这样的结论，这个收集Profile的消耗，对于桌面应用而言，是非常<strong>不合适</strong>的。</p>\n<p>但是C2则需要这些Profile去做更好的性能优化。</p>\n<p>所以对于Client模式的应用而言，解释器不会去收集程序的Profile信息，而Server模式在解释器阶段，则会进行Profile的收集，这也就导致了Client模式的起步性能是比Server模式的起步性能要好很多。</p>\n<h2 id=\"启动模式\"><a href=\"#启动模式\" class=\"headerlink\" title=\"启动模式\"></a>启动模式</h2><p>在JDK1.6之前，指定是<code>client</code>还是<code>server</code>模式，我们在java程序启动时直接加参数就行了</p>\n<p><code>java -client Hello</code></p>\n<p><strong>但是</strong></p>\n<p>注意我这个但是</p>\n<p>其实自从JDK6的某个版本开始，你已经控制不了这个参数了</p>\n<p><a href=\"https://docs.oracle.com/javase/7/docs/technotes/guides/vm/server-class.html\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/javase/7/docs/technotes/guides/vm/server-class.html</a></p>\n<p>从这个网站可以看到，默认如果你是64位的机器并且至少有2G内存和2核心的CPU，默认都是Server模式了。</p>\n<p><code>-client</code>这个参数会被忽略</p>\n<p>但是也并不是没有办法指定client模式</p>\n<p>不仅仅要在启动参数中加上<code>-client</code></p>\n<p>还需要去修改文件<code>jre/lib/jvm.cfg</code></p>\n<p>比如我的文件中默认是这个状态</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-server KNOWN</span><br><span class=\"line\">-client IGNORE</span><br><span class=\"line\">-hotspot ERROR</span><br><span class=\"line\">-classic WARN</span><br><span class=\"line\">-native ERROR</span><br><span class=\"line\">-green ERROR</span><br></pre></td></tr></table></figure>\n<p>注意到我的<code>-client</code>后面跟的是<code>IGNORE</code>，所以我指定<code>-client</code>模式其实是不生效的</p>\n<p>我需要改成<code>-client KNOWN</code>才行。</p>\n<p>当然Oracle选择忽略<code>-client</code>模式也不是没有道理的</p>\n<ul>\n<li>Java的桌面应用已经很少了，Swing基本已经死了</li>\n<li>现在大家的笔记本的CPU和内容资源都很充足</li>\n</ul>\n<p>所以全部使用<code>server</code>模式也没问题。</p>\n<h2 id=\"后续\"><a href=\"#后续\" class=\"headerlink\" title=\"后续\"></a>后续</h2><p>当然C1和C2的故事并没有这么简单</p>\n<p>同时JIT编译的策略也不是非C1就是C2，在JDK7中引入了分层编译，结合了C1和C2的优点。</p>\n<p>这些会在后面的文章讲述。</p>\n","categories":["HotSpot"],"tags":["HotSpot"]},{"title":"给RedisTemplate插入Cat打点","url":"https://blog.lovezhy.cc/2019/11/08/给RedisTemplate插入Cat打点/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Cat是美团开源的一套监控系统，功能非常强大<br>一般对方法进行打点，它会自动生成每个方法的耗时，同时也会记录全链路的每个调用方法的耗时</p>\n<p>对于查系统的性能瓶颈和稳定性有非常大的帮助</p>\n<a id=\"more\"></a>\n<p>基本用法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Transaction tranx = Cat.newTransaction(<span class=\"string\">\"Cache\"</span>, <span class=\"string\">\"get\"</span>);</span><br><span class=\"line\">tranx.addData(<span class=\"string\">\"key\"</span>, <span class=\"string\">\"name\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//do something</span></span><br><span class=\"line\">tranx.setStatus(<span class=\"string\">\"0\"</span>);</span><br><span class=\"line\">tranx.complete();</span><br></pre></td></tr></table></figure></p>\n<p>上面的方法就是对中间的代码执行进行耗时打点，这里假设的是我们对Redis的get方法进行打点</p>\n<ul>\n<li>第一句：new一个Transaction出来，Type是Cache，也就是Transaction属于Cache，然后具体的方法是get</li>\n<li>第二句：addData，在执行过程中进行关键日志的记录，我们这里记录了get的key是name，方面查询长耗时的方法，增加一些提示性的参数</li>\n<li>第三句：执行具体的方法</li>\n<li>第四句：执行成功，设置status=0，0表示成功的意思，当然也有失败的方法，可以把具体的Exception传递进去</li>\n<li>第五句：标记Transaction完成</li>\n</ul>\n<h2 id=\"框架集成\"><a href=\"#框架集成\" class=\"headerlink\" title=\"框架集成\"></a>框架集成</h2><p>Cat只是提供了一些工具，并没有直接提供方法与常见的方法集成，让我们在业务代码的每个方法都手动编码上面这些流程肯定不现实，可以借助于很多的方法进行隐式的插入逻辑。</p>\n<h3 id=\"与Dubbo集成\"><a href=\"#与Dubbo集成\" class=\"headerlink\" title=\"与Dubbo集成\"></a>与Dubbo集成</h3><p>Dubbo提供了Filter机制，可以声明一个Filter进行对Dubbo服务方法的打点</p>\n<p><a href=\"https://github.com/dianping/cat/tree/master/integration/dubbo\" target=\"_blank\" rel=\"noopener\">Dubbo</a></p>\n<p>在Cat的官方仓库中收集了此集成方式，可以直接使用</p>\n<h2 id=\"与Mybatis集成\"><a href=\"#与Mybatis集成\" class=\"headerlink\" title=\"与Mybatis集成\"></a>与Mybatis集成</h2><p>和Dubbo一个，Mybatis也提供了Filter插件</p>\n<p><a href=\"https://github.com/dianping/cat/tree/master/integration/mybatis\" target=\"_blank\" rel=\"noopener\">Mybatis</a></p>\n<p>在Cat的官方仓库中收集了此集成方式，可以直接使用</p>\n<p>上面两种插件几乎是最常用的两个了，但是Redis的需求也比较强烈</p>\n<h2 id=\"Redis打点\"><a href=\"#Redis打点\" class=\"headerlink\" title=\"Redis打点\"></a>Redis打点</h2><p>Cat的官方仓库并没有提供Redis的打点插件，借着Filter的简单的逻辑，我准备找找现有框架的逻辑插入方法</p>\n<p>在正常的SpringBoot应用中，默认的Redis使用类是RedisTemplate，如果具体到某个操作，在内部声明了多个具体的类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisTemplate</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt;    </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// cache singleton objects (where possible)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"meta\">@Nullable</span> ValueOperations&lt;K, V&gt; valueOps;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"meta\">@Nullable</span> ListOperations&lt;K, V&gt; listOps;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"meta\">@Nullable</span> SetOperations&lt;K, V&gt; setOps;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"meta\">@Nullable</span> ZSetOperations&lt;K, V&gt; zSetOps;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"meta\">@Nullable</span> GeoOperations&lt;K, V&gt; geoOps;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"meta\">@Nullable</span> HyperLogLogOperations&lt;K, V&gt; hllOps;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>比如当我们调用</p>\n<p><code>redisTemplate.opsForSet().members(cacheName)</code>时，</p>\n<p>调用的是</p>\n<p><code>DefaultSetOperations.members(K key)</code>方法</p>\n<p>所以我们只要对上面提到的具体操作的类的一些方法进行打点就行</p>\n<p>但是很可惜，RedisTemplate并没有提供</p>\n<h2 id=\"方案一\"><a href=\"#方案一\" class=\"headerlink\" title=\"方案一\"></a>方案一</h2><p>直接使用SpringAop对具体的类进行代理</p>\n<p>这当时是我觉得最简单的方法，但是很遗憾</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultSetOperations</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractOperations</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">SetOperations</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultValueOperations</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractOperations</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">ValueOperations</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>这些具体实现类都不是public的，对这些方法进行切面处理是处理不了的</p>\n<h2 id=\"方案二\"><a href=\"#方案二\" class=\"headerlink\" title=\"方案二\"></a>方案二</h2><p>最简单的方法被否决了，于是只能找一些其他的方法</p>\n<p>当时看到Java的Agent可以在类被加载时进行一些修改，于是产生了写一个javaagent的方法</p>\n<p>目标效果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> execute(<span class=\"keyword\">new</span> ValueDeserializingRedisCallback(key) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">byte</span>[] inRedis(<span class=\"keyword\">byte</span>[] rawKey, RedisConnection connection) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> connection.get(rawKey);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">=&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Transaction tranx = Cat.newTransaction(<span class=\"string\">\"Cache\"</span>, <span class=\"string\">\"get\"</span>); </span><br><span class=\"line\">    tranx.addData(<span class=\"string\">\"key\"</span>, key);</span><br><span class=\"line\">    V res = execute(<span class=\"keyword\">new</span> ValueDeserializingRedisCallback(key) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">byte</span>[] inRedis(<span class=\"keyword\">byte</span>[] rawKey, RedisConnection connection) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> connection.get(rawKey);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    tranx.setStatus(<span class=\"string\">\"0\"</span>);</span><br><span class=\"line\">    tranx.complete();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是为了得到失败的效果，同时防止Cat方法抛出异常影响正常逻辑，需要多加几个try catch</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Transaction tranx = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      tranx = Cat.newTransaction(<span class=\"string\">\"Cache\"</span>, <span class=\"string\">\"get\"</span>);</span><br><span class=\"line\">      tranx.addData(<span class=\"string\">\"key\"</span>, key);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    V res = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        V res = execute(<span class=\"keyword\">new</span> ValueDeserializingRedisCallback(key) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"meta\">@Override</span></span><br><span class=\"line\">              <span class=\"keyword\">protected</span> <span class=\"keyword\">byte</span>[] inRedis(<span class=\"keyword\">byte</span>[] rawKey, RedisConnection connection) &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">return</span> connection.get(rawKey);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (tranx != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           tranx.setStatus(e);</span><br><span class=\"line\">           tranx.complete();</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">         </span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (tranx != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        tranx.setStatus(<span class=\"string\">\"0\"</span>);</span><br><span class=\"line\">        tranx.complete();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(Throwable e) &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，代码非常长，但是不用担心性能，经过编译优化之后很多其实都被优化掉了</p>\n<h2 id=\"java-lang-instrument包\"><a href=\"#java-lang-instrument包\" class=\"headerlink\" title=\"java.lang.instrument包\"></a>java.lang.instrument包</h2><blockquote>\n<p>Provides services that allow Java programming language agents to instrument programs running on the JVM. The mechanism for instrumentation is modification of the byte-codes of methods.<br>Package Specification</p>\n</blockquote>\n<p>Oracle的官网上对这个包的定义如上，简单的说就是给与我们能力动态的修改Java类的字节码<br>一般可以用来监控，织入类似于AOP的逻辑</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>当时选择了javaassit进行字节码的织入，但是javaassit有一个很大的局限就是不能使用本地变量</p>\n<p>比如<code>Transaction tranx</code>这个我们在声明出来之后，在下面的代码就获取不到这个变量了</p>\n<p>但是整个方法不会触及多线程的场景，所以想到的方案就是放在一个ThreadLocal中</p>\n<p>先构造出一个ThreadLocal的类进行封装</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisCatLog</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;RedisCatLog&gt; THREAD_LOCAL_CAT_LOG = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">startLog</span><span class=\"params\">(String action, Object data)</span> </span>&#123;</span><br><span class=\"line\">        THREAD_LOCAL_CAT_LOG.remove();</span><br><span class=\"line\">        RedisCatLog redisCatLog = <span class=\"keyword\">new</span> RedisCatLog(action);</span><br><span class=\"line\">        redisCatLog.before(String.valueOf(data));</span><br><span class=\"line\">        THREAD_LOCAL_CAT_LOG.set(redisCatLog);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">endLog</span><span class=\"params\">(<span class=\"keyword\">boolean</span> success)</span> </span>&#123;</span><br><span class=\"line\">        RedisCatLog redisCatLog = THREAD_LOCAL_CAT_LOG.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Objects.nonNull(redisCatLog)) &#123;</span><br><span class=\"line\">            redisCatLog.after(success);</span><br><span class=\"line\">            THREAD_LOCAL_CAT_LOG.remove();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String action;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Transaction tranx;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RedisCatLog</span><span class=\"params\">(String action)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.action = action;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">before</span><span class=\"params\">(String data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.tranx = Cat.newTransaction(<span class=\"string\">\"Cache.\"</span>, <span class=\"keyword\">this</span>.action);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.tranx <span class=\"keyword\">instanceof</span> NullMessage) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">\"is null message\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.tranx.addData(<span class=\"string\">\"key\"</span>, data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">after</span><span class=\"params\">(<span class=\"keyword\">boolean</span> success)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!success) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.tranx.setStatus(<span class=\"string\">\"failed\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.tranx.setStatus(<span class=\"string\">\"0\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.tranx.complete();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，有了这个类之后，我们的织入代码就比较简单了</p>\n<ul>\n<li>给现有方法的开始加入RedisCatLog.startLog()</li>\n<li>给方法的结尾加上RedisCatLog.endLog()</li>\n<li>给原有的完整代码加上try catch</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public V get(Object key) &#123;</span><br><span class=\"line\">    try &#123;RedisCatLog.startLog(\"get\", key);&#125; catch(Throwable e) &#123;&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        V res = execute(new ValueDeserializingRedisCallback(key) &#123;</span><br><span class=\"line\">              @Override</span><br><span class=\"line\">              protected byte[] inRedis(byte[] rawKey, RedisConnection connection) &#123;</span><br><span class=\"line\">                  return connection.get(rawKey);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;, true);</span><br><span class=\"line\">    &#125; catch(Throwable e) &#123;</span><br><span class=\"line\">        try &#123;RedisCatLog.endLog(false);&#125; catch(Throwable e) &#123;&#125;</span><br><span class=\"line\">        throw e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    try &#123;RedisCatLog.endLog(true);&#125; catch(Throwable e) &#123;&#125;</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>整体来看是不是简单的了很多</p>\n<p>下面就是具体的javaassit代码编写了</p>\n<p>在编写时参考了文档，并没有系统的学习javaassit</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String methodName = methods[i].getName();</span><br><span class=\"line\">CtClass etype = ClassPool.getDefault().get(<span class=\"string\">\"java.lang.Throwable\"</span>);</span><br><span class=\"line\">methods[i].addCatch(<span class=\"string\">\"&#123; RedisCatLog.endLog(false); throw $e; &#125;\"</span>, etype);</span><br><span class=\"line\">methods[i].insertBefore(before(classMethodNameInfo.getType() + <span class=\"string\">\"-\"</span> + methodName));</span><br><span class=\"line\">methods[i].insertAfter(after());</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">before</span><span class=\"params\">(String action)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> String.format(<span class=\"string\">\"try &#123; RedisCatLog.startLog(\\\"%s\\\", $1); &#125; catch (Throwable e) &#123;&#125;\"</span>, action);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">after</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"try&#123; RedisCatLog.endLog(true);&#125; catch (Throwable e) &#123;&#125;\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>大概的整体逻辑如下</p>\n<p>项目我传到了Github上，<a href=\"https://github.com/zhyzhyzhy/CatRedisLogAspect\" target=\"_blank\" rel=\"noopener\">https://github.com/zhyzhyzhy/CatRedisLogAspect</a></p>\n<p>大家可以参考文档进行使用</p>\n","categories":["Spring和SpringBoot"],"tags":["Spring","Cat"]},{"title":"Raft实现指北","url":"https://blog.lovezhy.cc/2019/09/05/Raft实现指北/","content":"<p>Raft实现指北<br><a id=\"more\"></a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>自己陆陆续续花了一些时间完成了一个Raft的库，目前基本的流程都完成了，下面要继续做的话，就是要进行一些优化的逻辑了。<br><a href=\"https://github.com/zhyzhyzhy/Rub-Raft\" target=\"_blank\" rel=\"noopener\">Rub-Raft</a><br>取名叫Rub，就是卢布的意思，纪念雯姐今年去世的花枝鼠[2016-2019]。<br>卢布是我见过最乖的鼠，很聪明，她喜欢睡在吊床上，不会像其他的鼠去啃吊床的线。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>一个很好的博文<br><a href=\"https://lichuang.github.io/post/20180921-raft/\" target=\"_blank\" rel=\"noopener\">https://lichuang.github.io/post/20180921-raft/</a>  </p>\n<p>《CONSENSUS: BRIDGING THEORY AND PRACTICE》论文<br><a href=\"https://ramcloud.stanford.edu/~ongaro/thesis.pdf\" target=\"_blank\" rel=\"noopener\">https://ramcloud.stanford.edu/~ongaro/thesis.pdf</a>  </p>\n<p>动画讲解<br><a href=\"https://raft.github.io/\" target=\"_blank\" rel=\"noopener\">https://raft.github.io/</a></p>\n<h2 id=\"整体流程\"><a href=\"#整体流程\" class=\"headerlink\" title=\"整体流程\"></a>整体流程</h2><p>集群的整体状态一般分为三种</p>\n<ul>\n<li>选举</li>\n<li>日志添加<ul>\n<li>正常添加</li>\n<li>非正常添加</li>\n<li>新节点获取日志</li>\n</ul>\n</li>\n<li>新增节点</li>\n</ul>\n<p>我可能不太会对所有流程做详细的阐述，只是一些简单的问答和心得。</p>\n<p>整个RPC的方法其实只要4个就可以完成Raft，前两个和选举有关，后两个和日志有关</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">VoteResponse <span class=\"title\">requestPreVote</span><span class=\"params\">(VoteRequest voteRequest)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">VoteResponse <span class=\"title\">requestVote</span><span class=\"params\">(VoteRequest voteRequest)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ReplicatedLogResponse <span class=\"title\">requestAppendLog</span><span class=\"params\">(ReplicatedLogRequest replicatedLogRequest)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">InstallSnapshotResponse <span class=\"title\">requestInstallSnapShot</span><span class=\"params\">(InstallSnapshotRequest installSnapShotRequest)</span></span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><h3 id=\"需要节点的自动注册和发现吗\"><a href=\"#需要节点的自动注册和发现吗\" class=\"headerlink\" title=\"需要节点的自动注册和发现吗\"></a>需要节点的自动注册和发现吗</h3><p>一开始我还是RPC的实现思路，以为需要一个自动的节点注册和发现机制<br>当然其实并不需要，集群启动的时候，只要我们把初始的节点信息写死在启动Config文件中就好  </p>\n<p>那么可不可以有呢，我理解是不可以的，因为选举的时候，节点需要知道当前节点的个数，来判断自己得到的选票是不是已经有集群节点的一半了。<br>如果你还搞个节点自动注册，那么到底集群有几个节点呢？</p>\n<h2 id=\"节点的RPC连接\"><a href=\"#节点的RPC连接\" class=\"headerlink\" title=\"节点的RPC连接\"></a>节点的RPC连接</h2><p>讲道理其实RPC连接并不是什么大问题，但是我们不能先入为主的当做DUBBO这种RPC框架去实现我们的RPC框架。<br>这个问题的根源是：正常的RPC模型并不是互相问答的模式<br>都是C/S模型<br>一个节点一般会开一个Server，让其他的节点来连接，并提出请求，这个Server并不会主动向其他的Node发送消息。 </p>\n<p>这个时候会想到，我们每个节点都当做是一个Server，然后对每个其他的Node，开对应的Client连接。我就是这么实现的，这样的情况其实对于两个节点而言，互相的连接通过了两个不同的Channel来实现。</p>\n<p>后来发现其实这样还有问题。<br>问题是在无法重新连接的情况<br>假设这样的情形，3Node互相连接，过程中Node1断开，其他两个Node互相连接，过一阵子，Node1又启动，开启自己的RpcServer，并顺利连接到其他两个Node的RpcServer<br>而其他两个Node并不会主动的去连接Node1的RpcServer</p>\n<p>这个就需要一种机制，当其他的节点连接上自己的RpcServer的时候，获得感知，然后自己也去连接对方的RpcServer</p>\n<p>那么这个感知机制，放在哪里去做呢。<br>放在Rpc层面吗？我感觉侵入性很大，一方面作为一个Rpc并不需要这种机制，需要的话，也是一个抽象度很高的东西，类似于连接上的回调之类。</p>\n<p>我这里另外开了一个RPC方法，叫<code>requestConnect</code>，当每个节点RPCClient或者RPCServer启动的时候，都会向其他的节点发送<code>requestConnect</code>请求，其他节点接收到这个请求，会检查自己与发送请求的节点的链路是否已经失效，如果失效，则请求重新连接。</p>\n<p>这样完成的很好，但是就是RPC请求的次数会有点多。</p>\n<h2 id=\"RPC请求的异步与同步\"><a href=\"#RPC请求的异步与同步\" class=\"headerlink\" title=\"RPC请求的异步与同步\"></a>RPC请求的异步与同步</h2><p>这个问题不是很复杂，但是我们如果自己实现RPC的话，要注意的一点就是不能不支持异步的方式。<br>我的RPC的实现中，支持3种请求方式</p>\n<ul>\n<li>SYNC 同步请求</li>\n<li>ASYNC 异步请求</li>\n<li>ONE_WAY 不需要返回的请求</li>\n</ul>\n<p>不过异步请求说白了就是RPC框架帮你封装好了SYNC的Future的方式</p>\n<p>上面提到了Raft的需要的5种方法，那些需要异步呢</p>\n<ul>\n<li>requestConnect =&gt; ONE_WAY</li>\n<li>requestPreVote =&gt; ASYCN</li>\n<li>requestVote =&gt; ASYNC</li>\n<li>requestAppendLog =&gt; SYNC</li>\n<li>requestInstallSnapShot =&gt; SYNC</li>\n</ul>\n<h2 id=\"选举\"><a href=\"#选举\" class=\"headerlink\" title=\"选举\"></a>选举</h2><h3 id=\"节点启动顺序\"><a href=\"#节点启动顺序\" class=\"headerlink\" title=\"节点启动顺序\"></a>节点启动顺序</h3><p>节点启动的顺序要注意什么吗？<br>还是不需要，选举要得到一般的选票才能成为Leader，即使有一个节点最后启动，此时集群中已经选举出一个Leader了，最后启动的那个节点收到AppendLog的消息，就会自动变成Follower。</p>\n<h3 id=\"节点初始化\"><a href=\"#节点初始化\" class=\"headerlink\" title=\"节点初始化\"></a>节点初始化</h3><p>节点初始化要做的事不多，就是设置自己的状态为<code>Follower</code><br>然后启动一个选举超时的定时器</p>\n<h3 id=\"选举超时时间\"><a href=\"#选举超时时间\" class=\"headerlink\" title=\"选举超时时间\"></a>选举超时时间</h3><p>节点刚启动的状态是<code>Follower</code>，并且启动一个超时定时器，当时间到了的时候开始进行选举<br>那么这个超时的时间是多少呢？论文中给出的范围是150 - 300ms[章节3.4]  </p>\n<h3 id=\"超时期间收到Request\"><a href=\"#超时期间收到Request\" class=\"headerlink\" title=\"超时期间收到Request\"></a>超时期间收到Request</h3><p>我们知道当选举超时之后，节点把自己的状态设为<code>pre_candidate</code>，并且发送消息给其他节点进行选举。<br>如果超时期间收到消息呢<br>论文中写，<code>A server remains in follower state as long as it receives valid RPCs from a leader or candidate.</code></p>\n<p>很明晰，超时期间收到其他节点的Request，那么就不会进入选举流程，依然是一个Follower。</p>\n<h3 id=\"超时方法什么时候调用\"><a href=\"#超时方法什么时候调用\" class=\"headerlink\" title=\"超时方法什么时候调用\"></a>超时方法什么时候调用</h3><p>在接收到PreVote，Vote，AppendLog的RPC请求接收到之后都要开始调用  </p>\n<h3 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h3><p>要加锁吗，当然是要的<br>上一个我们提到<br>节点超时，开始发起选举RPC之前，启动超时，如果到超时结束，还没有选举出一个Leader，那么就把自己的term加一再次发起选举</p>\n<p>这个过程中有两个事件需要一些条件的同步</p>\n<ul>\n<li>超时线程：没有收到Leader的信息和其他节点的选举信息，就执行，也就是心跳有更新</li>\n<li>接收vote线程：收到Leader和其他节点的信息，还在超时未完成状态，就更新心跳信息</li>\n</ul>\n<p>如果分为两个方法的话，最简单的就是给整个方法都加锁<br>但是这样锁的粒度太大了，能不能把条件抽象出来呢</p>\n<p>我想的是对Node的状态进行cas的修改<br>超时线程，首先判断心跳有没有更新，如果有更新就不进行选举，如果没有更新，就加锁的对NodeStatus进行CAS更新，从Follower更新到Pre_Candidate<br>接收Vote线程，首先对NodeStatus进行CAS的更新，从Follower更新到Follower，然后更新心跳时间<br>我们分析两个线程的流程<br>超时线程</p>\n<ul>\n<li>1.判断心跳有没有更新</li>\n<li>2.NodeStatus从Follower更新到Pre_Candidate</li>\n</ul>\n<p>接收Vote线程</p>\n<ul>\n<li>3.首先对NodeStatus进行CAS的更新，从Follower更新到Follower</li>\n<li>4.更新心跳时间</li>\n</ul>\n<p>如果不加锁，流程从3 - 1 - 2 - 4就出问题了</p>\n<p>这个思路很麻烦</p>\n<p>我们再换个思路</p>\n<p>超时线程进行vote的时候，需要对term进行+1<br>接收Vote线程，如果成功接收其他节点的信息维持Follower的话，那么对面的term肯定比自己大的，那么也就是需要对Term进行加1</p>\n<p>所以我们对Term进行cas操作，谁成功了谁进行操作</p>\n<h3 id=\"PreVote\"><a href=\"#PreVote\" class=\"headerlink\" title=\"PreVote\"></a>PreVote</h3><p>其实论文中并没有很直观的提到PreVote的阶段<br>需要PreVote的原因也不复杂，可以百度一下。</p>\n<h3 id=\"VoteFor可以进行修改吗\"><a href=\"#VoteFor可以进行修改吗\" class=\"headerlink\" title=\"VoteFor可以进行修改吗\"></a>VoteFor可以进行修改吗</h3><p><code>Vote</code>阶段<br>假设这样一种场景：<br>我们有节点1 2 3<br>2最后启动<br>1，3同时超时，且3的请求先到2<br>3，term = 1，2投票给他，1拒绝，于是3变成leader<br>1，term=1，2拒绝了他，3也拒绝了他</p>\n<p>这个时候Term2其实已经有Leader了，是3，那么1也要变成Follower<br>这个时候1收到HeartBeat就要把自己变成Follower<br>那么这里的1的Term=1的votedfor其实已经设置为自己了<br>所以VotedFor还是可以进行修改的  </p>\n<h3 id=\"Leader发现更高任期的Server\"><a href=\"#Leader发现更高任期的Server\" class=\"headerlink\" title=\"Leader发现更高任期的Server\"></a>Leader发现更高任期的Server</h3><p>这种情况也是会发现的，就是Leader进行了STW的GC，然后其他的节点进行了超时选举，选出了Leader。<br>这种时候，原来的Leader的GC结束，进行进行AppendLogRequest，就会发现更高任期的Server<br>这种情况直接自己变成Follower就行</p>\n<h3 id=\"日志比较的原则\"><a href=\"#日志比较的原则\" class=\"headerlink\" title=\"日志比较的原则\"></a>日志比较的原则</h3><p><a href=\"https://zhuanlan.zhihu.com/p/32052223\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/32052223</a><br>日志比较的原则是，如果本地的最后一条log entry的term更大，则term大的更新，如果term一样大，则Log Index更大的更新</p>\n<h3 id=\"选举模型\"><a href=\"#选举模型\" class=\"headerlink\" title=\"选举模型\"></a>选举模型</h3><p>5个节点中，如果有两个节点同意，那么就可以成为Leader<br>但是反过来说，如果3个节点拒绝了，那么就不能成为Leader</p>\n<p>第一个条件我们可以使用Latch<br>第二个条件我们还是可以使用Latch</p>\n<p>那么怎么组合这两个Latch呢<br>答案就是<br>所以总而言之，不能用Latch<br>只能加锁唤醒了</p>\n<p>我这里自己实现了一个类专门用来进行选举的计数。</p>\n<h2 id=\"日志复制\"><a href=\"#日志复制\" class=\"headerlink\" title=\"日志复制\"></a>日志复制</h2><h3 id=\"Peer状态管理\"><a href=\"#Peer状态管理\" class=\"headerlink\" title=\"Peer状态管理\"></a>Peer状态管理</h3><p>这个也是我实现的时候遇到的比较棘手的问题<br>一开始也没有什么好的解决思路</p>\n<p>因为每个节点的任务执行的状态在同一个时刻肯定是不一致的，有可能这个快一点，那个慢一点</p>\n<p>也有可能就是有的是正常发送心跳，有的则是刚刚重启需要进行日志的同步  </p>\n<p>但是有一个很明确的点就是每个Follower节点都是不同的状态管理</p>\n<p>同时我们再关注下Leader向Follower节点发送心跳或者AppendLogRequest的频率，会发现每次只能有一个请求过去，当这个请求没有返回或者未超时失败时，是不能够发送下一个Rpc的。</p>\n<p><img src=\"/images/raft/peer.png\" alt=\"\"></p>\n<p>综合以上两点，我的设计就是为每个PeerNode分配一个任务队列，每个PeerNode都有一个单独的线程去拿队列的第一个任务，然后同步的执行。</p>\n<p>当Leader需要进行发送心跳或者AppendLogRequest或者其他的请求时，直接Append一个Task到PeerNode的任务队列就行。</p>\n<h3 id=\"除了AppendLog还要做什么\"><a href=\"#除了AppendLog还要做什么\" class=\"headerlink\" title=\"除了AppendLog还要做什么\"></a>除了AppendLog还要做什么</h3><p>这个也是一个误区，因为心跳的RpcRequest就是一个空的AppendLogRequest<br>我开始的实现中，会判断如果需要Append的Log为空，那么就重置一下选举定时器，然后就直接返回了。  </p>\n<p>这个其实是错误的，我们对每一个AppendLogRequest都要进行日志的比对，把还没有Commit的日志，如果需要，给删了或者覆盖了。  </p>\n<p>这么说可能不太明白，假设这样一种场景。<br>一共三个节点，Node1是Leader，三个节点的日志都是1，2，3，一致的。<br><img src=\"/images/raft/log.png\" alt=\"\">  </p>\n<p>然后发生了网络分区，Leader被隔绝了，但是Node1并不知道，同时客户端的请求也过来了，虽然日志无法commit，但是还是Append到了Node1中。  </p>\n<p>如果网络分区结束，Node2变成了Leader，Node2给Node1发送心跳的时候，这时候就需要根据Log的index和Leader的commitIndex，把4和5删掉。<br>这个BUG我也是找了很久，当初图省事简单也没考虑到这些。  </p>\n<h3 id=\"ReplicatedLogResponse的变更\"><a href=\"#ReplicatedLogResponse的变更\" class=\"headerlink\" title=\"ReplicatedLogResponse的变更\"></a>ReplicatedLogResponse的变更</h3><p>如果是节点Down了之后重启，Leader发现nextIndex对不上的时候，会一步一步的退一个NextIndex把日志发送过去，但是每次都发送后续的全量的Log，开销会很大，所以这里可能可以加一个优化，就是在ReplicatedLogResponse加上自己的lastCommitIndex，让Leader可以一次定位到matchIndex。</p>\n<h2 id=\"成员变更\"><a href=\"#成员变更\" class=\"headerlink\" title=\"成员变更\"></a>成员变更</h2><p>论文中讲了，如果3台节点中突然加了两台，可能出现两个Leader，一个通过新配置，一个通过旧配置。</p>\n<p>所以一般的实现是一次只增加一个节点，这个增加的行为其实是人为控制的。</p>\n<p>这个地方的实现也有一些坑点存在。</p>\n<p>比如论文中写新配置是通过日志的形式进行Append进去的，那么这个日志的格式是啥样的呢。<br>一开始我们定义成了增加节点和删除节点的形式，比如<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClusterChangeLog</span> </span>&#123;</span><br><span class=\"line\">\tType type; <span class=\"comment\">//表示是增加节点还是删除节点</span></span><br><span class=\"line\">\tNodeId nodeId; <span class=\"comment\">//需要增加的节点Id或者删除的节点Id</span></span><br><span class=\"line\">\tEndPoint endPoint; <span class=\"comment\">//需要增加的节点Id或者删除的节点Id的IP和端口地址</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>像这种形式的日志进行Append，但是其实是不行的。</p>\n<p>我们需要的Log要包含新的集群的所有的节点信息，是否是删除还是增加，删除还是增加的节点信息由节点的日志模块自己去解析。<br>所以正确的形式应该是这样<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClusterChangeLog</span> </span>&#123;</span><br><span class=\"line\">\tList&lt;NodeConfig&gt; nodeConfigs;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>为什么说第一种的形式是行不通的或者说实现起来有BUG呢？<br>主要的问题还是在要新增的那个节点上，</p>\n<ul>\n<li>首先新增的节点会有个像Leader获取日志的情况，在获取日志的时候，新增的节点还不属于集群，也就是说，在日志中并没有体现，除了Leader节点，其他的follower节点并不知道该节点的存在。也就是说，我们在开启新增的节点的时候，是不能够将现有的集群的配置写给他启动的，不然就自动连接到其他的节点上去了。</li>\n<li>第二种情况就是，如果我们把当前的集群配置写给新增的那个节点，然后启动它，再把新的集群配置写给Leader，在Leader还没发送时，Leader挂了，那么这个新增的节点咋办呢，能办也能办，但是搞起来会很复杂</li>\n</ul>\n<p>所以我们需要在启动新的节点时，不给它写当前的集群的配置，然后把新增的集群信息写给Leader，Leader也不会立即写日志，而是会进行日志的同步，</p>\n<ul>\n<li>如果日志同步的过程中，Leader挂了，那么没关系，因为新的配置还没写日志，挂了就人为的再写给新的Leader就行，不会影响当前的集群</li>\n<li>日志同步结束之后，把日志进行Append，然后发送给所有的节点，包括新增的节点，那么即使这中间Leader挂了，因为集群更改日志是只要Append就生效的，按照日志最新的才能当前Leader的原则，新的Leader出现之后，会把更改日志再同步到其他的节点，包括新增的节点。</li>\n</ul>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>好的，代码写完了，那么你怎么测试你的代码的正确性呢。<br>这个是我当初头疼的一点，没什么办法进行测试，我到底有没有写对。</p>\n<p>首先这是个分布式的应用，我们除了模拟分布式的环境，还要模拟网络的各种情况，这些肯定不是我们真实模拟硬件和网络情况的，所以肯定要侵入代码的。<br>但是这种需要侵入代码的方法，没有一个方法论在里面的话很容易写乱。</p>\n<p>这里我参考了MIT6.824的课程代码<br><a href=\"https://github.com/chaozh/MIT-6.824/blob/master/src/raft/test_test.go\" target=\"_blank\" rel=\"noopener\">MIT-6.824/blob/master/src/raft/test_tes</a> </p>\n<p>这里模拟了诸多情况</p>\n<ul>\n<li>Leader断网</li>\n<li>Leader断网又恢复</li>\n<li>集群整体掉线恢复</li>\n<li>网络分区</li>\n</ul>\n<p>等诸多情况</p>\n","categories":["分布式"],"tags":["raft"]},{"title":"HotSpot原理指南-基本知识","url":"https://blog.lovezhy.cc/2019/07/26/HotSpot原理指南-基本知识/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>作为写了好几年Java的人，自然想去深入了解一下JVM的构造，它的具体实现。</p>\n<p>Clone了代码，运行了起来，看了《HotSpot实战》和《揭秘Java虚拟机-JVM设计原理与实现》，但是能力一般，水平有限，对JVM还是知之甚少，发现继续研究下去将是一种苦修，要做好看很久代码都毫无进展的准备。但是本人志不在此，还是想去研究分布式与数据库，精力有限，只有暂且放弃JVM的深入研究。</p>\n<p>如此直接放弃还是有点可惜，虽然目前学到的不成体系，但是还是想写一篇Blog记录一下。</p>\n<p>所以此博客是上文提到的两本书的摘要+自己的一些学习理解，内容会很散，同时为了省力，摘要部分不特别标出。</p>\n<a id=\"more\"></a>\n<h2 id=\"源码目录\"><a href=\"#源码目录\" class=\"headerlink\" title=\"源码目录\"></a>源码目录</h2><p>HotSpot源码目录较多，有几个是比较重要的</p>\n<ul>\n<li>/c1 =&gt; 客户端解释器</li>\n<li>/classfile =&gt; Class文件解析</li>\n<li>/gc =&gt; gc相关</li>\n<li>/interpreter =&gt; C++解释器和模板解释器都在里面</li>\n<li>/oops =&gt; Java的类模型，也就是OOP-KLASS模型</li>\n<li>/opto =&gt; c2解释器，也就是服务端解释器</li>\n<li>/prims =&gt; 供外部程序访问JVM的通道，比如JNI，Perf，JMX等</li>\n<li>/runtime =&gt; 运行时模块，包括frame，thread，VMOptions等</li>\n<li>/shark =&gt; 基于LLVM实现的JIT编译器</li>\n</ul>\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><p>JMM开头的方法，和Memory没关系，指的是Management的意思</p>\n<h2 id=\"命令行选项\"><a href=\"#命令行选项\" class=\"headerlink\" title=\"命令行选项\"></a>命令行选项</h2><p>JRockit JVM中命令行选项分为三种</p>\n<ul>\n<li>系统属性，-D开头</li>\n<li>标准选项，-X,-Xms其实我觉得全拼是-X:memory-start?</li>\n<li>非标准选项,-XX</li>\n</ul>\n<h2 id=\"Class文件解析\"><a href=\"#Class文件解析\" class=\"headerlink\" title=\"Class文件解析\"></a>Class文件解析</h2><p>Class文件的解析的代码都在/classfile目录下</p>\n<p><img src=\"/images/JVM杂记/class文件格式.jpg\" alt=\"\"></p>\n<p>HotSpot构建了一个叫systemDictionary的字典，结构是<code>[class name,class loader] -&gt; class</code>，用来存储系统中已经加载的类，从这个Map中我们可以看到一些类加载器的条件，双亲委派的概念。</p>\n<p>在classFileParser.cpp中，宏定义了Class文件开头的MagicWord和Java_Version的对应关系<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> JAVA_CLASSFILE_MAGIC              0xCAFEBABE</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> JAVA_MIN_SUPPORTED_VERSION        45</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> JAVA_MAX_SUPPORTED_VERSION        53</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> JAVA_MAX_SUPPORTED_MINOR_VERSION  0</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> JAVA_1_5_VERSION                  49</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> JAVA_6_VERSION                    50</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> JAVA_7_VERSION                    51</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> JAVA_8_VERSION                    52</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> JAVA_9_VERSION                    53</span></span><br></pre></td></tr></table></figure></p>\n<p>文件解析后，各个Class文件是独立的，而各个类之间的联系其实是通过符号引用来串联在一起，JVM在进行符号引用的解析之后，就可以进行类型的相互引用和方法调用</p>\n<p>JVM的链接分为三个部分：</p>\n<ul>\n<li>验证：对方法进行一系列的检查，方法的访问控制，参数和静态类型检查等</li>\n<li>准备：为类静态变量分配内存空间，但是不会初始化值</li>\n<li>解析：将常量池中的4类符号引用转换为直接引用(用常量池项表示的字符串 -&gt; 实际内存地址)<ul>\n<li>类</li>\n<li>接口</li>\n<li>字段</li>\n<li>类方法和接口方法</li>\n</ul>\n</li>\n</ul>\n<p>链接完之后就是进行初始化，也就是调用static {}方法</p>\n<p>对于方法的链接，运用的是链接解析器，LinkResolver对方法进行解析和查找<br>对一个方法进行解析时，需要对instanceKlass中的method表进行查找，找到目标方法后转换成MethodHandle类型句柄返回<br>对方法的权限检查（public，private这种）是在找到之后进行</p>\n<h2 id=\"runtime模块与Shutdown-Hook\"><a href=\"#runtime模块与Shutdown-Hook\" class=\"headerlink\" title=\"runtime模块与Shutdown Hook\"></a>runtime模块与Shutdown Hook</h2><p>runtime模块主要定义HotSpot运行时数据</p>\n<p><code>frame.hpp</code>定义了栈帧的结构，包括Java栈帧，C栈帧。</p>\n<p><code>destroy_vm</code>的退出流程中，会运行JVM层的关闭钩子函数。<br>这里的关闭钩子函数就是提到的<code>Runtime.getRuntime().addShutdownHook();</code><br>书中提到的File.deleteOnExit方法，也是调用的这个，但是获取方式看起来不太一样<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sun.misc.SharedSecrets.getJavaLangAccess()</span><br><span class=\"line\">            .registerShutdownHook(<span class=\"number\">2</span> <span class=\"comment\">/* Shutdown hook invocation order */</span>,</span><br><span class=\"line\">                <span class=\"keyword\">true</span> <span class=\"comment\">/* register even if shutdown in progress */</span>,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                       runHooks();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br></pre></td></tr></table></figure></p>\n<p>而且参数也是不止一个，看起来还可以指定顺序<br>但是不管咋样，最后两种方式其实都是调用的<code>Shutdown.add</code>方法<br>Runtime中的调用<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shutdown.add(<span class=\"number\">1</span> <span class=\"comment\">/* shutdown hook invocation order */</span>,</span><br><span class=\"line\">               <span class=\"keyword\">false</span> <span class=\"comment\">/* not registered if shutdown in progress */</span>,</span><br><span class=\"line\">               <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                       runHooks();</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           );</span><br></pre></td></tr></table></figure></p>\n<p>看Order的参数来说的话，其实Runtime的优先级更高，而File.deleteOnExit的优先级第二。</p>\n<h2 id=\"synchronized实现\"><a href=\"#synchronized实现\" class=\"headerlink\" title=\"synchronized实现\"></a>synchronized实现</h2><p>synchronized方法或者代码块，会生成两个特殊的字节码  </p>\n<ul>\n<li>monitorenter  </li>\n<li>monitorexit<br>对于解释器而言，具体的执行逻辑在<br><code>intercepter/bytecodeIntercepter.cpp 1803行 JDK9</code><br>也就是<code>CASE(_monitorenter)</code>中<br>具体的实现分为偏向锁，轻量级锁，重量级锁<br>最后会调用<code>InterpreterRuntime::monitorenter</code>方法，这个方法定义在<code>interpreter/interpreterRuntime.cpp</code>中<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IRT_ENTRY_NO_ASYNC(<span class=\"keyword\">void</span>, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))</span><br><span class=\"line\">\t...</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (PrintBiasedLockingStatistics) &#123;</span><br><span class=\"line\">    Atomic::inc(BiasedLocking::slow_path_entry_count_addr());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Handle h_obj(thread, elem-&gt;obj());</span><br><span class=\"line\">  assert(Universe::heap()-&gt;is_in_reserved_or_null(h_obj()),</span><br><span class=\"line\">         <span class=\"string\">\"must be NULL or an object\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (UseBiasedLocking) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Retry fast entry if bias is revoked to avoid unnecessary inflation</span></span><br><span class=\"line\">    ObjectSynchronizer::fast_enter(h_obj, elem-&gt;lock(), <span class=\"literal\">true</span>, CHECK);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    ObjectSynchronizer::slow_enter(h_obj, elem-&gt;lock(), CHECK);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> ...</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>仔细看会使用到<code>ObjectSynchronizer</code>的两个方法，如果使用了偏向锁，那么就是<code>fast_enter</code>，如果不允许偏向锁，那么就是<code>slow_enter</code></p>\n<p>在<code>slow_enter</code>的最后，如果还是不行，就会进入锁膨胀的状态，也就是重量级锁</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjectSynchronizer::inflate(THREAD,</span><br><span class=\"line\">                            obj(),</span><br><span class=\"line\">                            inflate_cause_monitor_enter)-&gt;enter(THREAD);</span><br></pre></td></tr></table></figure>\n<p>这个时候就要用到<code>ObjectMonitor</code>类中的方法，最后还会涉及到<code>ObjectWaiter</code>类，这个类就是设计了一个链表，类似于<code>ReententLock</code>中的等待链表。</p>\n<p>最后还是很好奇最终的互斥锁到底是怎么实现的，代码在<code>runtime/mutex.cpp</code>中，仔细看了一下，并没有使用到c语言中的Mutex库，最终还是依赖于CAS实现的。</p>\n<p>其实说到底，最后所有的锁都是基于CAS + 链表。</p>\n<p>这里有一个概念上的观念，就是<a href=\"https://stackoverflow.com/questions/1898374/does-the-jvm-create-a-mutex-for-every-object-in-order-to-implement-the-synchron\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/1898374/does-the-jvm-create-a-mutex-for-every-object-in-order-to-implement-the-synchron</a>该问题中提到的</p>\n<blockquote>\n<p>Ask: Using only CAS instructions, how do you get the OS scheduler to put a thread to sleep? </p>\n<p>Answer: you don’t. You only use CAS to acquire / release the lock in the uninflated / uncontended case. If contention is detected, the locking/unlocking code would then do the relevant thread scheduling syscalls … or whatever.</p>\n</blockquote>\n<p>如果你查看ReentrentLock的最后将等待的线程放入等待链表中，对线程调用的是<code>LockSupport.park()</code>方法，这是一个native方法，要去源码中找实现，在<code>hotspot/src/os/linux/vm/os_linux.cpp</code>中，可以看到这里为了让线程能够进入os的调度，也就是放弃CPU资源，还是需要进行<code>pthread_cond_wait</code>的调用的。最后对线程的唤醒，还是需要进行notify的。</p>\n<p>在synchronized的底层实现中，最后也是进行park，调用的是<code>os::PlatformEvent::park</code>方法，使用的类是</p>\n<p><code>class ParkEvent : public os::PlatformEvent</code></p>\n<p>所以，(CAS+链表+pthread_mutex)才是真正的实现机制。</p>\n<p>而如果是多线程争用的情况，其实最终的目的还是要保证原子释放CPU资源。</p>\n<p>说了一堆，其实核心在锁的实现上，基本都放弃了直接使用pthread_mutex的方法，而是运用<strong>CAS的方式进行自旋</strong>，而pthread_mutex的使用仅仅是为了将线程进行操作系统的重新调度。</p>\n<p>参考文章：</p>\n<ul>\n<li><a href=\"https://github.com/farmerjohngit/myblog/issues/15\" target=\"_blank\" rel=\"noopener\">https://github.com/farmerjohngit/myblog/issues/15</a></li>\n<li><a href=\"https://www.jianshu.com/p/c5058b6fe8e5\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/c5058b6fe8e5</a></li>\n</ul>\n<p>偏向锁<br>这个名词看名字不是那么容易理解，在JRockit中描述为延迟解锁</p>\n<p><img src=\"/images/JVM杂记/锁转换.png\" alt=\"\"></p>\n<blockquote>\n<p>在上图中，有三种锁类型，其中胖锁和瘦锁在之前中介绍过，这里新增了延迟锁，用来解释 锁在大部分情况下都只作用于线程局部场景下的情况。<br>正如之前介绍过的，对象首先是未加锁状态的，然后线程 T1 执行 monitorenter 指令，使 之进入延迟加锁状态。但如果线程 T1 在该对象上执行了 monitorexit 指令，这时系统会假装 已经解锁了，但实际上仍是锁定状态，锁对象的锁字中仍记录着线程 T1 的线程 ID。在此之后， 线程 T1 如果再执行加锁操作，就不用再执行相关操作了。<br>如果另一个线程 T2 试图获取同一个锁，则之前所做“该锁绝大部分被线 T1 程使用”的假 设不再成立，会受到性能惩罚，将锁字中的线程 ID 由线程 T1 的 ID 替换为线程 T2 的。如果这 种情况经常出现，那么可能会禁用该对象作为延迟锁，并将该对象作为普通的瘦锁使用。假设这 是线程 T2 第一次在该对象上调用 monitorenter 指令，则程序会进入瘦锁控制流程。在上图中， 被禁用于延迟解锁的对象用星号(*)做了标记。此时，当线程 T3 试图在某个已被禁用于延迟解 锁的对象上加锁，如果该对象还未被锁定，则此时仍会使用瘦锁。<br>使用瘦锁时，如果竞争激烈，或者在锁对象上调用了 wait 方法或 notify 方法，则瘦锁会 膨胀为胖锁，需要等待队列来处理。从图中可以看到，处于延迟解锁状态的对象直接调用 wait 方法或 notify 方法的话，也会膨胀为胖锁</p>\n</blockquote>\n<p>单例模式的双重校验锁的实现其实是有问题的，加了volatile能解决问题，但是会带来略微的性能问题</p>\n<h2 id=\"内存-OOP\"><a href=\"#内存-OOP\" class=\"headerlink\" title=\"内存 OOP\"></a>内存 OOP</h2><p>虚拟机中内存空间按照内存的用途，可以划分为<strong>堆和非堆</strong></p>\n<ul>\n<li>堆：用于对象的分配空间</li>\n<li>非堆：包括方法区和Code Cache</li>\n</ul>\n<p>Perf Data区域，有perfMemory模块管理<br>为了支持虚拟机性能监控，在虚拟机中开辟了一块共享内存，专门存储一些性能指标<br>虚拟机使用共享内存方式向外部进程提供了一种通信手段，允许外部监控进程attach至虚拟机进程，从共享内存中读取这些perf Data</p>\n<p>oop-klass模型<br>这个感觉是比较重要的点了<br>还是一个老生长谈的问题，why的问题<br>运用C++的基础模型去实现有没有问题呢？<br>其实我感觉是没有问题的，但是相对于C++的模型，Java这种方式，其实主要是更省内存。<br>同一个类的所有对象维护同一个VTable，其次就是和C++的多态方式不同，Java是模型每一个函数都是可以被子类覆盖的，而C++的只有是虚函数才能，换句话说，Java里面每个函数都是虚函数。<br>虚函数暴增的情况下，显然这种方式更加的省内存。<br>//fixMe</p>\n<blockquote>\n<p>而且我感觉还和Java的类加载机制有关，因为Java的符号引用转换为直接引用的解析过程，是可以再运行中才进行的，如果父类的方法被动态改变了，函数的地址肯定也需要进行相应的改变，而现有子类的对于这个方法的指向，只要改变一次Klass就行。</p>\n</blockquote>\n<p>在该模型中，Java的method也作为一种OOP存在</p>\n<p><img src=\"/images/JVM杂记/markword.jpg\" alt=\"\"></p>\n<p>实例对象的创建 分为快速分配和慢速分配  </p>\n<ul>\n<li>快速分配就是必须是该类已经被加载和正确解析 因为类的解析，就是符号引用变直接引用的过程不一定就是ClassLoader的时候进行，HotSpot是类第一次被使用的时候解析<br>快速分配就是可以在TLAB，就是线程缓存中分配，而不必先分配到Eden区，如果开启了TLAB选项</li>\n<li>慢速分配就是需要先解析，然后在Eden区分配</li>\n</ul>\n<p>对象在内存中的布局，也就是OOP对象，可以分为连续的两部分，也就是MarkWord对象头和实例数据部分<br>而在Klass模型中，存储着对象的每个变量在实例数据部分的偏移量和长度</p>\n<p>Klass中，有一个和Java类对应的mirror成员</p>\n<p>JVM为每个线程分配一个PC寄存器，在真实机器中，往往提供一个PC寄存器专门用来保存程序运行的指令在内存中的位置，在HotSpot的实现中，为每个线程分配了一个字长的存储空间，以实现类似硬件级的PC寄存器<br>如果当前执行方法不是本地方法，那么PC寄存器就保存的是JVM正在执行的字节码指令的地址，如果是本地方法，那么PC寄存器的值是未定义的，因为本地方法的执行依赖硬件PC寄存器，其值是由操作系统维护</p>\n<p>Java虚拟机栈的作用：存储方法执行中的局部变量，中间演算结果以及方法返回结果</p>\n<p>JVM允许Java虚拟机栈被实现为固定大小和动态收缩</p>\n<ul>\n<li><p>固定大小，顾名思义，如果超过，抛出StackOverflowError异常</p>\n</li>\n<li><p>动态扩展：OOM异常</p>\n</li>\n</ul>\n<p>虚拟机规范对方法区实现的位置并没有明确要求，在HotSpot中，位于永久代中。<br>HotSpot会收集方法区，主要是常量池的收集和类的卸载<br>在HotSpot内部，Java方法也是由一个内部对象表示的，对象的类型是methodOop，是Java方法在JVM内部的表示方式<br>methodOop内部有指向所在类的运行时常量池的指针<br>methodOop内部有个_constMethod指针，类型是constMethodOop，用来存储和定位方法中的只读数据，如字节码，方法引用，方法名，方法签名，异常表等信息</p>\n<p>Perf Data区域，有perfMemory模块管理<br>为了支持虚拟机性能监控，在虚拟机中开辟了一块共享内存，专门存储一些性能指标<br>虚拟机使用共享内存方式向外部进程提供了一种通信手段，允许外部监控进程attach至虚拟机进程，从共享内存中读取这些perf Data</p>\n<p>Java类的生命周期的第一个阶段，加载，就是为了在JVM内部创建一个与Java类结构对等的数据对象</p>\n<p>如果想要破坏双亲委派的机制，自定义类加载器加载核心类库，还是会被拒绝，因为在defineClass方法中，会提供保护，对类名为Java开头的类，直接抛出异常</p>\n<p>同样的，类型转换需要两个类都是同一个类加载器加载的，不然会报错，上次那个Dubbo的问题就这样，报错是两个一样的类，无法进行cast</p>\n<h2 id=\"GC\"><a href=\"#GC\" class=\"headerlink\" title=\"GC\"></a>GC</h2><p>GC的几个策略</p>\n<ul>\n<li>GC工作线程：串行还是并行</li>\n<li>GC工作线程和应用线程：并发执行还是暂停应用</li>\n<li>基本收集算法：压缩，非压缩还是拷贝</li>\n</ul>\n<p>吞吐量：应用程序运行时间/(应用程序运行时间 + 垃圾收集时间)</p>\n<p>HotSpot每个线程在Eden区都有自己的一小块区域，用于TLAB分配<br>通常情况下，系统中有大量连续的内存块可以用来进行分配的话，碰撞指针算法进行分配，效率很高。思路就是记录上一次分配对象的位置，当有新对象要分配的时候，只需要一次移动位置就可以完成内存的分配<br>在TLAB中进行分配，也就是碰撞指针(bump-the-pointer)分配，效率很高</p>\n<p>不然就需要全局锁进行在Eden区分配</p>\n<p>还有另外一种优化，叫栈上分配</p>\n<p>栈上分配需要对方法的对象进行逃逸分析<br>如果局部变量的作用域仅限于方法内部，则JVM直接在栈帧内分配对象，避免在堆中分配<br>但是这里引用R大的话</p>\n<blockquote>\n<p>嗯但是Oracle/Sun的HotSpot VM从来没在产品里实现过栈上分配，而只实现过它的一种特殊形式——标量替换（scalar replacement）。这俩是不一样的喔。栈上分配还是要分配完整的对象结构，只不过是在栈帧里而不在GC堆里分配；标量替换则不分配完整的对象，直接把对象的字段打散看作方法的局部变量，也就是说标量替换后就没有对象头了，也不需要把该对象的字段打包为一个整体。<br><a href=\"https://book.douban.com/people/RednaxelaFX/annotation/25847620/\" target=\"_blank\" rel=\"noopener\">https://book.douban.com/people/RednaxelaFX/annotation/25847620/</a></p>\n</blockquote>\n<p>有个类叫GCCause，里面定义了一些枚举，就是引起GC的一些情况<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Cause &#123;</span><br><span class=\"line\"><span class=\"comment\">/* public */</span></span><br><span class=\"line\">_java_lang_system_gc,</span><br><span class=\"line\">_full_gc_alot,</span><br><span class=\"line\">_scavenge_alot,</span><br><span class=\"line\">_allocation_profiler,</span><br><span class=\"line\">_jvmti_force_gc,</span><br><span class=\"line\">_gc_locker,</span><br><span class=\"line\">_heap_inspection,</span><br><span class=\"line\">_heap_dump,</span><br><span class=\"line\">_wb_young_gc,</span><br><span class=\"line\">_wb_conc_mark,</span><br><span class=\"line\">_wb_full_gc,</span><br><span class=\"line\">_update_allocation_context_stats_inc,</span><br><span class=\"line\">_update_allocation_context_stats_full,</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* implementation independent, but reserved for GC use */</span></span><br><span class=\"line\">_no_gc,</span><br><span class=\"line\">_no_cause_specified,</span><br><span class=\"line\">_allocation_failure,</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* implementation specific */</span></span><br><span class=\"line\"></span><br><span class=\"line\">_tenured_generation_full,</span><br><span class=\"line\">_metadata_GC_threshold,</span><br><span class=\"line\">_metadata_GC_clear_soft_refs,</span><br><span class=\"line\"></span><br><span class=\"line\">_cms_generation_full,</span><br><span class=\"line\">_cms_initial_mark,</span><br><span class=\"line\">_cms_final_remark,</span><br><span class=\"line\">_cms_concurrent_mark,</span><br><span class=\"line\"></span><br><span class=\"line\">_old_generation_expanded_on_last_scavenge,</span><br><span class=\"line\">_old_generation_too_full_to_scavenge,</span><br><span class=\"line\">_adaptive_size_policy,</span><br><span class=\"line\"></span><br><span class=\"line\">_g1_inc_collection_pause,</span><br><span class=\"line\">_g1_humongous_allocation,</span><br><span class=\"line\"></span><br><span class=\"line\">_dcmd_gc_run,</span><br><span class=\"line\"></span><br><span class=\"line\">_last_gc_cause</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>收集算法</p>\n<ul>\n<li>标记-清除 Mark-Sweep</li>\n<li>复制算法 Copying</li>\n<li>标记-压缩算法 Mark-Compact</li>\n</ul>\n<p>堆的类型</p>\n<p>不同的收集器可能对应着不同类型的堆</p>\n<p><code>CollectedHeap &lt;- ParallelScavengeHeap</code></p>\n<p><code>CollectedHeap &lt;- SharedHeap &lt;- G1CollectedHeap</code></p>\n<p>CMS的创新之处在于把标记分为两个阶段，初始标记和并发标记</p>\n<p>但是引入了新的缺点，就是并发收集失败的问题，在并发标记时，内存使用过度，只有STW，采取线性标记和收集</p>\n<p>而且只能由于并发清除的问题，只能进行标记-清除，将产生内存碎片，而新生代由于其特殊性，将产生更多的内存碎片，所以CMS在新生代并不适用，只运用在老年代</p>\n<p>安全点</p>\n<blockquote>\n<p>由于JVM系统运行期间的复杂性，不可能做到随时暂停，因此引入了安全点（safepoint）：程序只有在运行到安全点的时候，才准暂停下来。HotSpot采取主动中断的方式，让执行线程在运行时轮询是否需要暂停的标识，若需要则中断挂起。</p>\n</blockquote>\n<p>//fixme<br>其实我觉得这里说的不对，应该不是不可能做到随时暂停，而是随时暂停的消耗太大了，因为后面也写到是主动中断的方式，如果在每个字节码后面都插入check是否需要中断的代码，则消耗确实是太大了<br>参考文章：<a href=\"https://www.jianshu.com/p/c79c5e02ebe6\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/c79c5e02ebe6</a></p>\n<p>G1收集器<br>G1重新定义了堆空间，打破了原有的分代模型，将堆划分为一个个区域<br>在进行收集的时候，不必在全堆的范围内进行，好吃就是带来了停顿时间的可预测<br>G1会通过一个合理的计算模型，计算出每个region的收集成本并量化</p>\n<p>分代模型的写屏障<br>这个是比较重要的一个，一开始是比较难理解的<br><img src=\"/images/JVM杂记/写屏障.png\" alt=\"\"><br>我们从正常的新生代的GC开始说，从图中看到，如果只从GCRoot出发，其实是扫描不到F的，如果扫描不到，说明F是需要被清除的<br>但是其实F被老年代的E所引用，也就是说他不能被清除<br>这就是说，GCRoot需要包含新生代中的被老年代引用的对象。<br>但是如果要实现这个功能，可能要扫描所有的老年代对象了，如果每次进行新生代的GC时都扫描老年代，那么分代GC的意义就不是那么明显了<br>所以这里用了一个写屏障，底层使用的是卡表的概念进行标记。<br>简单的说就是每当有老年代对象引用新生代对象时，就把老年代对象所在的位置标记一下，然后进行新生代GC时，把老年代标记了的位置进行扫描进行，而不用全部扫描<br><a href=\"https://juejin.im/post/5c39920b6fb9a049e82bbf94\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5c39920b6fb9a049e82bbf94</a></p>\n<p>压缩指针<br>指针的大小一般是平台的决定的，但是在64位的机器上，但是还是可以进行一些优化，优化的基础是内存的申请是一下子一大片连续的内存<br>举个例子就是在64位机器上，如果我们要申请的一块内存小于4G，那么完全可以只用32位就可以进行指针的保存</p>\n<p>JRockit里面提到了一种伪优化<br>就是对象池，有人认为，保留一个存活对象池来重新使用已创建的对象可以提升垃圾回收的性能</p>\n<blockquote>\n<p>但实际上，对象池不仅增加了应用程序的复杂度，还很容易出错。对于现代垃圾收集器来说，使用 java.lang. ref.Reference 系列类实现缓存，或者直接将无用对象的引用置为 null 就好了，不用多操心。<br>此外，长期持有无用的对象其实是个大麻烦，分代式垃圾回收器可以很好地处理临时对象，但如果这些临时对象被人为保存下来，无法被回收掉的话，最终就会被提升到老年代，并将其挤满。</p>\n</blockquote>\n<h2 id=\"栈帧\"><a href=\"#栈帧\" class=\"headerlink\" title=\"栈帧\"></a>栈帧</h2><p>如果函数要返回整数或者指针的话，寄存器%eax可以用来返回值<br>寄存器eax，edx，ecx被划分为调用者保存<br>而寄存器ebx，esi，edi寄存器划分为被调用者保存<br>栈是以帧为单位保存当前线程的运行状态<br>当线程执行一个方法时，它会跟踪当前常量池<br>栈帧存储了方法的局部变量表，操作数栈，动态链接和方法返回地址</p>\n<p><img src=\"/images/JVM杂记/栈帧结构.png\" alt=\"\"><br><img src=\"/images/JVM杂记/解释器帧.png\" alt=\"\"></p>\n<p>局部变量表</p>\n<ul>\n<li>局部变量表被组织为一个字长为单位，从0开始计数的数组</li>\n<li>存储时以slot为单位，一个slot一般为32位，short，byte，char在存入表中要先转换为int</li>\n<li>一般会存储的类型除了基本类型和引用，还有returnAddress类型，它指向了一个字节码指令的地址</li>\n<li>参数值到参数变量列表的传递依赖于局部变量表</li>\n<li>第0位索引的slot默认是用于传递方法所属对象实例的引用</li>\n</ul>\n<p>局部变量表的描述</p>\n<ul>\n<li>start_pc，length：描述局部变量的作用域</li>\n<li>name_index：描述局部变量名的常量池索引，对应Class文件中的Name</li>\n<li>descriptor_index:描述局部变量类型的常量池索引，对应Class文件中的Signature</li>\n<li>index：描述局部变量在当前栈帧的局部变量索引</li>\n</ul>\n<p>局部变量表的大小在编译期就可以确定，在Code属性中明确了大小</p>\n<p>操作数栈</p>\n<ul>\n<li>操作数栈的深度由Code属性max_stacks在编译期确定</li>\n<li>和局部变量表不同的是，操作数栈不是通过索引来访问的，而是通过入栈和出栈来访问</li>\n<li>还有一个比较重要的点，就是操作数栈和下一个栈帧的参数列表是可以复用的，不然我们在HSDB调试操作数栈的时候看起来会比较迷惑</li>\n</ul>\n<p>异常表<br>为了处理Java方法中的异常情况，帧数据区还必须保存一个对此方法异常表的引用，当异常抛出时，JVM给catch块中的代码<br>如果没发现，方法立即终止，然后JVM用帧区数据的信息回复发起调用的方法的帧，然后再发起调用方法的上下文重新抛出同样的异常</p>\n<p>Hotspot解释器执行引擎在执行字节码时，实际上是执行一段已经被编译成本地机器直接运行的指令<br>在JVM启动期间，解释器模块就会将每个字节码转换成与之等价的机器指令，放在Code Cache中<br>所以HotSpot充分利用了计算机的资源，包括寄存器</p>\n<h2 id=\"JavaCalls\"><a href=\"#JavaCalls\" class=\"headerlink\" title=\"JavaCalls\"></a>JavaCalls</h2><p>JavaCalls，说白了就是JVM调用Java方法</p>\n<p>然后CallStub，是一个函数指针，在调用Java程序的Main函数时，需要使用这个函数指针</p>\n<p>但是CallStub指向的函数是一个entry_point，是一个例程</p>\n<p>当然这里其实是有歧义的例程在JVM的概念就是提前用机器码写好的函数，而entry_point虽然也是例程，然后它主要突出entry这个词，主要是在方法调用切换时进行调用的例程</p>\n<p>再说回CallStub，它指向的例程，就是为所有Java程序的唯一一个Main方法构造他的前一个栈帧</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>最直接的就是参数args，在栈中需要使用CallStub指向的例程构建好，然后CallStub的函数指针的函数中，还需要传入一个entry_point，这个就是在进行Java函数调用的时候，需要进行寄存器的保存等之类的操作，而这些操作由不同的entry_point来操作。</p>\n<p>//fix me</p>\n<p>个人理解就是在各种invoke的字节码指令中，会频繁的调用这些不同的entry_point。</p>\n<h2 id=\"常量池\"><a href=\"#常量池\" class=\"headerlink\" title=\"常量池\"></a>常量池</h2><p>其实JVM中常量池有两种不同的概念<br>第一种是Class文件的常量池<br>虚拟机在创建一个类或者接口时候，按照Class文件的定义创建相应的常量池，也就是Class文件中的constant_pool表。<br>第二种是方法区中的常量池，虚拟机在对类进行解析和连接之后，将在内存中为该类生成一套运行时常量池，常量池在运行时动态分配<br>第三种是代码中我们提到的常量池，也就是String常量池，JVM中创建了一个String的Table</p>\n<p>参考<a href=\"https://blog.csdn.net/zm13007310400/article/details/77534349\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/zm13007310400/article/details/77534349</a></p>\n<p>那么为什么要有常量池呢<br>Answer：</p>\n<blockquote>\n<p>常量池的出现，解决了JVM定位字段和方法的问题，它在不破坏指令集的简洁性的前提下，仅仅通过少量字节就能定位到目标。<br>更详细的说，以字符串数据aVeryLongFunctionName为例，如果在编译时每次都要重新避免这个字符串的话，那么字节码就谈不上压缩了</p>\n</blockquote>\n<p>但是每次字段或者方法的访问都需要解析常量池项的话，将不可避免的造成性能下降<br>对于类文件的运行时常量池，JVM内还会有它的高速缓冲ConstantPoolCache</p>\n<h2 id=\"解释器\"><a href=\"#解释器\" class=\"headerlink\" title=\"解释器\"></a>解释器</h2><p>HotSpot的解释器分为了两种<br>一种是CPP解释器，也就是最原始的解释器，类似于Case，Case这种形式，文件是intercepter/bytecodeIntercepter.cpp<br>一种是模板解释器，现在默认是这样，这种是在JVM启动时对每一个字节码都进行了当前平台的机器码转换，具体的是维护了一个平台相关TemplateTable，可以在cpu/x86/vm中的templateTable_XX.cpp中找到，相对于CPP解释器，其实这也是一种解释的方法，虽然第一种最终执行的也是C++编译成的机器码，但是模板解释器相对于CPP解释器，机器码是手动写的，可以进行一些优化，比如TOS，还有就是对于取出下一个执行进行运行，也可以直接插入到当前字节码的机器码中</p>\n<p>对于模板解释器的取指令的操作，其实在写在每一个字节码指令的最后。<br>HotSpot在为每一个字节码指令生成其机器逻辑指令时，会同时为该字节码指令生成其取址逻辑</p>\n<p>PC计数器，在x86平台上就是esi寄存器，所以在JVM中并不是完全不使用CPU的寄存器</p>\n<p>面向栈式的指令，可以省去很多的操作数，所以一定程度上也减少了代码体积<br>这话其实不对，因为相对于寄存器式的指令，寄存器式的一个指令就能完成的事，其实栈式需要多个指令</p>\n<p>栈帧重叠<br>就是前面提到的上一个方法的操作数栈可以直接成为下一个方法的参数表</p>\n<p>栈上替换 OSR<br>个人理解就是在一个方法里遇到了Loop非常久的情况，对方法进行了JIT编译，但是由于这个Loop非常长，JIT编译完还未结束，所以为了将当前方法替换到新的栈帧，使用栈上替换<br>具体的解释在R大这儿<br><a href=\"https://www.zhihu.com/question/45910849\" target=\"_blank\" rel=\"noopener\">OSR（On-Stack Replacement）是怎样的机制？</a><br>JRockit没有实现OSR，因为太复杂了</p>\n<p>JIT编译器<br>为什么不直接全部aot编译一下，而是选择了解释+JIT的方式<br>R大这里也回答了[<a href=\"https://www.zhihu.com/question/37389356)(https://www.zhihu.com/question/37389356\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/37389356)(https://www.zhihu.com/question/37389356</a>)<br>我总结一下</p>\n<ul>\n<li>时间开销，aot的启动时间肯定很慢</li>\n<li>空间开销，字节码到机器码会代码膨胀</li>\n<li>编译时机，一些profile的收集对编译有很大的影响<blockquote>\n<p>JIT是一个充满希望的方向，因为它可以搜集到程序在AOT编译时得不到的runtime数据，在优化时，有更多的上下文可以依靠，理论上应该有更好的优化特性</p>\n</blockquote>\n</li>\n</ul>\n<p>在JRockit中，讲了aot其实在90年代就已经出现了，但是这种方式虽然快了很多，但是抛弃了很多Java的动态特性，提到了一个很重要的场景，就是在JSP的应用中，我们知道JSP其实就是b被编译成class文件，做的事也仅仅是疯狂的sout，如果aot一下，效率不会提高太多，但是代码体积会提高很多</p>\n<p>其实aot与全部JIT编译并不是一个概念，一个好的办法是，给JIT的编译加上不同层级的编译，一开始可能是优化不高的，后面收集到profile后再进行深层次的profile</p>\n<p>判断热方法</p>\n<ul>\n<li>counter，但是会降低效率</li>\n<li>基于软件的线程采样，周期性的获取活动线程的上下文</li>\n</ul>\n<p>JVM字节码的表现力其实比Java语言强，所以需要对字节码进行校验，防止一些恶意的技巧</p>\n<h2 id=\"TOS\"><a href=\"#TOS\" class=\"headerlink\" title=\"TOS\"></a>TOS</h2><p>TosState的取值范围为0-8，共计9种</p>\n<ul>\n<li>byte，bool</li>\n<li>char</li>\n<li>short</li>\n<li>int</li>\n<li>long</li>\n<li>float</li>\n<li>double</li>\n<li>object</li>\n<li>void</li>\n</ul>\n<p>最后一种其实就是空，参见R大的笔记，HotSpot实战中写的是tos类型，我还去百度了tos类型是啥类型😓 </p>\n<h2 id=\"VM选项\"><a href=\"#VM选项\" class=\"headerlink\" title=\"VM选项\"></a>VM选项</h2><table>\n<thead>\n<tr>\n<th>配置</th>\n<th>解释</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-XX:UseG1GC</td>\n<td>配置G1收集器</td>\n<td></td>\n</tr>\n<tr>\n<td>-Xint</td>\n<td>配置虚拟机以纯解释方式运行</td>\n<td></td>\n</tr>\n<tr>\n<td>-XX:+MaxFDLimit</td>\n<td>最大文件描述符数量</td>\n<td></td>\n</tr>\n<tr>\n<td>-XX:DisableExplicitGC</td>\n<td>Parallel Scanvenge收集器的配置，屏蔽System.gc()</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Tools\"><a href=\"#Tools\" class=\"headerlink\" title=\"Tools\"></a>Tools</h2><p>实际的性能分析可以查看《HotSpot实战》的5.3小节，讲的很详细</p>\n<ul>\n<li>HSDB：可以用来看JVM的运行时数据，查看线程栈，对象的数据</li>\n<li>jps：查看Java进程信息</li>\n<li>jinfo：</li>\n<li>jmap：</li>\n<li>jhat：</li>\n<li>jstat：</li>\n<li>jstack：</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://book.douban.com/people/RednaxelaFX/annotation/25847620/?start=0\" target=\"_blank\" rel=\"noopener\">RednaxelaFX对《HotSpot实战》的笔记</a><br><a href=\"https://book.douban.com/subject/25847620/\" target=\"_blank\" rel=\"noopener\">HotSpot实战</a><br><a href=\"https://book.douban.com/subject/30394745/\" target=\"_blank\" rel=\"noopener\">JRockit权威指南：深入理解JVM</a><br><a href=\"https://book.douban.com/subject/27086821/\" target=\"_blank\" rel=\"noopener\">https://book.douban.com/subject/27086821/</a></p>\n","categories":["HotSpot"],"tags":["JVM"]},{"title":"Java中FileLock的实现细节","url":"https://blog.lovezhy.cc/2019/03/29/Java中FileLock的实现细节/","content":"<h2 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h2><p>开始看Lucene源代码，找了个最简单的FSLockFactory开始看。<br>然而还是看出了不明白的地方  </p>\n<p>在NativeFSLockFactory的close方法中有这么一段注释</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// <span class=\"doctag\">NOTE:</span> we don't validate, as unlike SimpleFSLockFactory, we can't break others locks</span></span><br></pre></td></tr></table></figure>\n<p>我从网上找到了当初的Bug的讨论帖<br><a href=\"https://issues.apache.org/jira/browse/LUCENE-6507\" target=\"_blank\" rel=\"noopener\">https://issues.apache.org/jira/browse/LUCENE-6507</a>  </p>\n<p>从里面讨论了NativeFSLock了一些关于这个文件锁的实现的问题</p>\n<a id=\"more\"></a>\n<h2 id=\"JDK的BUG\"><a href=\"#JDK的BUG\" class=\"headerlink\" title=\"JDK的BUG\"></a>JDK的BUG</h2><blockquote>\n<p>On some systems, closing a channel releases all locks held by the Java virtual machine on the underlying file regardless of whether the locks were acquired via that channel or via another channel open on the same file. It is strongly recommended that, within a program, a unique channel be used to acquire all locks on any given file. </p>\n</blockquote>\n<p>这个JDK的文档中写的就是这么一种场景，在某些操作系统上，如果我们把channel直接关闭，那么其他的在这个文件上的Lock会直接失效，当然前提是在同一个JVM进程中</p>\n<p>如果没有这个BUG，我们会怎么写这个LOCK的获取代码呢<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FileChannel channel = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">FileLock lock = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    channel = FileChannel.open(realPath, StandardOpenOption.CREATE, StandardOpenOption.WRITE);</span><br><span class=\"line\">    lock = channel.tryLock();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lock != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> NativeFSLock(lock, channel, realPath, creationTime);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> LockObtainFailedException(<span class=\"string\">\"Lock held by another program: \"</span> + realPath);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lock == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// not successful - clear up and move out</span></span><br><span class=\"line\">      IOUtils.closeWhileHandlingException(channel); <span class=\"comment\">// <span class=\"doctag\">TODO:</span> addSuppressed</span></span><br><span class=\"line\">      clearLockHeld(realPath);  <span class=\"comment\">// clear LOCK_HELD last </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>很简单的，就是先拿channel，然后tryLock，如果失败，就是记得关闭channel就行了。</p>\n<p>但是有个JDK的这个问题，还能直接关闭吗？<br>显然是不能的，你关闭channel，会把其他在这个channel的锁给invalid掉。</p>\n<h2 id=\"Lucene的实现\"><a href=\"#Lucene的实现\" class=\"headerlink\" title=\"Lucene的实现\"></a>Lucene的实现</h2><p>这个帖子最后的解决方案，就是加了一个类似于双重校验锁的东西。<br>在同一个进程中，设置一个<br><code>Set&lt;String&gt; LOCK_HELD</code></p>\n<p>要想获取文件锁，首先得成功把LockName加个Lock_HELD中。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://github.com/frohoff/jdk8u-dev-jdk/blob/master/src/share/classes/java/nio/channels/FileLock.java\" target=\"_blank\" rel=\"noopener\"><code>java.nio.channel.FileLock</code>注释</a></p>\n","categories":["Lucene"],"tags":["Lucene"]},{"title":"h2database的MVStore解析","url":"https://blog.lovezhy.cc/2019/02/18/H2database的MVStore解析/","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>MVStore是h2数据库的底层的存储文件格式<br>在1.4版本之前底层的文件存储都是<code>org.h2.store.*</code>包中的<br>然后1.4之后默认改为了<code>org.h2.mvstore.*</code>包中的  </p>\n<p>官方的介绍说是根据<code>Log Structed FS</code>设计的，顺序写提高性能</p>\n<p>MV的意思是<code>multi-version</code></p>\n<p>同类型的项目有个叫<code>mapDB</code>的项目<br><a href=\"https://github.com/jankotek/mapdb\" target=\"_blank\" rel=\"noopener\">https://github.com/jankotek/mapdb</a>  </p>\n<p>还有一个Apache的项目<code>mavibot</code><br><a href=\"http://directory.apache.org/mavibot/downloads.html\" target=\"_blank\" rel=\"noopener\">http://directory.apache.org/mavibot/downloads.html</a>  </p>\n<a id=\"more\"></a>\n<h1 id=\"简单使用\"><a href=\"#简单使用\" class=\"headerlink\" title=\"简单使用\"></a>简单使用</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.h2.mvstore.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// open the store (in-memory if fileName is null)</span></span><br><span class=\"line\">MVStore s = MVStore.open(fileName);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// create/get the map named \"data\"</span></span><br><span class=\"line\">MVMap&lt;Integer, String&gt; map = s.openMap(<span class=\"string\">\"data\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// add and read some data</span></span><br><span class=\"line\">map.put(<span class=\"number\">1</span>, <span class=\"string\">\"Hello World\"</span>);</span><br><span class=\"line\">System.out.println(map.get(<span class=\"number\">1</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// close the store (this will persist changes)</span></span><br><span class=\"line\">s.close();</span><br></pre></td></tr></table></figure>\n<p>来自官网的例子<br>就当做一个普通的Map使用就行，不过这里支持持久化到磁盘上</p>\n<h1 id=\"文件格式\"><a href=\"#文件格式\" class=\"headerlink\" title=\"文件格式\"></a>文件格式</h1><p>在参考文档中有详细的讲述，不过和最新的代码版本有一些出入<br><img src=\"/images/mvstore/fileformat.png\" alt=\"\"></p>\n<p>先谈谈<code>block</code>的概念<br><code>block</code>是一个扇区的大小，也就是磁盘一次读取的大小。<br>所以H2里定为<strong>4k</strong>，然后无论是<code>file header</code>还是<code>chunk</code>，都是对齐到<code>block</code>的整数倍 </p>\n<h2 id=\"总体\"><a href=\"#总体\" class=\"headerlink\" title=\"总体\"></a>总体</h2><p><code>[ file header 1 ] [ file header 2 ] [ chunk ] [ chunk ] ... [ chunk ]</code></p>\n<p>整个文件的格式是这样<br>其中<code>file header</code>是个KV的格式，<strong>大小是一个<code>block</code></strong><br>形如<br><code>H:2,blockSize:1000,created:167a11ebf8d,format:1,fletcher:9f80997e</code></p>\n<ul>\n<li><code>H:2</code>:固定的，表示这个是h2数据库文件</li>\n<li><code>blockSize:1000</code>：<code>block</code>的大小，size是16进制的，换成存储的就是4K</li>\n<li><code>created:167a11ebf8d</code>：创建时间，v也是16进制的</li>\n<li><code>format:1</code>：文件格式版本，为了防止后续如果新版本文件格式更改，现在都是1</li>\n<li><code>fletcher:9f80997e</code>：checkSum</li>\n</ul>\n<p><code>file header</code>写了两份，header1和header2内容是一样的，官网的描述是防止文件损坏破坏了一份，也是有道理的。</p>\n<h2 id=\"Chunk\"><a href=\"#Chunk\" class=\"headerlink\" title=\"Chunk\"></a>Chunk</h2><p>由于是Version的概念，所以每一次Commit，都会把这个阶段进行了修改的Page都放在新的Chunk中，Version++ （当然如果这段时间内没有修改，就不会commit）</p>\n<p>每次Commit结束，只保留RootPage，把Children的Page缓存全部清空</p>\n<p>下面的<code>chunk</code>是真正存储数据的地方，格式如下：<br><code>[ header ] [ page ] [ page ] ... [ page ] [ footer ]</code></p>\n<p><code>Chunk</code>的大小是不固定的，但是肯定是<code>block</code>的整数倍大小  </p>\n<p>header也是KV的格式，长度限定了最大值<code>Chunk.MAX_HEADER_LENGTH = 1k</code><br>header的header生成来自函数<code>Chunk#asString</code><br>结果是header形如：<br><code>chunk:5,block:5,len:1,map:c,max:980,next:6,pages:5,root:14000016194,time:102cc,version:5</code></p>\n<ul>\n<li><code>chunk:5</code>: 每个chunk都有一个id，这里的id为5，id是原子自增的</li>\n<li><code>block:5</code>：chunk开始的block，用<code>5*blockSize</code>就可以定为到chunk在file中的offset</li>\n<li><code>len:1</code>:chunk的长度，单位为block</li>\n<li><code>map:c</code>：最新的map的id，这里是16进制，每新建一个Map都会分配一个id，自增的，其实我觉得是记录map的个数</li>\n<li><code>max:980</code>:每个Page有个MaxLen（见下面Page的格式)，这里是chunk中所有的maxLen加起来的值</li>\n<li><code>next:6</code>：预测的下一个chunk的开始位置，单位为block</li>\n<li><code>pages:5</code>：此chunk中的包含的page的个数</li>\n<li><code>root:14000016194</code>: MetaMap Root Page的位置，但不是指在文件中的绝对位置，参见Page中的Children编码，一般是chunkId+offset来表示</li>\n<li><code>time:102cc</code>：时间戳，16进制，从文件创建后到chunk写入的时间差</li>\n<li><code>version:5</code>：版本号，一般来说一个commit就会创建一个chunk，每个chunk都是一个新的版本号，这里的chunk包含的数据版本是5</li>\n</ul>\n<p>除了上面这些，可能还有</p>\n<ul>\n<li><code>liveMax</code>:  回去看max的含义，是每个Page的MaxLen的和，就是无论这个Page是否还被使用，liveMax就是所有还在被使用的Page的MaxLen的和</li>\n<li><code>livePages</code>：和上面的Pages的对应，也是还在被使用的Page的个数，而Pages统计的是所有<br>那么统计上面这个两个参数有啥含义呢，当我们回收一个Chunk的时候，如果其中Pages很多，但是目前还在被使用的极少，那么就会进行compact，把还在使用的移动到新的Chunk中，然后回收这个Chunk</li>\n</ul>\n<p>footer的信息和header其实和一部分是一样的<br>写入footer我感觉是为了文件初始化的时候直接从文件末尾开始构建MetaMap准备的<br><code>chunk:5,block:5,version:5,checkSum:{checkSum}</code></p>\n<h2 id=\"Page\"><a href=\"#Page\" class=\"headerlink\" title=\"Page\"></a>Page</h2><p><code>page</code><br>page是进行数据读写和操作的最小单位<br>但是和其他的框架中的Page定义不同的是，这里的<strong>page的大小并不一定</strong>，虽然不固定，但是也有一个阈值的<br>当超过阈值条件后，会进行页分裂，关于页分裂的参见下文</p>\n<p>每一个Map的底层都是一个B+树，然后每一个节点都是一个Page<br>但是其实不是标准的B+树，是一种变形，叫<code>Counted B+ Tree</code><br>这个奇怪的结构，网上并没有找到介绍，但是其实就是进行了B+Tree的优化<br>参见我的另一个文章<strong>Counted-B+Tree原理</strong></p>\n<p>一个Page的结构是<br><code>[length][checkSum][mapId][len][type][children][childCount][keys][values]</code></p>\n<ul>\n<li><code>length</code>：page的大小，int类型</li>\n<li><code>checkSum</code>: checkSum，计算方式是<code>chunkId ^ page在chunk中的offset ^ length</code>，short类型</li>\n<li><code>mapId</code>：page所属的map的id，variable size int类型 </li>\n<li><code>len</code>：key的个数，variable size int类型</li>\n<li><code>type</code>：page的类型，0代表叶子节点，1代表内部节点，如果值+2了表示key和value进行了LZF压缩，如果值+6表示key和value进行了Deflate压缩，byte类型</li>\n<li><code>children</code>：long[]类型，值为子节点的位置，其中<ul>\n<li>26bit为chunkId，</li>\n<li>32bit为page在chunk中的offset，</li>\n<li>5bit位lengthCode，标志page的maxLen<ul>\n<li>0 =&gt; 32bytes</li>\n<li>1 =&gt; 48bytes</li>\n<li>2 =&gt; 64bytes</li>\n<li>3 =&gt; 96bytes</li>\n<li>…</li>\n</ul>\n</li>\n<li>1bit为children的type，叶子节点还是内部节点</li>\n</ul>\n</li>\n<li><code>childCount</code>：表示子节点中的key个数，类型是variable size long数组</li>\n<li><code>keys</code>:放的是key，byte[]类型</li>\n<li><code>values</code>：只有子节点有，放的是值，byte[]类型</li>\n</ul>\n<p>问：为什么不用绝对位置的信息来存放Page的位置呢<br>答：这样灵活性更大，可以移动整个chunk而不用进行Page位置的修改<br>问：什么时候会移动Chunk呢<br>答：目前没看到</p>\n<h1 id=\"metaMap\"><a href=\"#metaMap\" class=\"headerlink\" title=\"metaMap\"></a>metaMap</h1><p>在文件初始化的时候，会创建一个metaMap<br>这个Map中存放的是文件的一些元信息<br>每次Chunk进行写入的时候，最后写入metaMap的Page的信息</p>\n<p>metaMap中存放着这些信息</p>\n<ul>\n<li><code>name.{mapName}</code> =&gt; mapId，由map的名字对应MapId，mapId是16进制</li>\n<li><code>map.{id}</code> =&gt; <code>name:{mapName}</code></li>\n<li><code>root.{mapId}</code>：mapId所指的map的RootPage的位置</li>\n<li><code>chunk.{chunkId}</code> =&gt; <code>chunk:2,block:3,len:1,liveMax:100,livePages:1,map:1,max:3c0,next:4,pages:5,root:800000be0a,time:824,version:2</code> 表示chunk为id的信息</li>\n</ul>\n<p>但是整个MVStore会进行GC的，就是定期清除那些有用的Page不多的Chunk，然后把空出来的空间放新的Chunk。<br>这就导致了一个问题，就是<strong>最新的Chunk不一定就是就在文件的最后</strong><br>所以怎么找到最新的MetaMap的地址呢<br>记得每个Chunk里有个next的KV吗，在MVStore进行初始化的时候，会直接读取最后一个Chunk，然后依次根据他的next值寻找下去，从而找到最后一个Chunk。</p>\n<h1 id=\"文件新建\"><a href=\"#文件新建\" class=\"headerlink\" title=\"文件新建\"></a>文件新建</h1><p>h2抽象出了操作文件接口和上层的业务<br>文件的实现都是在<code>org.h2.store.fs.*</code>中，读写接口是FileChannel。<br>当我们调用</p>\n<p><code>MVStore s = MVStore.open(&quot;/Users/zhuyichen/h2/data.mv&quot;);</code></p>\n<p>时，MVStore会打开一个新的文件，当然是文件不存在的时候<br>写上<code>file header</code>部分，写两份<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">storeHeader.put(<span class=\"string\">\"H\"</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">storeHeader.put(<span class=\"string\">\"blockSize\"</span>, BLOCK_SIZE); <span class=\"comment\">//BLOCK_SIZE = 4 * 1024</span></span><br><span class=\"line\">storeHeader.put(<span class=\"string\">\"format\"</span>, FORMAT_WRITE);  <span class=\"comment\">//FORMAT_WRITE = 1</span></span><br><span class=\"line\">storeHeader.put(<span class=\"string\">\"created\"</span>, creationTime);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"文件打开\"><a href=\"#文件打开\" class=\"headerlink\" title=\"文件打开\"></a>文件打开</h1><p>如果是打开旧的文件，那么会分为下面几个步骤</p>\n<ul>\n<li>读取Header信息</li>\n<li>读取最后一个Chunk的Footer信息</li>\n<li>读取最后一个Chunk的Header信息</li>\n<li>定位MetaMap的位置</li>\n<li>读取MetaMap的信息，定位所有Map的RootPage的信息</li>\n</ul>\n<p>所以其实整个核心就是找到MetaMap的位置，然后读取，只要得到MetaMap的信息，就可以找到所有的Map的位置了</p>\n<p>这里还是略复杂，为了讲清楚，我们举例子<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MVStore s = MVStore.open(<span class=\"string\">\"/Users/zhuyichen/h2/data.mv\"</span>);</span><br><span class=\"line\">MVMap&lt;Integer, String&gt; map1 = s.openMap(<span class=\"string\">\"data1\"</span>);</span><br><span class=\"line\">MVMap&lt;Integer, String&gt; map2 = s.openMap(<span class=\"string\">\"data2\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">    map1.put(i, <span class=\"string\">\"Hello1\"</span>);</span><br><span class=\"line\">    map2.put(i, <span class=\"string\">\"hello2\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">s.commit();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">50</span>; i++) &#123;</span><br><span class=\"line\">    map1.put(i, <span class=\"string\">\"hi1\"</span>);</span><br><span class=\"line\">    map2.put(i, <span class=\"string\">\"hi2\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">s.close();</span><br></pre></td></tr></table></figure></p>\n<p>我们在运行上面的代码之后，会产生两个Chunk<br><img src=\"/images/mvstore/fileformat2.png\" alt=\"\"><br>如上图<br>第一个Chunk中包含了两个B+树  每一个RootPage包含四个Leaf Page<br>在第二次修改中，我们只修改了50个元素，所以没有动到第4个Leaf Page的数据<br>当我们进行commit之后，只save了3个Page，第4个没有动Page，我们还是指向了Chunk1的数据  具体的基于Page的B+树，请看下面</p>\n<p>这里我们知道了文件的布局，下面看看文件的打开流程<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MVStore s = MVStore.open(<span class=\"string\">\"/Users/zhuyichen/h2/data.mv\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>当我们调用这句话的时候</p>\n<h1 id=\"新建Map\"><a href=\"#新建Map\" class=\"headerlink\" title=\"新建Map\"></a>新建Map</h1><p>打开文件之后，新建一个Map实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MVMap&lt;String, String&gt; map = mvStore.openMap(<span class=\"string\">\"data\"</span>);</span><br></pre></td></tr></table></figure>\n<p>其实还有第二个参数，是Map的一些可配置参数<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MVMap.Builder&lt;Integer, String&gt; mvMapConfig = <span class=\"keyword\">new</span> MVMap.Builder&lt;&gt;();</span><br><span class=\"line\">MVMap&lt;Integer, String&gt; map = s.openMap(<span class=\"string\">\"data1\"</span>, mvMapConfig);</span><br></pre></td></tr></table></figure></p>\n<p>参数列表</p>\n<ul>\n<li>keyType:  默认是ObjectDataType</li>\n<li>valueType:  默认是ObjectDataType</li>\n<li>singleWriter: </li>\n</ul>\n<p>我们假设文件是新建的，也就是metaMap中查询不到这个Map的信息<br>然后会给这个Map分配一个唯一的ID<br>然后向metaMap中写入自己的信息</p>\n<p>然后新建一个空Leaf作为Map的RootPage，keys和values都是长度为0的数组</p>\n<h1 id=\"基于Page的B-树\"><a href=\"#基于Page的B-树\" class=\"headerlink\" title=\"基于Page的B+树\"></a>基于Page的B+树</h1><p>每个Page上能放的key的个数是限制的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map.put(<span class=\"string\">\"key1\"</span>, <span class=\"string\">\"value1\"</span>);</span><br></pre></td></tr></table></figure>\n<p>假设我们这么进行写入<br>假设我们是新打开的Map，那么此时Map上只有一个空的Leaf数组  </p>\n<p>在进行写入之前，会对整个MVStore进行一个检查，检查文件的有效性<br>类似于JVM会检查Class文件的MagicWord，cafebabe一样。</p>\n<p>下面就是查找过程，由于是Empty-Leaf，所以找到的index是-1。<br>继而把这个Leaf进行扩容，把<code>key1</code>放到Page对应的keys数组中<br>既然扩容values，把<code>value1</code>放到数组中</p>\n<h2 id=\"页分裂\"><a href=\"#页分裂\" class=\"headerlink\" title=\"页分裂\"></a>页分裂</h2><p>页分裂的条件<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(keyCount = p.getKeyCount()) &gt; store.getKeysPerPage() || </span><br><span class=\"line\">p.getMemory() &gt; store.getMaxPageSize() &amp;&amp; keyCount &gt; (p.isLeaf() ? <span class=\"number\">1</span> : <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure></p>\n<p>看起来还是挺简单的</p>\n<p>store.getKeysPerPage默认是48<br>store.getMaxPageSize和Cache有关，不过默认是64K<br>如果Page是Leaf的话，还必须至少有一个Value，是Node的话，至少有两个子节点<br>但是我理解的话，如果是因为内存过大而分裂，那么Node节点其实是不太可能的</p>\n<h1 id=\"持久化流程\"><a href=\"#持久化流程\" class=\"headerlink\" title=\"持久化流程\"></a>持久化流程</h1><p>和正常的数据库一样，当我们读取和写入数据的时候，都会先从磁盘上把该数据所在的Page加载到内存中<br>然后持久化的最小单位也是Page<br>也就是说，如果Chunk 1中的Leaf Page中有48个KeyValue，但是我们只修改了<strong>一个Value</strong>，然后整个Page还是会持久化到Chunk 2中  </p>\n<h2 id=\"手动持久化\"><a href=\"#手动持久化\" class=\"headerlink\" title=\"手动持久化\"></a>手动持久化</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvStore.commit();</span><br><span class=\"line\">mvStore.close();</span><br></pre></td></tr></table></figure>\n<p>当我们手动进行commit或者直接close的时候，其实就是告诉MVStore进行一次Version的持久化<br>结果就是创建一个<code>Version = currentVersion</code>的Chunk</p>\n<p>写chunk的时候，首先写入header<br>然后开始写Page的信息</p>\n<p>写完用户的Map的Page信息之后，最后写入MetaMap的Pages</p>\n<h2 id=\"后台定时持久化\"><a href=\"#后台定时持久化\" class=\"headerlink\" title=\"后台定时持久化\"></a>后台定时持久化</h2><p>在MVStore进行初始化之后，会启动一个后台线程<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BackgroundWriterThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (store.backgroundWriterThread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (sync) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        sync.wait(sleep);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException ignore) &#123;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (store.backgroundWriterThread == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                store.writeInBackground();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>同时传递给它一个sleep的time，每隔sleepTime，就进行一次commit，默认的sleep的时间是1000ms<br>当他醒来之后，如果发现数据有改变，就会进行一次commit</p>\n<p>由于时间很短，所以正常情况下，不需要手动进行commit</p>\n<p>在我们调用<code>MVStore#close</code>的时候，也会调用一次进行commit</p>\n<h1 id=\"GC\"><a href=\"#GC\" class=\"headerlink\" title=\"GC\"></a>GC</h1><p>随着使用时间变长，肯定不会没有限制的创建Chunk的，MVStore也有回收机制，去回收很久之前的版本的Chunk<br>在官方文档中写的是</p>\n<blockquote>\n<p>Old data is kept for at least 45 seconds (configurable), so that there are no explicit sync operations required to guarantee data consistency. An application can also sync explicitly when needed. To reuse disk space, the chunks with the lowest amount of live data are compacted (the live data is stored again in the next chunk). To improve data locality and disk space usage, the plan is to automatically defragment and compact data.  </p>\n</blockquote>\n<p>我们知道MVStore不会保存所有的Version，很久之前的Version肯定会清除<br>那么就需要一个文件空间标记机制，标记那一块没有被使用已经被Free了，然后下面的Chunk进行写入的时候，可以复写那一块磁盘地址  </p>\n<p>这个机制在MVStore的底层文件操作类FileStore中<br>底层使用了BitSet来表示，单位为BLOCK_SIZE<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#FileStore</span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> FreeSpaceBitSet freeSpace =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> FreeSpaceBitSet(<span class=\"number\">2</span>, MVStore.BLOCK_SIZE);</span><br><span class=\"line\">            </span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">markUsed</span><span class=\"params\">(<span class=\"keyword\">long</span> pos, <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">        freeSpace.markUsed(pos, length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//这个是核心方法，从FileStore中寻找length长度的位置</span></span><br><span class=\"line\"><span class=\"comment\">//注意，不是直接从文件末尾找一块地方</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">allocate</span><span class=\"params\">(<span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> freeSpace.allocate(length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">predictAllocation</span><span class=\"params\">(<span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> freeSpace.predictAllocation(length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//free从pos开始的空间</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">free</span><span class=\"params\">(<span class=\"keyword\">long</span> pos, <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">        freeSpace.free(pos, length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getFillRate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> freeSpace.getFillRate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">getFirstFree</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> freeSpace.getFirstFree();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">getFileLengthInUse</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> freeSpace.getLastFree();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>在我们进行store的时候<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MVStore#storeNow()</span><br><span class=\"line\"><span class=\"keyword\">long</span> filePos = allocateFileSpace(length, !reuseSpace);</span><br></pre></td></tr></table></figure></p>\n<p>就能看到分配的逻辑在里面</p>\n<p>同时我们还能看到Free的方法在里面，就是标记一块Chunk所在的地方已经可以进行reuse<br>那么怎么进行判定了，从上图我们可以知道其实即使在Chunk2中，还是有Page是引用的Chunk1</p>\n<p>MVStore解决的方法也比较简单，就是DFS<br>遍历所有的Map的Node和Page，找到一个Chunk，就把ChunkId放在一个Map中，最后遍历当前文件中的所有Chunk，如果在Map中未找到，那么就是可以回收的<br>有点类似引用计数的方法，但是会不会出现循环引用呢<br>由于所有的Map的RootMap都是存在最新的Chunk中，所有不会出现循环引用的情况</p>\n<p>方法在<code>MVStore#collectReferencedChunks</code><br>这里为了加速DFS的速度，还启动了一个线程池</p>\n<p>带来的问题：<br>GC的机制也带来了问题，就是最新的Chunk在哪儿的问题<br>我们知道如果真的是Log Structed FS的格式的话，那么最新写入的肯定是在最后，而MetaMap的Root Page是在最新的Chunk中的<br>所以我们需要一个机制在打开文件的时候，找到最新的Chunk的位置<br>这个查找的过程，前面已经描述了一遍了</p>\n<h1 id=\"Compact\"><a href=\"#Compact\" class=\"headerlink\" title=\"Compact\"></a>Compact</h1><p>当一个Chunk中LivePages比较少的时候，H2会进行Compact<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MVStore#compact</span><br></pre></td></tr></table></figure></p>\n<p>Compact的方式<br>我只能表示非常的tricky<br>把LivePages中比较少的Page上的数据，全部replace了一遍，这样Chunk1指向chunk0的数据相当于全部update了一遍，但是数据没有变化</p>\n<p>等Compact完之后，再进行上面一步</p>\n<h1 id=\"Page-Cache\"><a href=\"#Page-Cache\" class=\"headerlink\" title=\"Page Cache\"></a>Page Cache</h1><p>Page的Cache机制不是LRU，而是LIRS<br>说实话这种Cache机制我是第一次见</p>\n<h1 id=\"Debug技巧\"><a href=\"#Debug技巧\" class=\"headerlink\" title=\"Debug技巧\"></a>Debug技巧</h1><h2 id=\"源码环境导入Idea\"><a href=\"#源码环境导入Idea\" class=\"headerlink\" title=\"源码环境导入Idea\"></a>源码环境导入Idea</h2><p>会出现提示<code>configure OSGI</code>，<strong>别点</strong></p>\n<h2 id=\"dump-file\"><a href=\"#dump-file\" class=\"headerlink\" title=\"dump file\"></a>dump file</h2><p>如果想要观察Commit发生了什么<br>可以把<code>BackgroundWriterThread</code>给关闭了，防止在背后每隔1s自己<code>commit</code><br>h2的作者提供了一个dump方法<br><code>MVStoreTool.dump()</code><br>可以把文件的内容打印出来</p>\n<h1 id=\"PR\"><a href=\"#PR\" class=\"headerlink\" title=\"PR\"></a>PR</h1><p>在阅读MVStore源码的过程中，还发现了一个comment的错误<br>已经提了PR进行了修复</p>\n<h1 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h1><ul>\n<li><a href=\"http://www.h2database.com/html/mvstore.html\" target=\"_blank\" rel=\"noopener\">http://www.h2database.com/html/mvstore.html</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Variable-length_quantity\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Variable-length_quantity</a></li>\n</ul>\n","categories":["数据库"],"tags":["h2"]},{"title":"HotSpot原理指南-oop-klass模型","url":"https://blog.lovezhy.cc/2019/02/16/HotSpot原理指南-oop-klass模型/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>看任何JVM的书，oop-klass总是绕不去的坎<br>我一直想理解这些，但是就是理解不了，但是也说不出哪里不明白。</p>\n<p>这篇文章不会对这个模型做系统的阐述，假设读者已经看过oop-klass模型，但是还是有点一知半解的状态。</p>\n<h2 id=\"oop-klass\"><a href=\"#oop-klass\" class=\"headerlink\" title=\"oop-klass\"></a>oop-klass</h2><p><strong>为什么要这么设计？</strong><br>其实很多书也提到，既然HotSpot完全基于C++去编写，要实现多态完全可以进行C++层面的转换就行。<br>但是C++的多态其实每一个对象都维护了一个VTable，就是虚函数表，函数表可以理解为一个函数指针的数组，这个数组在内存上和一个对象是一起的。<br>但是很多书中提到，为了避免每个对象都有一个VTable，JVM定义了oop-klass模型，其中oop就是保存数据结构的，而klass则担当了一部分VTable的功能，这样的话，<strong>VTable就是每个类只存在一个</strong>。<br>也就是说，对oop而言，它对应的klass是单例的，而Java层面每New一个对象，都会在JVM生成一个oop。</p>\n<p>所以在Java中，类和对象的关系更像是这样:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Student student1 = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"zhang\"</span>, <span class=\"number\">19</span>);</span><br><span class=\"line\">        Student student2 = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"wang\"</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Student</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> age)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"/images/oop-klass/oop1.png\" alt=\"\">  </p>\n<h2 id=\"动态绑定与VTable\"><a href=\"#动态绑定与VTable\" class=\"headerlink\" title=\"动态绑定与VTable\"></a>动态绑定与VTable</h2><p>这里再提一个我对动态绑定的理解。<br>其实动态绑定这个概念，大家都知道大概是个什么意思，但是再详细的说，就理不清很多细节。 </p>\n<p>现在我们都知道动态绑定是和虚表有关，在Java字节码中，需要动态绑定的指令是<code>invokevirtual</code>。<br><a href=\"https://cs.au.dk/~mis/dOvs/jvmspec/ref--35.html\" target=\"_blank\" rel=\"noopener\">https://cs.au.dk/~mis/dOvs/jvmspec/ref–35.html</a><br>这个ref中讲的是，动态绑定需要一个寻找函数的过程</p>\n<blockquote>\n<p>invokevirtual retrieves the Java class for objectref, and searches the list of methods defined by that class and then its superclasses, looking for a method called methodname, whose descriptor is descriptor.</p>\n</blockquote>\n<p>这当然我感觉是一种很扯淡的说法，要是这么来，运行时时间都花在匹配函数上去了。<br>而寻找函数的过程，我理解<strong>完全可以放在编译期去完成</strong>。<br>我更认同是这种方式，就是不需要进行运行时的函数匹配，动态绑定的意思是需要在运行时改变代码段的函数指针，类似于下面文章中提到的<br><a href=\"https://www.jianshu.com/p/fa50296b301c\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/fa50296b301c</a></p>\n<blockquote>\n<p>编译器内部会发生转换，产生类似下面的代码：<br>( <em>( p-&gt;vptr )[0] ) (p);  //</em>( p-&gt;vptr )[0]是函数入口地址</p>\n</blockquote>\n<p>这段代码的生成，对于C++而言是编译时，对于Java则是ClassLoader的时候，并不是运行时。</p>\n<p>关于动态绑定，还有一些其他模棱两可的说法<br>比如这个文章中<br><a href=\"https://zhuanlan.zhihu.com/p/24317613\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/24317613</a></p>\n<p>它提到在<code>invokevirtual</code>的调用过程，需要去查父类的方法表</p>\n<blockquote>\n<p>(2) 在Father类型的方法表中查找方法f1，如果找到，则将方法f1在方法表中的索引项11(如上图)记录到AutoCall类的常量池中第15个常量表中(常量池解析 )。这里有一点要注意：如果Father类型方法表中没有方法f1，那么即使Son类型中方法表有，编译的时候也通过不了。因为调用方法f1的类的对象father的声明为Father类型。</p>\n</blockquote>\n<p>这我也是觉得是脱裤子放屁的说法，为啥要去查父类的方法表，要知道父类的方法表，是在另外一个Klass对象里，要是继承链比较长，那么需要很多次指针寻址才能找到。</p>\n<p>其实这个和另外一个比较经典的动态绑定的解释很像：</p>\n<blockquote>\n<p>如果子类Son中定义了 method() 的方法，则直接调用子类中的相应方法；如果子类Son中没有定义相应的方法，则到其父类中寻找method()方法。</p>\n</blockquote>\n<p>很多人把这个过程理解为动态绑定，这个的问题也是一样的，它的假设是子类的Klass对象中没有父类的方法指针，所以需要去父类的Klass的VTable中去找。</p>\n<p>但是通过一些文章我们可以看出，其实子类的VTable完全的Copy了一份父类的VTable。<br><a href=\"https://stackoverflow.com/questions/18082651/how-does-dynamic-binding-happens-in-jvm\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/18082651/how-does-dynamic-binding-happens-in-jvm</a><br><a href=\"https://cloud.tencent.com/developer/article/1180981\" target=\"_blank\" rel=\"noopener\">https://cloud.tencent.com/developer/article/1180981</a>  </p>\n<p>所以至此，整个动态绑定的过程我们就已经理解，所谓动态绑定，就是比静态绑定多了一个指针寻址，去Klass中找VTable的过程。</p>\n<h2 id=\"1-7到1-8\"><a href=\"#1-7到1-8\" class=\"headerlink\" title=\"1.7到1.8\"></a>1.7到1.8</h2><p>很多书中都提到，oop-klass模型在1.8中改变较大。<br>原因是1.8中去掉了永久代（Perm），而改为了元空间(MetaSpace)。</p>\n<p>我们先看看1.7中的oop-klass的继承链<br><a href=\"https://github.com/openjdk-mirror/jdk7u-hotspot/blob/master/src/share/vm/oops/oopsHierarchy.hpp\" target=\"_blank\" rel=\"noopener\">https://github.com/openjdk-mirror/jdk7u-hotspot/blob/master/src/share/vm/oops/oopsHierarchy.hpp</a>   </p>\n<p>oop继承链<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">oopDesc</span>*                            <span class=\"title\">oop</span></span>;</span><br><span class=\"line\">typedef <span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">instanceOopDesc</span>*            <span class=\"title\">instanceOop</span></span>;</span><br><span class=\"line\">typedef <span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">methodOopDesc</span>*                    <span class=\"title\">methodOop</span></span>;</span><br><span class=\"line\">typedef <span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">constMethodOopDesc</span>*            <span class=\"title\">constMethodOop</span></span>;</span><br><span class=\"line\">typedef <span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">methodDataOopDesc</span>*            <span class=\"title\">methodDataOop</span></span>;</span><br><span class=\"line\">typedef <span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">arrayOopDesc</span>*                    <span class=\"title\">arrayOop</span></span>;</span><br><span class=\"line\">typedef <span class=\"class\"><span class=\"keyword\">class</span>     <span class=\"title\">objArrayOopDesc</span>*            <span class=\"title\">objArrayOop</span></span>;</span><br><span class=\"line\">typedef <span class=\"class\"><span class=\"keyword\">class</span>     <span class=\"title\">typeArrayOopDesc</span>*            <span class=\"title\">typeArrayOop</span></span>;</span><br><span class=\"line\">typedef <span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">constantPoolOopDesc</span>*            <span class=\"title\">constantPoolOop</span></span>;</span><br><span class=\"line\">typedef <span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">constantPoolCacheOopDesc</span>*   <span class=\"title\">constantPoolCacheOop</span></span>;</span><br><span class=\"line\">typedef <span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">klassOopDesc</span>*                    <span class=\"title\">klassOop</span></span>;</span><br><span class=\"line\">typedef <span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">markOopDesc</span>*                    <span class=\"title\">markOop</span></span>;</span><br><span class=\"line\">typedef <span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">compiledICHolderOopDesc</span>*    <span class=\"title\">compiledICHolderOop</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>klass继承链<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Klass</span></span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">instanceKlass</span></span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>     <span class=\"title\">instanceMirrorKlass</span></span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>     <span class=\"title\">instanceRefKlass</span></span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">methodKlass</span></span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">constMethodKlass</span></span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">methodDataKlass</span></span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">klassKlass</span></span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>     <span class=\"title\">instanceKlassKlass</span></span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>     <span class=\"title\">arrayKlassKlass</span></span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>       <span class=\"title\">objArrayKlassKlass</span></span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>       <span class=\"title\">typeArrayKlassKlass</span></span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">arrayKlass</span></span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>     <span class=\"title\">objArrayKlass</span></span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>     <span class=\"title\">typeArrayKlass</span></span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">constantPoolKlass</span></span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">constantPoolCacheKlass</span></span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">compiledICHolderKlass</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>可以说是非常多</p>\n<p>但是到了1.8中，就变的很少<br>oop继承链<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">oopDesc</span>*                            <span class=\"title\">oop</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">instanceOopDesc</span>*            <span class=\"title\">instanceOop</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">arrayOopDesc</span>*                    <span class=\"title\">arrayOop</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">class</span>     <span class=\"title\">objArrayOopDesc</span>*            <span class=\"title\">objArrayOop</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">class</span>     <span class=\"title\">typeArrayOopDesc</span>*            <span class=\"title\">typeArrayOop</span>;</span></span><br></pre></td></tr></table></figure></p>\n<p>klass继承链<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Klass</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">InstanceKlass</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>     <span class=\"title\">InstanceMirrorKlass</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>     <span class=\"title\">InstanceClassLoaderKlass</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>     <span class=\"title\">InstanceRefKlass</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">ArrayKlass</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>     <span class=\"title\">ObjArrayKlass</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>     <span class=\"title\">TypeArrayKlass</span>;</span></span><br></pre></td></tr></table></figure></p>\n<p>而少掉的那部分，其实只是换了个名字，叫做Metadata<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//      class MetaspaceObj</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">ConstMethod</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">ConstantPoolCache</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">MethodData</span>;</span></span><br><span class=\"line\"><span class=\"comment\">//      class Metadata</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">Method</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">ConstantPool</span>;</span></span><br><span class=\"line\"><span class=\"comment\">//      class CHeapObj</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>   <span class=\"title\">CompiledICHolder</span>;</span></span><br></pre></td></tr></table></figure></p>\n<p>可能你已经猜到了，Metadata的这部分，已经全部转移到了元空间。</p>\n<p>以下是 JDK 1.7 中的类在 JDK 1.8 中的存在形式：</p>\n<ul>\n<li>klassOop -&gt; Klass*</li>\n<li>klassKlass 不再需要</li>\n<li>methodOop -&gt; Method*</li>\n<li>methodDataOop -&gt; MethodData*</li>\n<li>constMethodOop -&gt; ConstMethod*</li>\n<li>constantPoolOop -&gt; ConstantPool*</li>\n<li>constantPoolCacheOop -&gt; ConstantPoolCache*</li>\n</ul>\n<p>Klass少掉的部分，还可以理解，但是为啥oop会少了这么多。</p>\n<p>这里就牵扯到永久代和元空间的区别了。</p>\n<p>首先的问题是，为什么撤销永久代而换成元空间<br>我找到了当初的JEP<br><a href=\"http://openjdk.java.net/jeps/122?spm=a2c4e.11153940.blogcont20279.13.13fd33dbw7ltIv\" target=\"_blank\" rel=\"noopener\">http://openjdk.java.net/jeps/122?spm=a2c4e.11153940.blogcont20279.13.13fd33dbw7ltIv</a></p>\n<blockquote>\n<p>永久代的调优非常难，永久代的大小很难确定，其中涉及到太多因素，如类的总数、常量池大小和方法数量等，而且永久代的数据可能会随着每一次Full GC而发生移动。</p>\n</blockquote>\n<p>这里就要提到元空间的特点</p>\n<blockquote>\n<p>Symbols were moved to the native heap<br>Interned strings were moved to the Java Heap<br>Class statics were moved to the Java Heap</p>\n</blockquote>\n<ul>\n<li>永久代属于堆，有大小限制。元空间使用堆外内存，理论上无内存限制</li>\n<li>JDK7之前的HotSpot，字符串常量池的字符串被存储在永久代中，因此可能导致一系列的性能问题和内存溢出错误。在JDK8中，字符串常量池中只保存字符串的引用。</li>\n</ul>\n<p>而如果你去看JDK1.7的oopDesc的定义，你会发现一个奇怪的事<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">oopDesc</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">friend</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VMStructs</span>;</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"keyword\">volatile</span> markOop  _mark;</span><br><span class=\"line\">  <span class=\"keyword\">union</span> _metadata &#123;</span><br><span class=\"line\">    wideKlassOop    _klass;</span><br><span class=\"line\">    narrowOop       _compressed_klass;</span><br><span class=\"line\">  &#125; _metadata;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里的Klass，为什么是Oop对象？</p>\n<p>这里引用R大的解释<br><a href=\"https://rednaxelafx.iteye.com/blog/858009\" target=\"_blank\" rel=\"noopener\">https://rednaxelafx.iteye.com/blog/858009</a></p>\n<blockquote>\n<p>因为HotSpot 1.7之前，包括Class在内的元数据对象都需要被GC管理，因此这四列的对象其实都是oopDesc类型，只不过第一列是描述实例的instanceOopDes, 第二三四列为klassOopDesc；这个klassOopDesc可以看作是klass的一个wrapper，仅仅为了被gc更容易滴管理和表示，它的内部有一个klass成员来表达klass的信息。<br>所以第二列的 klassOopDesc 内部的klass 乃Integer类的klass，第三列的klass为 klassOopDesc这个对象的klass——instanceKlassKlass，那第三列这个类的klass是什么呢？由于描述instanceKlassKlass，methodKlassKlass，xxxxKlassKlass等一大票KlassKlass需要的元数据实际上是相同的，他们就是第四列的KlassKlass，第四列的KlassKlass的klass可以用它自己来描述，于是就圆满了。</p>\n</blockquote>\n<p>简单说就是为了偷懒，用Oop包裹一层，让GC一同管理了。<br>到了元方法区，已经不属于堆了，自然不需要这个了，自然可以去掉。</p>\n<p>所以到了1.8，就变成了正常的状态<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">oopDesc</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">volatile</span> markOop _mark;</span><br><span class=\"line\">  <span class=\"keyword\">union</span> _metadata &#123;</span><br><span class=\"line\">    Klass*      _klass;</span><br><span class=\"line\">    narrowKlass _compressed_klass;</span><br><span class=\"line\">  &#125; _metadata;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"MarkOop\"><a href=\"#MarkOop\" class=\"headerlink\" title=\"MarkOop\"></a>MarkOop</h2><p>还有一些细节，我还是比较困惑的。<br>比如这个MarkOop的定义<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">markOopDesc</span>:</span> <span class=\"keyword\">public</span> oopDesc &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>它是继承于oopDesc的<br>但是在oopDesc的定义中<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">oopDesc</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">volatile</span> markOop _mark;</span><br><span class=\"line\">  <span class=\"keyword\">union</span> _metadata &#123;</span><br><span class=\"line\">    Klass*      _klass;</span><br><span class=\"line\">    narrowKlass _compressed_klass;</span><br><span class=\"line\">  &#125; _metadata;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>又用到了markOop</p>\n<p>好吧，这个是一件比较奇怪的是。</p>\n<p>上面R大提到，继承与oopDesc的都是被GC管理的，<br>但是这里有个奇怪的点</p>\n<p>MarkOop存在于OopDesc中，讲道理应该是个对象才是，但是它的作用却只是作为对象头。<br>在Java层面没有与之对应的东西。<br>更没有道理要被GC管理着啊</p>\n<p>我翻阅文档的注释<br>发现了这么一句话<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Note that the mark is not a real oop but just a word.</span></span><br><span class=\"line\"><span class=\"comment\">// It is placed in the oop hierarchy for historical reasons.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br></pre></td></tr></table></figure></p>\n<p>既然官方解释是<strong>历史原因</strong>，那就不追究这个问题了。</p>\n<h2 id=\"JIT热点探测\"><a href=\"#JIT热点探测\" class=\"headerlink\" title=\"JIT热点探测\"></a>JIT热点探测</h2><p>这个算是一个小发现<br>我们查看oop的体系，发现Method也有对应的oop<br>在method的oop中，有个变量叫MethodCounters<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MethodCounters</span> :</span> <span class=\"keyword\">public</span> Metadata &#123;</span><br><span class=\"line\"> <span class=\"keyword\">friend</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VMStructs</span>;</span></span><br><span class=\"line\"> <span class=\"keyword\">friend</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JVMCIVMStructs</span>;</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> INCLUDE_AOT</span></span><br><span class=\"line\">  Method*           _method;                     <span class=\"comment\">// Back link to Method</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> defined(COMPILER2) || INCLUDE_JVMCI</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span>               _interpreter_invocation_count; <span class=\"comment\">// Count of times invoked (reused as prev_event_count in tiered)</span></span><br><span class=\"line\">  u2                _interpreter_throwout_count; <span class=\"comment\">// Count of times method was exited via exception while interpreting</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> INCLUDE_JVMTI</span></span><br><span class=\"line\">  u2                _number_of_breakpoints;      <span class=\"comment\">// fullspeed debugging support</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">  InvocationCounter _invocation_counter;         <span class=\"comment\">// Incremented before each activation of the method - used to trigger frequency-based optimizations</span></span><br><span class=\"line\">  InvocationCounter _backedge_counter;           <span class=\"comment\">// Incremented before each backedge taken - used to trigger frequencey-based optimizations</span></span><br></pre></td></tr></table></figure></p>\n<p>这个类维护了几个关于方法调用次数的计数器，和JIT的热点探测有关</p>\n<p>具体的细节可以查看<br><a href=\"https://www.jianshu.com/p/1ea9b3d1abb9\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/1ea9b3d1abb9</a> </p>\n<p><a href=\"http://mail.openjdk.java.net/pipermail/hotspot-compiler-dev/2011-June/005750.html\" target=\"_blank\" rel=\"noopener\">http://mail.openjdk.java.net/pipermail/hotspot-compiler-dev/2011-June/005750.html</a></p>\n<h2 id=\"HSDB\"><a href=\"#HSDB\" class=\"headerlink\" title=\"HSDB\"></a>HSDB</h2><p>这个工具，可以用来查看运行时的oop和klass数据<br>简单的使用，网上可以随便百度到，这里介绍下怎么查看虚表<br><a href=\"https://cloud.tencent.com/developer/article/1180981\" target=\"_blank\" rel=\"noopener\">https://cloud.tencent.com/developer/article/1180981</a>  </p>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><ul>\n<li><a href=\"https://www.sczyh30.com/posts/Java/jvm-klass-oop/\" target=\"_blank\" rel=\"noopener\">https://www.sczyh30.com/posts/Java/jvm-klass-oop/</a></li>\n<li><a href=\"https://book.douban.com/subject/25847620/\" target=\"_blank\" rel=\"noopener\">《HotSpot实战》</a></li>\n<li><a href=\"https://book.douban.com/subject/27086821/\" target=\"_blank\" rel=\"noopener\">《揭秘Java虚拟机》</a></li>\n<li><a href=\"https://www.cnblogs.com/paddix/p/5309550.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/paddix/p/5309550.html</a></li>\n<li><a href=\"https://www.slideshare.net/cafusic/jvm20101228?from_action=save\" target=\"_blank\" rel=\"noopener\">R大的JVM分享，强烈推荐</a></li>\n<li><a href=\"https://blogs.oracle.com/poonam/about-g1-garbage-collector,-permanent-generation-and-metaspace\" target=\"_blank\" rel=\"noopener\">oracle文档中对元空间的解释</a></li>\n</ul>\n","categories":["HotSpot"],"tags":["JVM","OopKlass"]},{"title":"十万嬉皮","url":"https://blog.lovezhy.cc/2019/01/05/十万嬉皮/","content":"<h1 id=\"十万嬉皮-万能青年旅店\"><a href=\"#十万嬉皮-万能青年旅店\" class=\"headerlink\" title=\"十万嬉皮 - 万能青年旅店\"></a><strong>十万嬉皮 - 万能青年旅店</strong></h1><p>大梦一场的董二千先生</p>\n<a id=\"more\"></a>\n<p>推开窗户，举起望远镜</p>\n<p>眼底映出，一阵浓烟</p>\n<p>前已无通路，后不见归途</p>\n<p>敌视现实，虚构远方</p>\n<p>东张西望，一无所长</p>\n<p>四体不勤，五谷不分</p>\n<p>文不能测字，武不能防身</p>\n<p>喜欢养狗，不爱洗头</p>\n<p>不事劳作，一无所获</p>\n<p>厌恶争执，不善言说</p>\n<p>终于沦为沉默的帮凶</p>\n<p>借酒浇愁，不太能喝</p>\n<p>蛊惑他人，麻醉内心</p>\n<p>浇上汽油，舒展眉头</p>\n<p>纵火的青年，迫近的时间</p>\n","categories":["我的生活"],"tags":["Life"]},{"title":"磁盘，IO，CPU与中断","url":"https://blog.lovezhy.cc/2019/01/03/磁盘，IO与中断/","content":"<p>第一次写如此泛泛而谈的文章。<br>最近磁盘，IO中断的概念不断的在我脑子中，就随便写写。</p>\n<a id=\"more\"></a>\n<h1 id=\"Speed\"><a href=\"#Speed\" class=\"headerlink\" title=\"Speed\"></a>Speed</h1><p>其实自己之前对内存访问，Cpu Cache和磁盘访问，网络访问的时间并没有多大的概念。<br>只知道个大概的比较<br>下面是各个操作的正常时间延迟</p>\n<blockquote>\n<p><img src=\"/images/磁盘IO与中断/速度.png\" alt=\"\"></p>\n<pre><code>--《Redis开发与运维》\n</code></pre></blockquote>\n<p>同时，目前很多的产品都用上了SSD。<br>而SSD相对于磁盘而言，访问速度和性能又上升了一个层次。</p>\n<blockquote>\n<p>传统磁盘的I/O寻道延迟很高，这导致它的访问延迟（～10ms）远高于内存（~100ns），并且它的随机访问性能远低于顺序访问性能，这对上层软件系统的设计产生了极大的影响。为了解决这一问题，存储器件的演进方向主要包含两类：(1) 闪存（Solid State Disk，SSD）将I/O访问延迟降低了三个数量级（~10us），并且它的随机读取性能与顺序读取性能相似<br>​                                                                                            – <a href=\"http://mysql.taobao.org/monthly/2018/11/01/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2018/11/01/</a></p>\n</blockquote>\n<p><strong>= = 我没测过，所以不对以上数据负责。。。</strong></p>\n<ul>\n<li>Cpu Cache &lt;&lt; Main Memory<br>这个很典型的例子，就是ArrayList的迭代和LinkedList的迭代，哪个快问题，因为一个CacheLine是64，所以读取不足64k的话，会把目标地址的周围数据也读进去填充为一个CacheLine，这个就导致了ArrayList的迭代速度大于LinkedList</li>\n<li>Main Memory Reference + Read 1MB sequenially from memory &lt;&lt;&lt; Disk Seek + Read 1MB sequenially from Disk<br>这个速度差距简直不忍直视，现在的很多内存数据库，比如Redis，虽然是双读双写，如果Miss了，还要读一次数据库，性能损耗很大，但是如果访问量巨大，全部命中Cache的话，那收益是巨大的。</li>\n</ul>\n<p>System Call<br>还有一个性能所在的地方就是系统调用<br>普通函数和系统调用的性能对比我也不是很清楚，只是知道系统调用性能消耗比较大<br><img src=\"/images/磁盘IO与中断/syscall.png\" alt=\"\">  </p>\n<p>从上面看，一个轻量级的系统调用还行，但是涉及到IO的，就很慢了，比正常函数慢100 - 1000倍不等。</p>\n<p>而如果考虑Epoll那种事件驱动的话，如果你的业务代码非阻塞，执行的非常的快的话，其实和IO事件比起来不算什么，参见Netty，可能你调用了几百个简单的函数，都不如一次Read函数花的时间多。</p>\n<p>从数据上看Write比Read更是慢了一倍，所以NIO而言，异步的写，我感觉还是比较重要的，特别是遇到<code>Would Block</code>的错误，如果还是拼命写，那其实还不如先存起来，等待一个写事件。</p>\n<h1 id=\"缓冲\"><a href=\"#缓冲\" class=\"headerlink\" title=\"缓冲\"></a>缓冲</h1><p>如果你再去看看主存的定义，会发现它其实是类似于缓存的东西，为磁盘服务的。<br>缓存的概念其实到处都有，主要用来处理上层和下层的速度不匹配的问题。<br>而磁盘的缓存单位一般是页，在H2Database中，一个页通常是4k，和内核的内存管理有关。<br>而数据的写入，一般是先写入主存，再写入磁盘。</p>\n<p>而大多数人不知道的是，我们代码的数据到磁盘之间，调用write之后，并不会直接到磁盘，而是先写入内核的缓存。</p>\n<p>所以数据的流向是这样的<br>用户态数据 -&gt; 内核态数据 -&gt; 磁盘。<br>相应的，从磁盘读取数据到用户态也是<br>磁盘 -&gt; 内核态数据 -&gt; 用户态数据</p>\n<p>内核是以页为单位把数据从磁盘读到内核缓冲区的。</p>\n<p>内核为啥要把数据先放到自己的缓冲区呢，个人理解答案当然还是为了缓冲。<br>就跟Cpu的CacheLine一样，你只从文件里读取一个Bit？那不行，直接拉满填充一个Page</p>\n<p>当我们自己向文件中写入了值的时候，其实还没有写进去磁盘，具体什么时候写，由内核来定。<br>所以提供了两个函数</p>\n<ul>\n<li>sync</li>\n<li>fsync</li>\n</ul>\n<p>sync只是把脏页数据，强制放到写磁盘的队列中<br>fsync一直到成功写入磁盘才返回<br>而write函数仅仅是写回脏页而已</p>\n<p>而这里其实还有个问题，就是内核是不相信用户的，所以如果你要从内核的缓冲区进行Read，内核会把那一份数据<strong>拷贝</strong>一份到用户态<br>这其中的消耗其实不是那么必要的。</p>\n<p>为此，内核还提供了一个函数mmap，就是给予用户程序能直接读取和写入数据到内核的缓冲区  </p>\n<p>在此，如果有这样一个需求，在一个静态的httpServer，需要把index.html传送到socket，我先read出来，然后write出去，这不傻逼了吗，白白复制这么多次。<br>然后有个系统调用叫sendfile，内核帮你直接复制到socket的缓冲区。</p>\n<h1 id=\"中断\"><a href=\"#中断\" class=\"headerlink\" title=\"中断\"></a>中断</h1><p>如果你注意思考上面的问题，你就会发现问题本质是</p>\n<ul>\n<li>CPU的快和其他东西慢的矛盾<br>在思考Epoll的就绪链表的时候，如果该Socket Fd上出现事件，就调用回调把自己插入到就绪链表。<br>那么再深层次一点，谁调用这个回调呢，是内核<br>再深层次一点，内核怎么知道你这个Fd上有数据<br>那就是网卡发送中断给CPU了<br><code>设备事件 - 中断 - CPU响应中断</code><br>这个简直是个完美的模型  </li>\n</ul>\n<p>但是上面的模型，如果基于Netty的Flux一样，并不能提高事件处理的速度，而是提高了吞吐量，提高吞吐量的关键就是不要Block住CPU，再实际一点就是不要Block住线程，让一个线程多处理事件。</p>\n<p>而提高应用的速度和吞吐量并不是两个毫不相干的东西，在一些情况下，甚至会是互相矛盾的。<br>比如就写事件而言，如果出现了would block</p>\n<ul>\n<li>我还是疯狂写</li>\n<li>注册写事件，当出现写事件再去写</li>\n</ul>\n<p>如果你是疯狂写，那么你就是让其他的事件去等待，恰好网络状况较好的话，这种的速度是很快的，但是吞吐量不高。<br>如果你是注册写事件，那么就是暂时放弃了这个fd，当Fd可写的时候，相对于第一种情况，已经经过了相对较长的时间了，相应的响应时间就变长了。</p>\n<p>我曾经设想过一个，就是用Netty的时候，把EventLoop线程设置为茫茫多，像Tomcat那么多，但是其实是有问题的，因为他的模型和Tomcat不一样，Tomcat的200个线程是不处理IO事件的，但是EventLoop中每一个线程还注册了Epoll来处理IO事件。</p>\n<h1 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h1><p>主存的定位是什么，Cache吗，作为CPU和磁盘的缓冲，有道理。<br>作为CPU计算的中间结果的暂存地？也有道理。<br>其实现在这种Cache大行其道的时代，你会发现主存却越来越非主流<br>从Cache的角度讲，主存的意义就是作为磁盘的高速Cache<br>但是现在你和其他人讲这个观点反而会觉得奇怪，内存怎么会和缓存是一回事呢？<br>因为现在很多东西都只在内存中，应用或者系统也没有打算写到磁盘中<br>Cache失效了？那就崩溃了，那就重启吧，不叫事。<br>但是如果你在公司不考虑缓存失效的情况，那你怕是要被开除了。</p>\n<p>但是其实我们没有考虑过，主存到底会不会失效呢<br>我们写Java程序，往一个List里面写一个对象，运行着发现这个对象没了<br>不会考虑到操作系统的问题，而是我们代码的问题<br>所以Cache失效的问题，是操作系统来保证不会失效的的。<br>当然DRAM也算，硬件一般也不会出问题</p>\n<p>如果你再深挖一下<br>什么？内存竟然不是我们自己来管理的？那我们平时写内存写内存是写到哪儿去了。<br>不要误以为写内存就是直接写物理内存(内存条)，其实只是提申请给操作系统，然后由操作系统写到了物理内存</p>\n<p>那平时我们print出来的那些内存地址呢，是真的物理地址吗？<br>不是<br>那些地址是假的吗？<br>是也不是。</p>\n<p>那么操作系统怎么管理内存的呢？<br>其实操作系统管理内存的方式更像是Cache管理的方式</p>\n<h1 id=\"CPU\"><a href=\"#CPU\" class=\"headerlink\" title=\"CPU\"></a>CPU</h1><p>如果你参考现在的系统优化方向，大部分分两个方向</p>\n<ul>\n<li>架构</li>\n<li>硬件</li>\n</ul>\n<p>之前我在的数据库事业部，架构上的优化，和高性能几乎没什么关系，基本都是为了CAP而来<br>但是加速执行，硬件是个大方向，而且越来越火</p>\n<p>比如Java的Panama项目中增强的SIMD支持<br>SIMD是什么呢？这个是CPU中很早就支持的东西，但是JDK中是我们无法控制的，有HotSpot自己控制。</p>\n<p>从数据库的查询来看，SIMD在对数组进行Project和Filter等特定算子的运行时，加速是很大的。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li>《Redis开发与运维》</li>\n<li><a href=\"http://mysql.taobao.org/monthly/2018/11/01/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2018/11/01/</a></li>\n<li><a href=\"https://stackoverflow.com/questions/23599074/system-calls-overhead\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/23599074/system-calls-overhead</a></li>\n</ul>\n","categories":["计算机随想"],"tags":["磁盘","IO","CPU中断"]},{"title":"我的2018","url":"https://blog.lovezhy.cc/2019/01/01/我的2018/","content":"<p>总结我的2018</p>\n<a id=\"more\"></a>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>一路坎坷的2018年终于过去了，一年12个月，我有9个月都在外面实习  </p>\n<ul>\n<li>2 - 4：美团实习</li>\n<li>6 - 8：阿里实习</li>\n<li>11 - ~：网易实习</li>\n</ul>\n<p>虽然其实自己感觉也没啥，但是回顾起来还是觉得满坎坷的  </p>\n<h2 id=\"美团实习\"><a href=\"#美团实习\" class=\"headerlink\" title=\"美团实习\"></a>美团实习</h2><p>去美团实习的时候，真的是一张白纸<br>最开始去之前还是觉得很开心很激动，因为美团也算是一个大公司了，而我一个双非本科的学生，能得到这样的机会，实在是难得。 当时HR告诉我的工资，足够我在上海活下去，也终于不需要向爸妈拿钱了。<br>但是由于发生了一些事，导致这段实习其实并不是很愉快   </p>\n<p>由于HR的原因，导致我的工资入职后才知道其实很低很低，因为HR不仅仅告诉错了我的工资，还没说日常是实习生是没有房补的。 每个月不仅仅仅靠自己的工资完全活不下去，还需要向爸妈拿钱  这个是我当时最伤心的地方   </p>\n<p>房子租的很远，每天上班大概需要一个半小时的时间 其中走路大概需要45分钟   </p>\n<p>由于当时春招并未开始，所以我知道自己的不足，还是在每天疯狂的学习到很晚，压力很大    </p>\n<p>虽然有点骄傲，进去后发现其实我的水平完全够得上，并没有感觉到不能胜任的地方，但是Leader还是只给我一些小任务去做 我的意思是，我并不能学到什么新的东西 完全是自己自学   </p>\n<p>春招正式开始后，主管以部门HC紧张为理由，拒绝给我转为暑假实习生(有房补)，让我继续保持日常实习生，然后八月份一起参加转正答辩，意味着如果我留下来，到八月份还是没有房补  </p>\n<p>住的很偏，周围并没有什么吃的 但是爸妈一直在问我吃的好不好，让我不要省，但是我还是不好意思和他们要钱，但是我还是得吃饭，外卖又很贵。于是很多个周末我都是早饭不吃，午饭点外卖顺便把晚饭也买下来，可以最大限度的参加满减和省一次运费  </p>\n<h2 id=\"春招\"><a href=\"#春招\" class=\"headerlink\" title=\"春招\"></a>春招</h2><p>大概3 - 4月份两个月都在不停地面试，写笔试，投简历<br>由于还是在美团上班，所以只能每次都约晚上的实习<br>好几次都顶着压力提前下班回去面试  </p>\n<p>最狠的一次是晚上7：30到11点，面了三个公司  </p>\n<p>第一个Offer是酷家乐的，面的其实还挺多的，最后一面是让我远程写代码，写一个命令行的管理系统，大概是一个小时的时间，我当时虽然没吃饭，但是状态不错，顺畅的写完了<br><img src=\"/images/2018/酷家乐.png\" alt=\"\"><br>收到Offer的时间是4.2号，那周我去虹桥的一个电影院看了<strong>玩家一号</strong>的IMAX版本  </p>\n<p>第二个Offer来自饿了么，让我去现场面，我去了之后发现其实面试挺简单的，简单面了两面之后就发了Offer给我<br><img src=\"/images/2018/饿了么.png\" alt=\"\">  </p>\n<p>第三个Offer，也就是最后一个Offer就是来自阿里<br>说来奇怪，阿里是我最早面完的，但是是发的最晚的，大概是在5.10号才发的<br>流程也是比较坎坷</p>\n<p>期间还面了有赞，华为，腾讯等<br>有赞还去了次杭州<br>华为是乘机回了次学校<br>腾讯电话面试挂了一次，然后笔试过了，现场面试又挂了</p>\n<h2 id=\"5月份\"><a href=\"#5月份\" class=\"headerlink\" title=\"5月份\"></a>5月份</h2><p>我在4.23号的时候，离职了美团，终于脱离了让我当时痛苦不堪的地方<br>在家短暂的呆了一段时间，然后去了学校<br>在学校玩的很开心<br>决定去阿里实习之后，按照内推人的建议开始学习Hadoop，Hive之类的一些东西 </p>\n<h2 id=\"阿里实习\"><a href=\"#阿里实习\" class=\"headerlink\" title=\"阿里实习\"></a>阿里实习</h2><p>5.31号入职的阿里，8.25号离职的<br>学到了很多，也很感谢这一段的时光  </p>\n<h2 id=\"秋招\"><a href=\"#秋招\" class=\"headerlink\" title=\"秋招\"></a>秋招</h2><p>秋招其实我参加的不多  </p>\n<p>网易是当时我比较中意的公司，在8月中旬的时候，特地请假去参加了提前批，感觉面试也比较简单，和想象中的不太一样，我当时以为会问的很难。</p>\n<p>中旬的时候回了一次学校，正好也参加了华为的优招，华为的优招投的部门是华为云，问的也比较一般。</p>\n<p>提前批除了这两个公司，我几乎没有参加其他的，一方面是阿里实在是加班太晚了，怕自己没有时间面试，另一方面也是没有时间去做笔试题。</p>\n<p>离职了阿里之后，那一段时间还是比较慌的，就开始疯狂投简历，但是那段时间其实很多的提前批都已经结束了，比如腾讯，百度等。</p>\n<p>当时网易迟迟不出消息，自己都有点想考研的打算了。</p>\n<p>在9.4号的时候，网易终于来了消息，发的offer。</p>\n<p>这也是我秋招的第一个offer。</p>\n<p><img src=\"/images/2018/网易.png\" alt=\"\">  </p>\n<p>其实当时网易是我比较满意的offer了，一方面觉得自己是SP，不知道哪里来的自信，一方面部门是杭研，传说中的养老部门。</p>\n<p>后面的秋招我就没怎么面试了，面了360企业安全，小米等。</p>\n<p>最终收获了4个offer。</p>\n<ul>\n<li>360企业安全</li>\n<li>小米</li>\n<li>华为</li>\n<li>网易</li>\n</ul>\n<p>选择了网易。</p>\n<h1 id=\"再次实习\"><a href=\"#再次实习\" class=\"headerlink\" title=\"再次实习\"></a>再次实习</h1><p>在10月底的时候，我再次踏上了实习的旅程。<br>其实我不是很想去实习的，但是我妈坚持让我去，原因是提前去可以熟悉环境，和同事领导更熟悉，这样在正式工作的时候会有些优势。<br>同时网易的HR们也很推荐我们去实习，实习超过3个月可以抵两个月的试用期。</p>\n<p>匆匆在杭州租了房子</p>\n<p>开始了3个月的实习生涯</p>\n<p>其实是希望破灭的开始</p>\n<p>我对网易的向往其实是之前我在阿里的时候，一个在网易实习的同学告诉我的，网易叫猪场，食堂很好吃，而且不要钱。<br>下班也很早，不怎么加班。</p>\n<p>然而事实上，网易上班是打卡的，而且是9.30打开。回过头看，比小米和阿里的都早。</p>\n<p>还有个事其实可以小声哔哔下，当时部门结果刚出来的时候，我是很惊讶的，因为部门叫推荐技术部，我们都没有听过这个部门，在HR面试的时候，HR还问我对网易的时序数据库敢不敢兴趣，我以为我要去做数据库相关的东西了。<br>推荐技术部，我网上都搜不到这个部门，让我感觉很恐惧。<br>我于是和HR要了主管的微信，想要了解一下，加了之后，主管其实态度并不很热情，只是匆匆介绍了下部门是做什么的<br>然后我问我去大概是做什么，主管说都是先从运营后台做起。</p>\n<p>万分纠结，其实我当时还挺想去小米的，但是最终还是决定去网易。<br>这个决定让我现在都后悔万分。</p>\n<p>去实习了不久，不出我的所望，做的是一个连产品经理都看不见希望的产品。<br>实习了一半的时候，主管非常激动的说要做类似于一元抽奖的东西，并且说”这个才是拉新的重头“。</p>\n<p>KPI项目，做出来了，当时后端就两个，我和一个同事一起做的。<br>其中也遇到了大的麻烦，Redis中间内存满了一次，导致开始随机删Key。<br>其实最奇怪的一点，让我很怀疑这个主管的能力。<br>他说，“能不能切掉Redis，让数据库抗压力”。<br>现在Redis的定位还仅仅是数据库的缓存吗？</p>\n<p>敢问，现在哪个公司的业务Redis挂了还能正常跑的？</p>\n<p>12月底的时候，网易开始裁员。我在这种基本凉凉的产品组当然瑟瑟发抖。<br>于是我问HR，我们会不会裁员，她信誓旦旦的说，不会的，安心干活儿。</p>\n<p>然后过了几天她就调岗了。换了新的HR。</p>\n<p>我在1.8号的时候离职，回学校做毕设。</p>\n<p>到了大概过完年，组里一个和我玩的很好的产品告诉我，整个部门都要裁了。</p>\n<p>于是我就又开始了找工作生涯。</p>\n<p>其实写到这儿，我的2018已经结束了，下面是2019年的事了，那就等2019年再说吧。</p>\n","categories":["总结"],"tags":["总结"]},{"title":"Things I Don’t Know as of 2018","url":"https://blog.lovezhy.cc/2019/01/01/Things I Don’t Know as of 2018/","content":"<p>创意来自<br><a href=\"https://overreacted.io/things-i-dont-know-as-of-2018/\" target=\"_blank\" rel=\"noopener\">https://overreacted.io/things-i-dont-know-as-of-2018/</a></p>\n<a id=\"more\"></a>\n<ol>\n<li><p>Docker，K8S：自己只是简单使用过Docker，K8S更是只是听过，因为自己很少有需求去部署服务，觉得自己懂一些还是很重要的</p>\n</li>\n<li><p>SpringCloud，Dubbo：也仅仅是知道是什么东西，大概是NetFlix的那一套微服务的东西，但是自己真的没有去系统的学过，对降级和限流什么的，都只是一个很模糊的概念。Rpc和服务治理，之前在美团用过Pigeon，但是Dubbo确实没有尝试过。</p>\n</li>\n<li><p>JavaScript：虽然自己不是很想去学习这个语言，但是有些地方总无法避免的要写一些前端的代码，懂一些还是非常重要的。</p>\n</li>\n<li><p>Vue：虽然自己用过Vue，但是最多只是当做一个库引入JS，而不是像现在的前端的工程化，NPM的那一套东西，WIKI文档自己也没有系统的看过。</p>\n</li>\n<li><p>Go：虽然很早就在看教程了，但是也仅仅局限于基础的语法，一些系统库和常见的框架还是不会，自己想要去看TIDB的代码，很有必要去深入的学习一下。</p>\n</li>\n<li><p>Service Mesh：自己之前找时间看了一下介绍，但是还是一头雾水，不知道在讲什么。</p>\n</li>\n<li><p>操作系统：越来越觉得操作系统是个很重要，东西很多的东西，自己不能局限于国内学校本科教会的那些，包括cgroup等这些很重要的API的实现</p>\n</li>\n<li><p>ES，Lucene：自己也仅仅听过，知道其实运用很广泛。</p>\n</li>\n<li><p>JVM：看过深入理解JVM，但是一直想要从源码层次去学习</p>\n</li>\n<li><p>Kafka：看过同事用过，自己也用过，但是对原理不是很了解</p>\n</li>\n<li><p>Netty：源码还没看完 </p>\n</li>\n<li><p>Zookeeper：源码下下来了，但是还没看过</p>\n</li>\n<li><p>Nginx：很惭愧，这个可能连配置我都不懂</p>\n</li>\n<li><p>函数式：SICP我也没看得下去，一直听大佬们说monad什么的，scala也是因为找不到写代码的场景而弃了好久了</p>\n</li>\n<li><p>RabbitMQ：仅仅听过和看同事用过，知道消息队列的用处</p>\n</li>\n<li><p>HDFS：Hadoop生态中对这个最底层的文件存储很感兴趣，可以去学习一番</p>\n</li>\n<li><p>CodeGen：目前知道的是基于APT和ASM的实现，但是自己对APT和ASM都不甚了解</p>\n</li>\n</ol>\n","categories":["总结"],"tags":["年度总结"]},{"title":"WebFlux性能问题和适用场景","url":"https://blog.lovezhy.cc/2018/12/29/webflux性能问题/","content":"<p>Spring5的主推功能可能就是WebFlux了<br>但是网上一堆人吹捧性能完爆SpringMVC似乎有点过头了</p>\n<p>结论就是WebFlux的线程模型不同，所以适应场景也不同<br>SpringMVC并不是互相替代的关系(个人感觉)<br><a id=\"more\"></a></p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><p>使用我推荐看这个视频<br><a href=\"https://www.youtube.com/watch?v=zVNIZXf4BG8&amp;t=2947s&amp;frags=pl%2Cwn\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=zVNIZXf4BG8&amp;t=2947s&amp;frags=pl%2Cwn</a></p>\n<p>简单易懂</p>\n<h1 id=\"细节问题\"><a href=\"#细节问题\" class=\"headerlink\" title=\"细节问题\"></a>细节问题</h1><h2 id=\"Web容器\"><a href=\"#Web容器\" class=\"headerlink\" title=\"Web容器\"></a>Web容器</h2><p>如果你同时引入的是<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>\n<p>那么默认的Web容器就是Tomcat</p>\n<p>如果想要使用Netty作为容器，那么可以在web模块中手动把Tomcat去除<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;exclusions&gt;</span><br><span class=\"line\">        &lt;&lt;exclusion&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;/exclusion&gt;</span><br><span class=\"line\">    &lt;/exclusions&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"内部依赖\"><a href=\"#内部依赖\" class=\"headerlink\" title=\"内部依赖\"></a>内部依赖</h2><p>其实看官方的图就会很费解，为啥WebFlux吹捧的是Reactive编程，却能跑在Tomcat上  </p>\n<p>为此我去翻看了文档</p>\n<p>如果Web容器使用的是Tomcat，那么就是使用Reactor桥接的servlet async api<br>如果Web容器是Netty，那么就是使用的Netty，天生支持Reactive</p>\n<p>所以官方的推荐还是使用Netty跑WebFlux  </p>\n<p>而用Netty跑SpringMVC行不行呢，也是可以的，但是性能并不会很好，主要是Tomcat是暴力创建线程，但是Netty默认线程数量较少</p>\n<h1 id=\"Reavtive代码\"><a href=\"#Reavtive代码\" class=\"headerlink\" title=\"Reavtive代码\"></a>Reavtive代码</h1><p>其实这是第二个误区，很多人以为只要我们在Controller中返回的是Mono或者Flux，性能就会得到提升<br>不存在的<br>如果你要使用WebFlux，那么对不起，从Dao到Service，全部都要是Mono和Flux。<br>目前官方的数据层Reactive框架只支持Redis，Mongo等几个，<strong>没有JDBC</strong><br>所以你的代码是JDBC，想要迁移到WebFlux并指望性能提升，那你可能要失望了  </p>\n<p>不过值得庆幸的是，JDBC的Reactive正在开发中，虽然尚不成熟，但是可以关注一下  </p>\n<h1 id=\"性能和迁移\"><a href=\"#性能和迁移\" class=\"headerlink\" title=\"性能和迁移\"></a>性能和迁移</h1><p>这个其实是值得商榷的问题<br>因为性能和很多因素有关  </p>\n<ul>\n<li>Web容器的线程模型  这个Tomcat和Netty不一样</li>\n<li>Web容器的线程个数 Tomcat默认200个Nio线程，但是Netty默认可能只有核心数*2</li>\n<li>业务代码，如果是IO操作较多，Netty模型可能比较适合，如果是业务阻塞较多，默认的Tomcat可能比较适合，Netty可能需要较多的冗余代码和调优，且性能可能不会有较大提升</li>\n</ul>\n<p>既然性能和这么多因素有关，所以官方也没有打包票WebFlux碾压SpringMVC</p>\n<p>关于迁移，文档是这么写的</p>\n<blockquote>\n<p>If you have a Spring MVC application that works fine, there is no need to change. Imperative programming is the easiest way to write, understand, and debug code. You have maximum choice of libraries, since, historically, most are blocking.</p>\n</blockquote>\n<p>这句话翻译过来就是<br>如果你的代码中有任何阻塞操作，请谨慎选择WebFlux</p>\n<p>关于性能</p>\n<blockquote>\n<p>Performance has many characteristics and meanings. Reactive and non-blocking generally do not make applications run faster. They can, in some cases, (for example, if using the WebClient to execute remote calls in parallel). On the whole, it requires more work to do things the non-blocking way and that can increase slightly the required processing time.</p>\n<p>The key expected benefit of reactive and non-blocking is the ability to scale with a small, fixed number of threads and less memory. That makes applications more resilient under load, because they scale in a more predictable way. In order to observe those benefits, however, you need to have some latency (including a mix of slow and unpredictable network I/O). That is where the reactive stack begins to show its strengths, and the differences can be dramatic.  </p>\n</blockquote>\n<p>WebFlux并不保证应用能运行的更快，但是它主打的是scale和低内存消耗<br>它的性能需要在一些特定的场景才能展现，比如慢网络IO的情况</p>\n<h1 id=\"惨痛的测试过程\"><a href=\"#惨痛的测试过程\" class=\"headerlink\" title=\"惨痛的测试过程\"></a>惨痛的测试过程</h1><p>看起来可能会有点乱，而且也并不是很权威，个人建议直接跳过这一节，去看结论</p>\n<h2 id=\"第一轮\"><a href=\"#第一轮\" class=\"headerlink\" title=\"第一轮\"></a>第一轮</h2><p>其实为啥写这个文章，就是我开始很开心的想要看看WebFlux到底比SpringMVC强多少  </p>\n<p>然后写出了下面的代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"/hello\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Map&lt;String, String&gt; <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">5</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Collections.singletonMap(<span class=\"string\">\"Hello\"</span>, <span class=\"string\">\"world\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"/reactor\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> Mono&lt;Map&lt;String, String&gt;&gt; reactor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Mono.create( sink -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">5</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sink.success(Collections.singletonMap(<span class=\"string\">\"Hello\"</span>, <span class=\"string\">\"world\"</span>));</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">» wrk -t30 -c3000 -d60s http://127.0.0.1:8080/hello --latency</span><br><span class=\"line\">Running 1m <span class=\"built_in\">test</span> @ http://127.0.0.1:8080/hello</span><br><span class=\"line\">  30 threads and 3000 connections</span><br><span class=\"line\">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class=\"line\">    Latency    89.76ms   56.33ms 401.67ms   61.64%</span><br><span class=\"line\">    Req/Sec   628.19    383.30     3.88k    81.15%</span><br><span class=\"line\">  Latency Distribution</span><br><span class=\"line\">     50%   89.00ms</span><br><span class=\"line\">     75%  132.28ms</span><br><span class=\"line\">     90%  161.62ms</span><br><span class=\"line\">     99%  229.86ms</span><br><span class=\"line\">  1027462 requests <span class=\"keyword\">in</span> 1.00m, 153.02MB <span class=\"built_in\">read</span></span><br><span class=\"line\">  Socket errors: connect 0, <span class=\"built_in\">read</span> 3283, write 0, timeout 0</span><br><span class=\"line\">Requests/sec:  17095.73</span><br><span class=\"line\">Transfer/sec:      2.55MB</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">» wrk -t30 -c3000 -d60s http://127.0.0.1:8080/reactor --latency</span><br><span class=\"line\">Running 1m <span class=\"built_in\">test</span> @ http://127.0.0.1:8080/reactor</span><br><span class=\"line\">  30 threads and 3000 connections</span><br><span class=\"line\">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class=\"line\">    Latency   100.82ms   65.39ms 451.83ms   65.85%</span><br><span class=\"line\">    Req/Sec   438.16    321.89     2.96k    80.20%</span><br><span class=\"line\">  Latency Distribution</span><br><span class=\"line\">     50%   94.37ms</span><br><span class=\"line\">     75%  146.32ms</span><br><span class=\"line\">     90%  185.54ms</span><br><span class=\"line\">     99%  281.39ms</span><br><span class=\"line\">  739620 requests <span class=\"keyword\">in</span> 1.00m, 110.15MB <span class=\"built_in\">read</span></span><br><span class=\"line\">  Socket errors: connect 0, <span class=\"built_in\">read</span> 2524, write 0, timeout 0</span><br><span class=\"line\">Requests/sec:  12306.22</span><br><span class=\"line\">Transfer/sec:      1.83MB</span><br></pre></td></tr></table></figure>\n<p>发现WebFlux性能反而不如SpringMVC，这里标注一点，Mono.create里面的逻辑，还是tomcat的线程去执行的<br>其实我想了想这里进行Sleep应该不是很合理，因为sleep算是个block操作</p>\n<p>继而我手动发布到parallel中，虽然我在官方的例子中没有看过这种写法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"/reactor\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> Mono&lt;Map&lt;String, String&gt;&gt; reactor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Mono.&lt;Map&lt;String, String&gt;&gt;create(sink -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">5</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sink.success(Collections.singletonMap(<span class=\"string\">\"Hello\"</span>, <span class=\"string\">\"world\"</span>));</span><br><span class=\"line\">    &#125;).publishOn(Schedulers.parallel());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">» wrk -t30 -c3000 -d60s http://127.0.0.1:8080/reactor --latency</span><br><span class=\"line\">Running 1m <span class=\"built_in\">test</span> @ http://127.0.0.1:8080/reactor</span><br><span class=\"line\">  30 threads and 3000 connections</span><br><span class=\"line\">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class=\"line\">    Latency   122.59ms   81.11ms 634.86ms   66.16%</span><br><span class=\"line\">    Req/Sec   378.94    246.55     2.56k    79.17%</span><br><span class=\"line\">  Latency Distribution</span><br><span class=\"line\">     50%  110.07ms</span><br><span class=\"line\">     75%  175.18ms</span><br><span class=\"line\">     90%  236.01ms</span><br><span class=\"line\">     99%  344.06ms</span><br><span class=\"line\">  662844 requests <span class=\"keyword\">in</span> 1.00m, 98.71MB <span class=\"built_in\">read</span></span><br><span class=\"line\">  Socket errors: connect 0, <span class=\"built_in\">read</span> 3813, write 0, timeout 0</span><br><span class=\"line\">Requests/sec:  11029.13</span><br><span class=\"line\">Transfer/sec:      1.64MB</span><br></pre></td></tr></table></figure>\n<p>可以看到性能反而变慢了，因为Schedulers.parallel()默认只有8线程在运行，于是我手动改成30</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">» wrk -t30 -c3000 -d60s http://127.0.0.1:8080/reactor --latency</span><br><span class=\"line\">Running 1m <span class=\"built_in\">test</span> @ http://127.0.0.1:8080/reactor</span><br><span class=\"line\">  30 threads and 3000 connections</span><br><span class=\"line\">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class=\"line\">    Latency   132.54ms   87.81ms 691.34ms   69.49%</span><br><span class=\"line\">    Req/Sec   390.05    258.97     2.97k    74.94%</span><br><span class=\"line\">  Latency Distribution</span><br><span class=\"line\">     50%  116.71ms</span><br><span class=\"line\">     75%  183.79ms</span><br><span class=\"line\">     90%  251.33ms</span><br><span class=\"line\">     99%  401.91ms</span><br><span class=\"line\">  678598 requests <span class=\"keyword\">in</span> 1.00m, 101.06MB <span class=\"built_in\">read</span></span><br><span class=\"line\">  Socket errors: connect 0, <span class=\"built_in\">read</span> 4059, write 0, timeout 0</span><br><span class=\"line\">Requests/sec:  11291.03</span><br><span class=\"line\">Transfer/sec:      1.68MB</span><br></pre></td></tr></table></figure>\n<p>可以看到结果其实差别并不大，瓶颈应该不在这里，或者WebFlux在publicOn做了什么调用</p>\n<h2 id=\"第二轮\"><a href=\"#第二轮\" class=\"headerlink\" title=\"第二轮\"></a>第二轮</h2><p>第二轮我修改了测试案例，换成了从Redis中取值的操作<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> ReactiveRedisTemplate&lt;String, String&gt; reactiveRedisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HelloController</span><span class=\"params\">(ReactiveRedisTemplate&lt;String, String&gt; reactiveRedisTemplate, StringRedisTemplate stringRedisTemplate)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.reactiveRedisTemplate = reactiveRedisTemplate;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> List&lt;String&gt; keys = Arrays.asList(<span class=\"string\">\"name1\"</span>, <span class=\"string\">\"name2\"</span>, <span class=\"string\">\"name3\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"/hello\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stringRedisTemplate.opsForValue().multiGet(keys);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"/reactor\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> Mono&lt;List&lt;String&gt;&gt; reactor() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> reactiveRedisTemplate.opsForValue().multiGet(keys);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">» wrk -t30 -c3000 -d60s http://127.0.0.1:8080/hello --latency</span><br><span class=\"line\">Running 1m <span class=\"built_in\">test</span> @ http://127.0.0.1:8080/hello</span><br><span class=\"line\">  30 threads and 3000 connections</span><br><span class=\"line\">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class=\"line\">    Latency   110.62ms   57.26ms 279.77ms   65.42%</span><br><span class=\"line\">    Req/Sec   467.92    327.19     4.65k    85.21%</span><br><span class=\"line\">  Latency Distribution</span><br><span class=\"line\">     50%  109.25ms</span><br><span class=\"line\">     75%  155.67ms</span><br><span class=\"line\">     90%  182.36ms</span><br><span class=\"line\">     99%  234.64ms</span><br><span class=\"line\">  808566 requests <span class=\"keyword\">in</span> 1.00m, 128.90MB <span class=\"built_in\">read</span></span><br><span class=\"line\">  Socket errors: connect 0, <span class=\"built_in\">read</span> 4070, write 0, timeout 0</span><br><span class=\"line\">Requests/sec:  13453.13</span><br><span class=\"line\">Transfer/sec:      2.14MB</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">» wrk -t30 -c3000 -d60s http://127.0.0.1:8080/reactor --latency</span><br><span class=\"line\">Running 1m <span class=\"built_in\">test</span> @ http://127.0.0.1:8080/reactor</span><br><span class=\"line\">  30 threads and 3000 connections</span><br><span class=\"line\">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class=\"line\">    Latency   236.17ms  113.54ms 650.53ms   68.95%</span><br><span class=\"line\">    Req/Sec   293.21    161.31     5.09k    81.31%</span><br><span class=\"line\">  Latency Distribution</span><br><span class=\"line\">     50%  251.06ms</span><br><span class=\"line\">     75%  313.69ms</span><br><span class=\"line\">     90%  352.13ms</span><br><span class=\"line\">     99%  521.69ms</span><br><span class=\"line\">  505806 requests <span class=\"keyword\">in</span> 1.00m, 80.62MB <span class=\"built_in\">read</span></span><br><span class=\"line\">  Socket errors: connect 0, <span class=\"built_in\">read</span> 3535, write 0, timeout 0</span><br><span class=\"line\">Requests/sec:   8416.85</span><br><span class=\"line\">Transfer/sec:      1.34MB</span><br></pre></td></tr></table></figure>\n<p>可以看到性能还是很低，甚至差别略大  </p>\n<p>于是我还是改成手动publish<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">» wrk -t30 -c3000 -d60s http://127.0.0.1:8080/reactor --latency</span><br><span class=\"line\">Running 1m <span class=\"built_in\">test</span> @ http://127.0.0.1:8080/reactor</span><br><span class=\"line\">  30 threads and 3000 connections</span><br><span class=\"line\">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class=\"line\">    Latency   228.61ms  101.83ms 666.54ms   70.65%</span><br><span class=\"line\">    Req/Sec   293.82    148.63     1.98k    75.36%</span><br><span class=\"line\">  Latency Distribution</span><br><span class=\"line\">     50%  237.21ms</span><br><span class=\"line\">     75%  287.44ms</span><br><span class=\"line\">     90%  335.04ms</span><br><span class=\"line\">     99%  526.61ms</span><br><span class=\"line\">  499892 requests <span class=\"keyword\">in</span> 1.00m, 79.68MB <span class=\"built_in\">read</span></span><br><span class=\"line\">  Socket errors: connect 0, <span class=\"built_in\">read</span> 3198, write 0, timeout 0</span><br><span class=\"line\">Requests/sec:   8317.62</span><br><span class=\"line\">Transfer/sec:      1.33MB</span><br></pre></td></tr></table></figure></p>\n<p>发现其实区别还是不大</p>\n<p>既然把pool改成30呢<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">» wrk -t30 -c3000 -d60s http:<span class=\"comment\">//127.0.0.1:8080/reactor --latency</span></span><br><span class=\"line\">Running <span class=\"number\">1</span>m test @ http:<span class=\"comment\">//127.0.0.1:8080/reactor</span></span><br><span class=\"line\">  <span class=\"number\">30</span> threads and <span class=\"number\">3000</span> connections</span><br><span class=\"line\">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class=\"line\">    Latency   <span class=\"number\">212.81</span>ms   <span class=\"number\">94.51</span>ms <span class=\"number\">709.88</span>ms   <span class=\"number\">69.39</span>%</span><br><span class=\"line\">    Req/Sec   <span class=\"number\">290.22</span>    <span class=\"number\">151.03</span>     <span class=\"number\">2.57</span>k    <span class=\"number\">77.73</span>%</span><br><span class=\"line\">  Latency Distribution</span><br><span class=\"line\">     <span class=\"number\">50</span>%  <span class=\"number\">214.93</span>ms</span><br><span class=\"line\">     <span class=\"number\">75</span>%  <span class=\"number\">262.16</span>ms</span><br><span class=\"line\">     <span class=\"number\">90</span>%  <span class=\"number\">317.48</span>ms</span><br><span class=\"line\">     <span class=\"number\">99</span>%  <span class=\"number\">479.01</span>ms</span><br><span class=\"line\">  <span class=\"number\">508591</span> requests in <span class=\"number\">1.00</span>m, <span class=\"number\">81.07</span>MB read</span><br><span class=\"line\">  Socket errors: connect <span class=\"number\">0</span>, read <span class=\"number\">3190</span>, write <span class=\"number\">0</span>, timeout <span class=\"number\">0</span></span><br><span class=\"line\">Requests/sec:   <span class=\"number\">8462.78</span></span><br><span class=\"line\">Transfer/sec:      <span class=\"number\">1.35</span>MB</span><br></pre></td></tr></table></figure></p>\n<p>还是差别不大，所以问题的关键应该不在这儿。</p>\n<h2 id=\"第三轮\"><a href=\"#第三轮\" class=\"headerlink\" title=\"第三轮\"></a>第三轮</h2><p>第三轮把容器改成了Netty<br>改为Netty之后有个要注意的就是Web容器的线程不会疯狂的进行创建了，一般就是核心数或者核心数*2</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">» wrk -t30 -c3000 -d60s http://127.0.0.1:8080/hello --latency</span><br><span class=\"line\">Running 1m <span class=\"built_in\">test</span> @ http://127.0.0.1:8080/hello</span><br><span class=\"line\">  30 threads and 3000 connections</span><br><span class=\"line\">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class=\"line\">    Latency    63.26ms   38.60ms   1.99s    83.37%</span><br><span class=\"line\">    Req/Sec   467.59    453.97     6.27k    85.41%</span><br><span class=\"line\">  Latency Distribution</span><br><span class=\"line\">     50%   65.65ms</span><br><span class=\"line\">     75%   83.72ms</span><br><span class=\"line\">     90%   93.78ms</span><br><span class=\"line\">     99%  129.69ms</span><br><span class=\"line\">  747480 requests <span class=\"keyword\">in</span> 1.00m, 80.55MB <span class=\"built_in\">read</span></span><br><span class=\"line\">  Socket errors: connect 0, <span class=\"built_in\">read</span> 4343, write 1, timeout 874</span><br><span class=\"line\">Requests/sec:  12437.61</span><br><span class=\"line\">Transfer/sec:      1.34MB</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">» wrk -t30 -c3000 -d60s http://127.0.0.1:8080/reactor --latency</span><br><span class=\"line\">Running 1m <span class=\"built_in\">test</span> @ http://127.0.0.1:8080/reactor</span><br><span class=\"line\">  30 threads and 3000 connections</span><br><span class=\"line\">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class=\"line\">    Latency   156.88ms   74.43ms 527.17ms   66.33%</span><br><span class=\"line\">    Req/Sec   431.27    207.17     5.08k    82.32%</span><br><span class=\"line\">  Latency Distribution</span><br><span class=\"line\">     50%  176.96ms</span><br><span class=\"line\">     75%  211.25ms</span><br><span class=\"line\">     90%  236.23ms</span><br><span class=\"line\">     99%  312.83ms</span><br><span class=\"line\">  762879 requests <span class=\"keyword\">in</span> 1.00m, 82.21MB <span class=\"built_in\">read</span></span><br><span class=\"line\">  Socket errors: connect 0, <span class=\"built_in\">read</span> 3419, write 0, timeout 0</span><br><span class=\"line\">Requests/sec:  12694.40</span><br><span class=\"line\">Transfer/sec:      1.37MB</span><br></pre></td></tr></table></figure>\n<p>和上面的tomcat相比，SpringMVC会比较糟糕，这个也是可以预见的，因为Redis中阻塞的EventLoop<br>WebFlux的性能超过了SpringMVC，同时注意看WebFlux超时为0，而SpringMVC伴随着大量的超时</p>\n<p>横向进行对比的话，SpringMVC的性能还是进行了下降<br>但是WebFlux却有很大的提升</p>\n<p>修改默认的EventLoop大小呢<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.setProperty(<span class=\"string\">\"reactor.schedulers.defaultPoolSize\"</span>, <span class=\"string\">\"30\"</span>);</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">» wrk -t30 -c3000 -d60s http://127.0.0.1:8080/hello --latency</span><br><span class=\"line\">Running 1m <span class=\"built_in\">test</span> @ http://127.0.0.1:8080/hello</span><br><span class=\"line\">  30 threads and 3000 connections</span><br><span class=\"line\">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class=\"line\">    Latency    61.56ms   35.75ms   1.98s    84.77%</span><br><span class=\"line\">    Req/Sec   484.48    503.66     8.98k    88.50%</span><br><span class=\"line\">  Latency Distribution</span><br><span class=\"line\">     50%   65.20ms</span><br><span class=\"line\">     75%   80.28ms</span><br><span class=\"line\">     90%   90.15ms</span><br><span class=\"line\">     99%  113.19ms</span><br><span class=\"line\">  764109 requests <span class=\"keyword\">in</span> 1.00m, 82.34MB <span class=\"built_in\">read</span></span><br><span class=\"line\">  Socket errors: connect 0, <span class=\"built_in\">read</span> 4749, write 2, timeout 916</span><br><span class=\"line\">Requests/sec:  12713.41</span><br><span class=\"line\">Transfer/sec:      1.37MB</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">» wrk -t30 -c3000 -d60s http://127.0.0.1:8080/reactor --latency</span><br><span class=\"line\">Running 1m <span class=\"built_in\">test</span> @ http://127.0.0.1:8080/reactor</span><br><span class=\"line\">  30 threads and 3000 connections</span><br><span class=\"line\">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class=\"line\">    Latency   117.43ms   58.73ms 310.79ms   65.99%</span><br><span class=\"line\">    Req/Sec   464.75    350.25     8.26k    84.65%</span><br><span class=\"line\">  Latency Distribution</span><br><span class=\"line\">     50%  116.12ms</span><br><span class=\"line\">     75%  160.88ms</span><br><span class=\"line\">     90%  192.55ms</span><br><span class=\"line\">     99%  257.21ms</span><br><span class=\"line\">  803283 requests <span class=\"keyword\">in</span> 1.00m, 86.57MB <span class=\"built_in\">read</span></span><br><span class=\"line\">  Socket errors: connect 0, <span class=\"built_in\">read</span> 3011, write 0, timeout 0</span><br><span class=\"line\">Requests/sec:  13366.05</span><br><span class=\"line\">Transfer/sec:      1.44MB</span><br></pre></td></tr></table></figure>\n<p>可以看到SpringMVC基本没变，同时带有大量的超时<br>但是WebFlux性能有提升，同时超时个数依旧为0  </p>\n<p>同时，发现无论怎么设置，都无法超过第二轮Tomcat的值</p>\n<h2 id=\"第四轮\"><a href=\"#第四轮\" class=\"headerlink\" title=\"第四轮\"></a>第四轮</h2><p>比较一下Tomcat的阻塞模型和Netty的非阻塞模型，在线程差不多的情况下的性能<br>增加配置<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.tomcat.max-threads=<span class=\"number\">20</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">» wrk -t30 -c3000 -d60s http://127.0.0.1:8080/hello --latency</span><br><span class=\"line\">Running 1m <span class=\"built_in\">test</span> @ http://127.0.0.1:8080/hello</span><br><span class=\"line\">  30 threads and 3000 connections</span><br><span class=\"line\">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class=\"line\">    Latency   119.35ms   73.88ms 323.07ms   61.31%</span><br><span class=\"line\">    Req/Sec   429.58    428.04     8.30k    89.22%</span><br><span class=\"line\">  Latency Distribution</span><br><span class=\"line\">     50%  124.08ms</span><br><span class=\"line\">     75%  179.28ms</span><br><span class=\"line\">     90%  215.99ms</span><br><span class=\"line\">     99%  268.68ms</span><br><span class=\"line\">  713803 requests <span class=\"keyword\">in</span> 1.00m, 113.80MB <span class=\"built_in\">read</span></span><br><span class=\"line\">  Socket errors: connect 0, <span class=\"built_in\">read</span> 3452, write 0, timeout 0</span><br><span class=\"line\">Requests/sec:  11876.60</span><br><span class=\"line\">Transfer/sec:      1.89MB</span><br></pre></td></tr></table></figure>\n<p>会发现WebFlux的表现要好的多</p>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>WebFlux相对于SpringMVC下的优点</p>\n<ul>\n<li>同样的性能场景消耗的资源更少</li>\n<li>适合横向扩展</li>\n</ul>\n<p>所以总结一下WebFlux什么场景下可以替换SpringMVC呢</p>\n<ul>\n<li>想要内存和线程数较少的场景</li>\n<li>网络较慢或者IO会经常出现问题的场景</li>\n</ul>\n<p>但是WebFlux需要</p>\n<ul>\n<li>非阻塞的业务代码，如果阻塞，需要自己开线程池去运行</li>\n</ul>\n<h1 id=\"混写\"><a href=\"#混写\" class=\"headerlink\" title=\"混写\"></a>混写</h1><p>其实SpringMVC和WebFlux混写个人感觉不会太好<br>因为SpringMVC一般配合的是业务阻塞较多，如果配合Netty，可能会阻塞EventLoop，编程压力较大，配合Tomcat，疯狂开线程就行<br>WebFlux还是比较适合Netty，Reactor模式，业务不能阻塞IO线程，如果业务阻塞操作较多，可能需要自己去单独开线程池去运行，编程较为复杂，所以业务那边，需要框架支持非阻塞运行<br>那WebFlux跑在Tomcat中呢，我觉得是可以的，但是感觉很变扭<br>WebClient例外，那个就是AsyncHttpClient，和Tomcat没啥关系  </p>\n<h1 id=\"未来与展望\"><a href=\"#未来与展望\" class=\"headerlink\" title=\"未来与展望\"></a>未来与展望</h1><p>WebFlux更多的是对标的Vertx，但是没有Vertx完善<br>好在支持自己的IOC和AOP<br>等JDBC支持异步的库完善了，可以用来写纯异步的轻量级应用 </p>\n","categories":["Spring和SpringBoot"],"tags":["Spring"]},{"title":"Counted B+Tree原理","url":"https://blog.lovezhy.cc/2018/12/17/Counted-B+Tree原理/","content":"<p>B树的一种变形，和B+树有点相近但是实现不一样</p>\n<a id=\"more\"></a>\n<h1 id=\"B-Tree\"><a href=\"#B-Tree\" class=\"headerlink\" title=\"B-Tree\"></a>B-Tree</h1><p><img src=\"/images/Counted-B-Tree原理/B-Tree.png\" alt=\"\"><br>上面是典型的一个B-Tree的结构<br>如果我们知道B-Tree的改进版B+Tree的话，就知道纯粹的B-Tree其实是有缺点的</p>\n<p>如果我们要取排名第X的元素，那么其实需要进行中序遍历<br>如果我们需要一段范围内的元素，那么还是需要进行中序遍历</p>\n<h1 id=\"B-Tree-1\"><a href=\"#B-Tree-1\" class=\"headerlink\" title=\"B+Tree\"></a>B+Tree</h1><p><img src=\"/images/Counted-B-Tree原理/B+Tree.png\" alt=\"\"><br>但是B+Tree提出了一种解决方案(当然还有其他的原因，磁盘的出入度之类)<br>它把所有的元素放在叶子节点，然后全部用指针串起来。</p>\n<p>但是这样还是有一个问题，我们寻找第X个，其实最差的情况下是O(n)的，因为必须从头开始寻找，而且必须把Page的数据全部读取出来，很有可能我们要的数据并不在这个Page上<br>还有一个问题，就是如果我们要倒数后10个元素，因为底层的指针是单方向的，所以无法从后往前。</p>\n<h1 id=\"Counted-B-Tree\"><a href=\"#Counted-B-Tree\" class=\"headerlink\" title=\"Counted-B-Tree\"></a>Counted-B-Tree</h1><p><img src=\"/images/Counted-B-Tree原理/Counted-B-Tree.png\" alt=\"\"><br>上面就是本文要讲的Counted-B-Tree了<br>每个父节点记录了子节点的元素个数<br>这样我们在寻找第X个元素的时候，不需要进行遍历<br>在寻找一段范围的元素的时候，也可以进行<br>同时如果是逆序的查找，其实也可以很快的进行，只要考虑每个节点是从左往右还是从右往左就行</p>\n<p>但是如果你说从B+Tree的磁盘存储角度讲的话，由于数据还是放在元素节点中，所以进行Page读取的话，还是会把很多不需要的值读取出来</p>\n<h1 id=\"Counted-B-Tree-1\"><a href=\"#Counted-B-Tree-1\" class=\"headerlink\" title=\"Counted-B+Tree\"></a>Counted-B+Tree</h1><p>在H2Database中<br>他的Page结构就结合了B+Tree和Counted-B-Tree<br>他的结构类似于这种<br><img src=\"/images/Counted-B-Tree原理/mv.png\" alt=\"\"><br>对于磁盘存储而言，维护了很好的出入度，同时对于第X个查找和范围查找又维持了很好的效率</p>\n<h1 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h1><p><a href=\"https://www.chiark.greenend.org.uk/~sgtatham/algorithms/cbtree.html\" target=\"_blank\" rel=\"noopener\">https://www.chiark.greenend.org.uk/~sgtatham/algorithms/cbtree.html</a>  </p>\n<p><a href=\"http://directory.apache.org/mavibot/user-guide/2-btree-types.html\" target=\"_blank\" rel=\"noopener\">http://directory.apache.org/mavibot/user-guide/2-btree-types.html</a></p>\n<p><a href=\"https://www.kancloud.cn/kancloud/theory-of-mysql-index/41846\" target=\"_blank\" rel=\"noopener\">https://www.kancloud.cn/kancloud/theory-of-mysql-index/41846</a></p>\n","categories":["数据库"],"tags":["数据库"]},{"title":"double精度踩坑","url":"https://blog.lovezhy.cc/2018/12/11/double精度踩坑/","content":"<p>double精度踩坑以及总结的实践</p>\n<a id=\"more\"></a>\n<h2 id=\"double运算不精确\"><a href=\"#double运算不精确\" class=\"headerlink\" title=\"double运算不精确\"></a>double运算不精确</h2><p>项目中的运算是这么个流程</p>\n<ol>\n<li><code>82.0 / 10 =&gt; 8.2</code>  第一步是没有什么问题的</li>\n<li><code>8.2 * 100 =&gt; 819.9999999999999</code> 这一步出现问题了  </li>\n</ol>\n<p>然后我去结果进行了int的取整操作，得到了819。</p>\n<p>当然我考虑了精度问题，但是是对819.9999999999999套上了BigDecimal，取值的时候选择了向下取整，结果还是819。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>解决方案还是BigDemical，这个是没有办法的。 </p>\n<p>但是BigDemical到底要用到什么程度呢</p>\n<p>比如上面的改成<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BigDecimal.valueOf(<span class=\"number\">82</span>).divide(BigDecimal.valueOf(<span class=\"number\">10</span>)).multiply(BigDecimal.valueOf(<span class=\"number\">100</span>)).intValue()</span><br></pre></td></tr></table></figure></p>\n<p>当然是没有问题的，但是未免太麻烦。</p>\n<p>对比几个精度缺失的问题，我发现都是最后的一位不精确，相差的都是<code>0.00...X</code>的位数<br>所以我觉得可以在最后一个double进行BigDecimal，设置精度，然后进行四舍五入取整。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> k = <span class=\"number\">1.1</span> + <span class=\"number\">0.1</span>;</span><br><span class=\"line\">System.out.println(k); =&gt; <span class=\"number\">1.2000000000000002</span></span><br><span class=\"line\">System.out.println(BigDecimal.valueOf(k).setScale(<span class=\"number\">4</span>, RoundingMode.HALF_UP).doubleValue()); =&gt; <span class=\"number\">1.2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">double</span> k = <span class=\"number\">82.0</span> / <span class=\"number\">10</span> * <span class=\"number\">100</span>;</span><br><span class=\"line\">System.out.println(k); =&gt; <span class=\"number\">819.9999999999999</span></span><br><span class=\"line\">System.out.println(BigDecimal.valueOf(k).setScale(<span class=\"number\">4</span>, RoundingMode.HALF_UP).doubleValue()); =&gt; <span class=\"number\">820.0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">double</span> k = <span class=\"number\">0.06</span> + <span class=\"number\">0.01</span>;</span><br><span class=\"line\">System.out.println(k); =&gt; <span class=\"number\">0.06999999999999999</span></span><br><span class=\"line\">System.out.println(BigDecimal.valueOf(k).setScale(<span class=\"number\">4</span>, RoundingMode.HALF_UP).doubleValue()); =&gt; <span class=\"number\">0.07</span></span><br></pre></td></tr></table></figure>\n<p>当然验证的几个都是正确的。 </p>\n<p>问题也很明显，那个setScale参数我是写死的，都是4。<br>当精度比4小或者比4大都会出现问题<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> k = <span class=\"number\">0.0000006</span> + <span class=\"number\">0.0000001</span>;</span><br><span class=\"line\">System.out.println(BigDecimal.valueOf(k).setScale(<span class=\"number\">4</span>, RoundingMode.HALF_UP).doubleValue()); =&gt; <span class=\"number\">0.0</span></span><br><span class=\"line\">System.out.println(BigDecimal.valueOf(k).setScale(<span class=\"number\">10</span>, RoundingMode.HALF_UP).doubleValue()); =&gt; <span class=\"number\">7.0E-7</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">double</span> k = <span class=\"number\">8.2</span> * <span class=\"number\">100000000000L</span>;</span><br><span class=\"line\">System.out.println(k); =&gt; <span class=\"number\">8.199999999999999E11</span></span><br><span class=\"line\">System.out.println(BigDecimal.valueOf(k).setScale(<span class=\"number\">4</span>, RoundingMode.HALF_UP).doubleValue()); =&gt; <span class=\"number\">8.199999999999999E11</span></span><br><span class=\"line\">System.out.println(BigDecimal.valueOf(k).setScale(<span class=\"number\">1</span>, RoundingMode.HALF_UP).doubleValue()); =&gt; <span class=\"number\">8.2E11</span></span><br></pre></td></tr></table></figure></p>\n<p>其实还是要了解scale代表着什么意思<br>是小数点后的精度的问题</p>\n<p>但是如果数字过小，那么scale就要设置的大一点<br>就比如<code>0.0000006 + 0.0000001</code>其实已经到小数点后7位了，设置4位的肯定不行</p>\n<p>但是作为Double，有效位数是16，如果小数点前的数字过多，那么其实scale设置得大也没用<br>而<code>8.2 * 100000000000L</code>的结果是<code>81999_9999_999.9999</code>这里即使我们设置到scale=4，后面其实已经没有数字了，所以得到的结果还是81999..</p>\n<p>那么似乎好像我们拿到scale就行了，把scale设置的比原始的小一点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> k = <span class=\"number\">8.2</span> * <span class=\"number\">100000000000L</span>;</span><br><span class=\"line\">System.out.println(k); =&gt; <span class=\"number\">8.199999999999999E11</span></span><br><span class=\"line\">BigDecimal decimal = BigDecimal.valueOf(k);</span><br><span class=\"line\">System.out.println(decimal.setScale(decimal.scale() - <span class=\"number\">1</span>, RoundingMode.HALF_UP).doubleValue()); =&gt; <span class=\"number\">8.2E11</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">double</span> k = <span class=\"number\">1.1</span> + <span class=\"number\">0.1</span>;</span><br><span class=\"line\">System.out.println(k); =&gt; <span class=\"number\">1.2000000000000002</span></span><br><span class=\"line\">BigDecimal decimal = BigDecimal.valueOf(k);</span><br><span class=\"line\">System.out.println(decimal.setScale(decimal.scale() - <span class=\"number\">1</span>, RoundingMode.HALF_UP).doubleValue()); =&gt; <span class=\"number\">1.2</span></span><br></pre></td></tr></table></figure>\n<p>似乎找到了完美的解决方案</p>\n<p>但是其实我们上面的假设都是基于一个假设，那就是我们的计算肯定会出现精度问题，并且肯定是有小数的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> k = <span class=\"number\">8900000000000L</span>;</span><br><span class=\"line\">System.out.println(k);</span><br><span class=\"line\">BigDecimal decimal = BigDecimal.valueOf(k);</span><br><span class=\"line\">System.out.println(decimal.scale());</span><br><span class=\"line\">System.out.println(decimal.setScale(decimal.scale() - <span class=\"number\">1</span>, RoundingMode.HALF_UP).doubleValue());</span><br></pre></td></tr></table></figure>\n<p>如果是这种情况呢？<br>那么我们会得到<code>9.0E12</code></p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>别想了，除非你是要比较两个数的大小，可以不用BigDecimal，把两个数相减和一个0.000001比较就行<br>其他想使用最后结果的，还是乖乖的从头BigDecimal到尾吧。</p>\n","categories":["踩坑"],"tags":["Java"]},{"title":"2018杭州初雪","url":"https://blog.lovezhy.cc/2018/12/09/2018杭州初雪/","content":"<p>2018-12-09</p>\n<p>杭州的第一场雪</p>\n<a id=\"more\"></a>\n<p><img src=\"/images/2018杭州雪/2018-1.jpg\" alt=\"\"></p>\n<p><img src=\"/images/2018杭州雪/2018-2.jpg\" alt=\"\"></p>\n","categories":["我的生活"],"tags":["生活"]},{"title":"从Redis看跳表实现","url":"https://blog.lovezhy.cc/2018/11/15/从Redis看跳表实现/","content":"<p>大学里也没教跳表，主要是树结构的实现<br>因为Redis源码里使用到了跳表<br>所以顺便学习一番<br><a id=\"more\"></a></p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>我把参考资料写在开头，因为我保证我不是跳表将的最好的<br><a href=\"https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/skiplists.pdf\" target=\"_blank\" rel=\"noopener\">https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/skiplists.pdf</a></p>\n<h1 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h1><p>Redis的跳表的定义代码在server.h中<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> &#123;</span></span><br><span class=\"line\">    robj *obj;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> score;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">backward</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistLevel</span> &#123;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">forward</span>;</span></span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> span;</span><br><span class=\"line\">    &#125; level[];</span><br><span class=\"line\">&#125; zskiplistNode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplist</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">header</span>, *<span class=\"title\">tail</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> level;</span><br><span class=\"line\">&#125; zskiplist;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"/images/从Redis看跳表实现/1.png\" alt=\"IMAGE\"></p>\n<p>和红黑树的功能相比，Redis的跳表的定义还有点不太常见的地方</p>\n<ul>\n<li>backward节点，这个节点的指向和level数组向前不一样，指向的是后一个节点，相当于红黑树的父节点的指针</li>\n<li>span，这个是计算当前节点和forward指向的节点中间的间隔，这个有什么用呢，主要是计算当前节点的排名的<br>我们在查找一个节点的时候，把查找过程中的所有的span加起来就是它在整个跳表中的排名<br>如果说上一个红黑树可能还算常见的话，这个就更不常见了，而且这个的计算还是有点复杂</li>\n</ul>\n<h1 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h1><p>对一个跳表而言，我们初始化的时候，要设定它的最大高度，Redis中设置的是32<br>在初始化跳表的时候，要先创建header节点，高度位32</p>\n<p>每个Node的创建的时候，level数组会随机一个大小，不超过32<br>代码如下：（没啥好看的）<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">zskiplist *<span class=\"title\">zslCreate</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j;</span><br><span class=\"line\">    zskiplist *zsl;</span><br><span class=\"line\"></span><br><span class=\"line\">    zsl = zmalloc(<span class=\"keyword\">sizeof</span>(*zsl));</span><br><span class=\"line\">    zsl-&gt;level = <span class=\"number\">1</span>;</span><br><span class=\"line\">    zsl-&gt;length = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//创建header</span></span><br><span class=\"line\">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,<span class=\"number\">0</span>,<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</span><br><span class=\"line\">        zsl-&gt;header-&gt;level[j].forward = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        zsl-&gt;header-&gt;level[j].span = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    zsl-&gt;header-&gt;backward = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    zsl-&gt;tail = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> zsl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">zskiplistNode *<span class=\"title\">zslCreateNode</span><span class=\"params\">(<span class=\"keyword\">int</span> level, <span class=\"keyword\">double</span> score, robj *obj)</span> </span>&#123;</span><br><span class=\"line\">    zskiplistNode *zn = zmalloc(<span class=\"keyword\">sizeof</span>(*zn)+level*<span class=\"keyword\">sizeof</span>(struct zskiplistLevel));</span><br><span class=\"line\">    zn-&gt;score = score;</span><br><span class=\"line\">    zn-&gt;obj = obj;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> zn;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h1><p>查找比较简单</p>\n<p><img src=\"/images/从Redis看跳表实现/2.png\" alt=\"IMAGE\"><br>比如上图中，我们要查找71这个元素，这个图假设的最大高度是4</p>\n<p>先从header的最高level开始<br>如果forward节点的值小于var，则前跳<br>如果大于或者指向了tail，则下降一个level</p>\n<p>再补充一个查找96的<br><img src=\"/images/从Redis看跳表实现/3.png\" alt=\"IMAGE\"></p>\n<h1 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h1><p>理解了查找的逻辑，才能方便理解怎么插入<br>因为插入一个节点，除了要知道它因为在的位置，还需要修改它前面节点的level数组中forward指针的指向<br>同时，对于Redis的拥有span的信息而言，还需要更改前面节点的span的值<br>这个Redis使用了一个Update数组和Rank数组辅助完成</p>\n<p>Update数组主要用来构建将插入节点的每个Level成员的前继节点<br>Rank数组则是Update数组中每个成员在整个跳表中的排名</p>\n<p>看图</p>\n<p><img src=\"/images/从Redis看跳表实现/4.png\" alt=\"IMAGE\"><br>假设当前的跳表是这样，我们要插入元素90<br>首先初始化Update和Rank数组，大小是maxLevel的大小，这里就是4</p>\n<p>首先对第一层分析<br><img src=\"/images/从Redis看跳表实现/5.png\" alt=\"IMAGE\"><br>从header节点出发，找到最后一个比90小的Level中的节点，就是16的level[3]<br>然后放入Update数组，同时把它的Rank放入Rank数组</p>\n<p>然后对第二层进行分析<br><img src=\"/images/从Redis看跳表实现/6.png\" alt=\"IMAGE\"><br>还是16这个节点，放入Update和Rank数组中</p>\n<p>第三层<br><img src=\"/images/从Redis看跳表实现/7.png\" alt=\"IMAGE\"><br>我们找到71这个节点，放入Update和Rank数组中</p>\n<p>第四层<br><img src=\"/images/从Redis看跳表实现/8.png\" alt=\"IMAGE\"><br>我们找到89这个节点</p>\n<p>到现在为止，Update数组和Rank数组都已经构建完毕<br>90插入的位置也已经找到，就是89节点的下一个位置</p>\n<p>我们随机一个高度，假设是3<br><img src=\"/images/从Redis看跳表实现/9.png\" alt=\"IMAGE\"></p>\n<p>那么我们更新90的前继节点的forward指针和span值呢<br>有了Update和Rank数组，公式可以很轻松的拿到<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x.level[i].forward = update[i]-&gt;level[i].forward</span><br><span class=\"line\">update[i]-&gt;level[i].forward = x</span><br><span class=\"line\"></span><br><span class=\"line\">x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class=\"number\">0</span>] - rank[i])</span><br><span class=\"line\">update[i]-&gt;level[i].span = (rank[<span class=\"number\">0</span>] - rank[i]) + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure></p>\n<p>这就是核心的插入逻辑，代码中其实不是每一层都是从Header开始查找的<br>我这么画是为了好理解一点</p>\n<p>下面是Redis中的源码<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">zskiplistNode *<span class=\"title\">zslInsert</span><span class=\"params\">(zskiplist *zsl, <span class=\"keyword\">double</span> score, robj *obj)</span> </span>&#123;</span><br><span class=\"line\">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> rank[ZSKIPLIST_MAXLEVEL];  <span class=\"comment\">//建立一个长度为32的rank，用于后续更新span</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, level;</span><br><span class=\"line\"></span><br><span class=\"line\">    serverAssert(!isnan(score));</span><br><span class=\"line\">    <span class=\"comment\">//update数组，存的是即将指向新插入节点的level数组的forward节点</span></span><br><span class=\"line\">    x = zsl-&gt;header;</span><br><span class=\"line\">    <span class=\"comment\">//for循环，寻找每一层的前继节点，方法Update数组中</span></span><br><span class=\"line\">    <span class=\"comment\">//当然这里并不是每次都从头开始找的，整个构建逻辑和查找很像</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = zsl-&gt;level<span class=\"number\">-1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        rank[i] = i == (zsl-&gt;level<span class=\"number\">-1</span>) ? <span class=\"number\">0</span> : rank[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class=\"line\">            (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class=\"line\">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class=\"line\">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; <span class=\"number\">0</span>))) &#123;</span><br><span class=\"line\">            rank[i] += x-&gt;level[i].span;</span><br><span class=\"line\">            x = x-&gt;level[i].forward;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        update[i] = x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//给新节点初始化一个高度</span></span><br><span class=\"line\">    level = zslRandomLevel();</span><br><span class=\"line\">    <span class=\"comment\">//创建一个跳表节点</span></span><br><span class=\"line\">    x = zslCreateNode(level,score,obj);</span><br><span class=\"line\">    <span class=\"comment\">//更新前继节点的forward和span</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; level; i++) &#123;</span><br><span class=\"line\">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</span><br><span class=\"line\">        update[i]-&gt;level[i].forward = x;</span><br><span class=\"line\"></span><br><span class=\"line\">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class=\"number\">0</span>] - rank[i]);</span><br><span class=\"line\">        update[i]-&gt;level[i].span = (rank[<span class=\"number\">0</span>] - rank[i]) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//有删减</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"删除节点\"><a href=\"#删除节点\" class=\"headerlink\" title=\"删除节点\"></a>删除节点</h1><p>删除节点其实比较简单了<br>只需要构建Update数组就行了<br>span就直接加上被删除节点的span就行了</p>\n","categories":["Redis"],"tags":["Redis","数据结构","跳表"]},{"title":"SDS实现从1.0到2.0","url":"https://blog.lovezhy.cc/2018/11/12/SDS实现从1.0到2.0/","content":"<p>Redis中的字符串使用的是自己的实现，解决了使用原生字符串的一些弊端<br>在源码中定义为<code>sds.h</code><br><a id=\"more\"></a></p>\n<h2 id=\"1-0\"><a href=\"#1-0\" class=\"headerlink\" title=\"1.0\"></a>1.0</h2><p>1.0 的定义是这样的</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"built_in\">free</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>通过两个字段标记buf中空闲的大小和已经有的字符串的长度<br>获得了以下的好处</p>\n<ul>\n<li>使得strlen的时间复杂度变成了O(1)</li>\n<li>避免缓冲区溢出问题，使用自定义的strcat等函数</li>\n<li>空间预分配，当需要对SDS进行扩展的时候，如果空间不足，再分配时会依据一些策略预分配一些空间<ul>\n<li>如果对SDS修改后len &lt; 1MB，那么将预分配len大小的空间，就是free = len</li>\n<li>如果对SDS修改后len &gt;= 1MB, 那么将预分配1MB大小的空间, 就是free = 1MB</li>\n</ul>\n</li>\n</ul>\n<p>有分配就有收回<br>关于收回有两个函数<code>sdstrim</code>和<code>sdsRemoveFreeSpace</code><br>第一个并没有回收buf数组，而是把多余的空间的大小写到了free中<br>第二个是进行了回收buf数组的操作<br>我再去看sdsRemoveFreeSpace的调用，发现其实调用的并不多<br>可能是Redis的场景中，直接delete的较多，进行remove并不多<br>而且Redis提供的操作中也只有append操作可以对字符串进行增加<br>具体哪些会调用remove，TODO一下，等后面看到了再说  </p>\n<p>我在看书的时候顺便去翻了下源码<br>发现3.2之后进行了一番的升级   </p>\n<p>变得略复杂</p>\n<p>为什么要进行了升级呢，其实SDS的定义也不是毫无缺点<br>看这个issue就知道了<br><a href=\"https://github.com/antirez/redis/issues/757\" target=\"_blank\" rel=\"noopener\">https://github.com/antirez/redis/issues/757</a><br>问题就在len和free的使用类型上，使用的是unsigned int</p>\n<ul>\n<li>unsigned int，也就是32位，最多只能记录4GB大小，超过4G的大小将无法使用</li>\n<li>内存损耗，如果字符串都非常短，可能16位就能记录，那么32位就损耗了2位</li>\n</ul>\n<p>（其实如果我倒觉得这两个不是什么问题，果然大佬的思想就是不一样）</p>\n<p>但是既然问题提出来了就需要解决</p>\n<p>简单的换len和free的类型吗<br>这个不行，因为你仔细观察上面两个缺点，发现他们其实是有点互斥的成分在里面<br>一个嫌弃是unsigned int过小，一个是嫌弃unsigned int过大</p>\n<p>然后这个PR就提出了自适应的sdshdr<br><a href=\"https://github.com/antirez/redis/pull/2509\" target=\"_blank\" rel=\"noopener\">https://github.com/antirez/redis/pull/2509</a><br>也就是SDS2.0的实现</p>\n<h2 id=\"2-0\"><a href=\"#2-0\" class=\"headerlink\" title=\"2.0\"></a>2.0</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">attribute__</span> ((__<span class=\"title\">packed__</span>)) <span class=\"title\">sdshdr5</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> flags; <span class=\"comment\">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">attribute__</span> ((__<span class=\"title\">packed__</span>)) <span class=\"title\">sdshdr8</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint8_t</span> len; <span class=\"comment\">/* used */</span></span><br><span class=\"line\">    <span class=\"keyword\">uint8_t</span> alloc; <span class=\"comment\">/* excluding the header and null terminator */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> flags; <span class=\"comment\">/* 3 lsb of type, 5 unused bits */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">attribute__</span> ((__<span class=\"title\">packed__</span>)) <span class=\"title\">sdshdr16</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> len; <span class=\"comment\">/* used */</span></span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> alloc; <span class=\"comment\">/* excluding the header and null terminator */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> flags; <span class=\"comment\">/* 3 lsb of type, 5 unused bits */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">attribute__</span> ((__<span class=\"title\">packed__</span>)) <span class=\"title\">sdshdr32</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> len; <span class=\"comment\">/* used */</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> alloc; <span class=\"comment\">/* excluding the header and null terminator */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> flags; <span class=\"comment\">/* 3 lsb of type, 5 unused bits */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">attribute__</span> ((__<span class=\"title\">packed__</span>)) <span class=\"title\">sdshdr64</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span> len; <span class=\"comment\">/* used */</span></span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span> alloc; <span class=\"comment\">/* excluding the header and null terminator */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> flags; <span class=\"comment\">/* 3 lsb of type, 5 unused bits */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这是2.0的struct定义<br>根据长度分为了5种，分别是8位，16位，32位，64位<br>每个定义中使用了一个char类型的flags标记当前的struct是什么类型  </p>\n<p>再注意看还有一个<code>__attribute__ ((__packed__))</code>的定义<br>这个我也不知道是啥，所以特地去查了一下<br>结果是GCC的编译器的一个标记选项，使用紧凑结构编译<br>正常情况下的struct会使用内存对齐的<br>比如这个<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">stu</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> ch;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> v;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, (<span class=\"keyword\">int</span>) <span class=\"keyword\">sizeof</span>(struct stu));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>结果在我的64位机器上输出的是8<br>虽然char是1位，int是4位，但是因为对齐的原因，ch和v之间有三位是不用的，属于padding位<br>所以整个struct的占用大小是8</p>\n<p>但是如果加上<code>__attribute__ ((__packed__))</code>选项呢<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">attribute__</span> ((<span class=\"title\">packed</span>)) <span class=\"title\">stu</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> ch;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> v;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, (<span class=\"keyword\">int</span>) <span class=\"keyword\">sizeof</span>(struct stu));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>你会发现输出的是5</p>\n<p>这个关键词看起来是极好的，但是其实也有弊端<br>既然节约了空间，那么在时间上肯定是有损耗的<br>正常我们读取v数据在32位的数据总线上，读取一次就够了，因为地址总线按照32位进行寻址的<br>但是如果是上面这种，因为v分布在两个32位的地址中，数据总线可能需要进行两个读取才能把v的值拿到</p>\n<p>说回SDS，既然分为了五种类型，那么在进行一些操作的时候就要分情况讨论了<br>因为在操作SDS的时候，统一的全部换成了地址进行操作<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">char</span> *sds;</span><br></pre></td></tr></table></figure></p>\n<p>之前的定义，len肯定是在前4位的，但是现在不知道了，所以要先找出type，看是哪一种类型</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> size_t <span class=\"title\">sdslen</span><span class=\"params\">(<span class=\"keyword\">const</span> sds s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> flags = s[<span class=\"number\">-1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_5:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> SDS_TYPE_5_LEN(flags);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_8:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> SDS_HDR(<span class=\"number\">8</span>,s)-&gt;len;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_16:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> SDS_HDR(<span class=\"number\">16</span>,s)-&gt;len;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_32:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> SDS_HDR(<span class=\"number\">32</span>,s)-&gt;len;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_64:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> SDS_HDR(<span class=\"number\">64</span>,s)-&gt;len;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>比如计算长度这个，得先拿出flags，判断下属于哪个类型的SDS，然后再对长度所在的地址进行取值</p>\n","categories":["Redis"],"tags":["Redis","SDS"]},{"title":"读书笔记 - NoSQL精粹","url":"https://blog.lovezhy.cc/2018/11/09/读书笔记 - NoSQL精粹/","content":"<p>《NoSQL精粹》读书笔记<br><a id=\"more\"></a></p>\n<h1 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h1><p>主张无模式的数据 模式就是<strong>需要预先定义结构</strong><br>可以运行在集群环境中<br>牺牲传统数据库的一致性</p>\n<h1 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h1><p>开发效率更快 无需太多的关心数据结构和关系型数据库之间的映射 -&gt; 无模式<br>适合大数据量场景 关系型数据库是为独立运行的计算机而设计 NoSQL为集群设计</p>\n<h1 id=\"模式\"><a href=\"#模式\" class=\"headerlink\" title=\"模式\"></a>模式</h1><p>虽然NoSQL没有模式，但是数据在运用的过程中隐含了一种模式<br>在实现数据结构变更的时候，也必须修改其规则</p>\n<h1 id=\"关系型数据库的价值\"><a href=\"#关系型数据库的价值\" class=\"headerlink\" title=\"关系型数据库的价值\"></a>关系型数据库的价值</h1><ul>\n<li>持久化数据</li>\n<li>并发安全 指的是事务</li>\n<li>集成 多个应用程序可以共享数据（那时候还没有Http来交换数据)</li>\n<li>标准化</li>\n</ul>\n<h1 id=\"关系型数据库的问题\"><a href=\"#关系型数据库的问题\" class=\"headerlink\" title=\"关系型数据库的问题\"></a>关系型数据库的问题</h1><p>元组中的值必须很简单 如果需要List，则必须再建立一个关系<br>ORM(object relation mapping)在一定程度上缓解了这个问题</p>\n<h1 id=\"NoSQL广泛使用的模型\"><a href=\"#NoSQL广泛使用的模型\" class=\"headerlink\" title=\"NoSQL广泛使用的模型\"></a>NoSQL广泛使用的模型</h1><ul>\n<li>键值</li>\n<li>文档</li>\n<li>列族</li>\n<li>图</li>\n</ul>\n<p>其中前三种是面向聚合</p>\n<h1 id=\"面向聚合\"><a href=\"#面向聚合\" class=\"headerlink\" title=\"面向聚合\"></a>面向聚合</h1><p>在领域驱动设计中，把一组相互关联的对象视为一个整体单元来操作，这个单元就叫聚合<br>比如学生选多门课<br>面向关系需要学生表记录学生，课表记录课，学生和课的映射表记录学生选了哪些课<br>面向聚合可能就直接一个JSON描述干净</p>\n<p>面向关系的更像是(标记聚合 + 面向组合)的方式</p>\n<p>因为集群的关系，面向聚合的数据库确实不支持跨越多个聚合的ACID事务<br>它每次只能在一个聚合结构上执行原子操作  </p>\n<p>聚合的有用之处在于它可以把经常访问的数据存放在一起</p>\n<h1 id=\"键值数据库和文档数据库\"><a href=\"#键值数据库和文档数据库\" class=\"headerlink\" title=\"键值数据库和文档数据库\"></a>键值数据库和文档数据库</h1><p>两类数据库都是面向聚合的<br>区别<br>键值数据库的聚合不透明<br>可以存储任意数据<br>访问聚合内容，必须通过Key来进行查找</p>\n<p>文档数据库的聚合中可以看到其结构<br>限制存放的内容 定义了其允许的结构和数据类型<br>可以更加灵活的访问数据<br>用聚合中的字段查询，只获取聚合的一部分<br>按照聚合内容创建索引</p>\n<h1 id=\"列族存储\"><a href=\"#列族存储\" class=\"headerlink\" title=\"列族存储\"></a>列族存储</h1><p>读多写少的场景<br>两级聚合结构<br>以一组列来存储<br><img src=\"/images/nosql精粹/1.png\" alt=\"IMAGE\"><br>上图的info和events就是列族<br>由<code>rowkey + (colomn family:colomn qualifier) + version</code>来唯一的标志一个Cell  </p>\n<p>为什么叫列族呢<br>我个人理解的话<br>就是列是从关系型数据库去讲的，数据库的第一范式就规定了列必须是不可再分的<br>但是列族的话表示这是可再分的<br>一个列族包含了很多的列<br>列族中可以随意添加列</p>\n<p>这样设计的理念是<strong>某个列族的数据经常要一起访问</strong></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>面向聚合数据库，都使用了聚合这个概念<br>而且聚合中都有一个可以查找其内容的索引键<br>聚合还是更新操作的最小数据单位  </p>\n<h1 id=\"图数据库\"><a href=\"#图数据库\" class=\"headerlink\" title=\"图数据库\"></a>图数据库</h1><p>如果两个聚合之间产生了关系，一个难点就是如何更新其数据</p>\n<p>面向聚合的数据库，在操作多个聚合的时候显得相当笨拙  </p>\n<p>如果待处理的数据中包含了大量的关系<br>这意味了关系型数据库可能是更好地选择<br>虽然关系型数据库在这里这种情况的性能也很糟糕，但是至少能保证ACID</p>\n<p>或者我们使用图数据库<br>图数据库特别擅长处理关系特别多的场景  </p>\n<p>图数据库和面向聚合的数据的明显的差异就是<br>它尤其的注重数据间的关系  </p>\n<h1 id=\"再谈无模式\"><a href=\"#再谈无模式\" class=\"headerlink\" title=\"再谈无模式\"></a>再谈无模式</h1><p>无模式数据库感知不到模式<br>所以它无法用模式来提升存储与获取数据的效率<br>也无法自行验证数据<br>带来的是使用的自由和灵活<br>所以NoSQL弃用模式，确实让人惊叹</p>\n<h1 id=\"隐含模式\"><a href=\"#隐含模式\" class=\"headerlink\" title=\"隐含模式\"></a>隐含模式</h1><p>不管数据库无模式到什么程度<br>总会存在隐含模式<br>指的是在编写数据操作代码时，对数据结构做的一系列假设  </p>\n<p>所以说隐含模式是在应用代码中  </p>\n<p>所以如果多个应用公用一个数据库<br>那么可能会出现问题<br>解决方法是在聚合中为不同的应用程序划分出不同的区域  </p>\n<h1 id=\"物化视图\"><a href=\"#物化视图\" class=\"headerlink\" title=\"物化视图\"></a>物化视图</h1><p>关系型数据库因为不存在聚合结构<br>所以可以用不同的方式访问数据  </p>\n<p>此外，还提供了视图的机制</p>\n<h1 id=\"数据分布\"><a href=\"#数据分布\" class=\"headerlink\" title=\"数据分布\"></a>数据分布</h1><p>数据分布有两种途径</p>\n<ul>\n<li>复制 将同一份数据拷贝到多个节点</li>\n<li>分片 将不同的数据分放在不同的节点中</li>\n</ul>\n<p>复制有两种形式</p>\n<ul>\n<li>主从式</li>\n<li>对等式</li>\n</ul>\n<h1 id=\"分片\"><a href=\"#分片\" class=\"headerlink\" title=\"分片\"></a>分片</h1><p>因为NoSQL的面向聚合的特性<br>所以对于分片非常的适合<br>我们进行分片的时候，将聚合作为分布数据的单元<br>这样可以保证查询的时候只需要查询一个节点  </p>\n<p>分片工作可以</p>\n<ul>\n<li>在客户端</li>\n<li>自动分片</li>\n</ul>\n<p>客户端的话，体验非常不好</p>\n<ul>\n<li>若要调整分片，既要修改代码，又要迁移数据</li>\n</ul>\n<p>分片对于读写性能的提升都是巨大的  </p>\n<h1 id=\"主从复制\"><a href=\"#主从复制\" class=\"headerlink\" title=\"主从复制\"></a>主从复制</h1><p>提升读性能，对写性能帮助不大<br>增强读取操作的故障恢复能力 （指的是不会自动选主的情况）</p>\n<p>问题<br>保证数据不一致性<br>写读不一致，读读不一致</p>\n<h1 id=\"对等复制\"><a href=\"#对等复制\" class=\"headerlink\" title=\"对等复制\"></a>对等复制</h1><p>没有主节点的概念<br>所有副本地位相同<br>都可以接收写入操作</p>\n<p>还是一致性，顺序不一致<br>（加分布式锁？那性能咋办）<br>而且更难解决</p>\n<h1 id=\"结合分片与复制\"><a href=\"#结合分片与复制\" class=\"headerlink\" title=\"结合分片与复制\"></a>结合分片与复制</h1><p>就是Redis Cluster的方案<br>多主多从</p>\n<h1 id=\"一致性\"><a href=\"#一致性\" class=\"headerlink\" title=\"一致性\"></a>一致性</h1><p>关系型数据库中的强一致性<br>而在NoSQL中，则一般采用CAP与最终一致性</p>\n<p>并发环境下维护数据一致性</p>\n<ul>\n<li>悲观方式 避免发生冲突</li>\n<li>乐观方式 先让冲突发生，然后检测冲突并对发生冲突的操作排序</li>\n</ul>\n<p>悲观方式一般是加锁</p>\n<p>乐观方式一般是“条件更新”<br>任意客户在执行更新操作之前<br>都要先测试数据和当前值和其上一次读入的值是否相同<br>测试和更新得是一个原子操作  </p>\n<p>顺序一致性</p>\n<ul>\n<li>所有节点都要保证以相同次序执行操作</li>\n</ul>\n<p>逻辑一致性</p>\n<ul>\n<li>就是脏读的问题</li>\n</ul>\n<p>逻辑一致性的解决依赖事务功能<br>NoSQL支持不支持事务还是得具体看的<br>如果不支持，那么就会出现问题<br>但是图数据库一般都是支持的  </p>\n<p>NoSQL的不一致窗口时间很短暂</p>\n<p>复制不一致</p>\n<ul>\n<li>主节点的更新向从节点复制的时候存在时间空隙</li>\n</ul>\n<p>最终一致性</p>\n<ul>\n<li>会话一致性  在用户会话内部保持“照原样读出所写内容的一致性”<br>方法：<ul>\n<li>黏性会话：绑定到某个节点的会话 缺点：降低负载均衡器的效能</li>\n<li>版本戳</li>\n</ul>\n</li>\n</ul>\n<p>CAP中的可用性是值<br>系统中某个无故障节点所接收的每一条请求<br>无论成功还是失败<br>都能得到响应</p>\n<p>现在不是完全的CAP二选一<br>都是BASE理论<br>首先分布容忍性肯定要有<br>然后一致性和可用性要有，但是既不具备完美的一致性，也不具备完美的可用性  </p>\n<p>BASE和ACID不是非非此即彼的关系<br>两者之间存在着多个逐渐过渡的权衡方案</p>\n<h1 id=\"放宽持久性\"><a href=\"#放宽持久性\" class=\"headerlink\" title=\"放宽持久性\"></a>放宽持久性</h1><p>放宽持久性可以换取更好的性能<br>大大提高请求响应的时间</p>\n<h1 id=\"复制持久性\"><a href=\"#复制持久性\" class=\"headerlink\" title=\"复制持久性\"></a>复制持久性</h1><p>确保主节点收到某些副本对更新数据的确认之后，再告知用户它已经接纳此更新</p>\n<h1 id=\"仲裁\"><a href=\"#仲裁\" class=\"headerlink\" title=\"仲裁\"></a>仲裁</h1><p>一致性和持久性之间的问题<br>不是非此即彼的问题<br>处理请求所用的节点越多，避免不一致问题的能力就越强<br>但是延迟也就越高</p>\n<p>写入仲裁<br>就是Paxos中的超过半数投票才能通过该议案</p>\n<p>读取仲裁<br>想要保证能够读取到最新的数据<br>必须要多少个节点联系才行</p>\n<p>假设一个写入操作沟通了K个节点<br>那么想要读取到最新的数据，至少要和K+1个节点沟通</p>\n<h1 id=\"版本戳\"><a href=\"#版本戳\" class=\"headerlink\" title=\"版本戳\"></a>版本戳</h1><p>事务分为商业事务和系统事务</p>\n<p>商业事务<br>类似于锁库存，开始填写订单信息</p>\n<p>系统事务<br>填写完订单信息，提交表单</p>\n<p>商业事务的问题就是在需要计算和决策的时候<br>数据有可能已经发生了改动</p>\n<p>这种问题可以采用离线并发的技术<br>乐观离线锁，也就是条件更新<br>也就是版本戳</p>\n<p>比如http中的Etag</p>\n<p>创建版本戳的方法</p>\n<ul>\n<li>计数器，每次+1</li>\n<li>GUID，GUID是微软对UUID这个标准的实现</li>\n<li>根据资源内容生成Hash</li>\n<li>使用上次更新的时间戳 不需要主节点来生成 但是所有节点的时钟必须同步 同时精度要高</li>\n</ul>\n<p>主从复制，更新不一致的情况<br>节点每次复制的时候，带上版本戳<br>这样从从节点中读的话，版本低的那个就说明数据较旧</p>\n<p>万一是对等式NoSQL系统<br>最常用的版本戳形式 叫 数组式版本戳<br>就是每个进程都维护一个进程版本戳的数组<br>[server1:12, server2:32, server3:64]<br>这是三台主服务器的情况<br>如果两个版本戳中都有一个比对方大，那么就是发生了写入冲突<br>但是无法解决这个问题  </p>\n<h1 id=\"MapReduce\"><a href=\"#MapReduce\" class=\"headerlink\" title=\"MapReduce\"></a>MapReduce</h1><p>Hadoop<br>在集群上运行，执行并发操作</p>\n<p>Map从聚合中读取数据，缩减为相关的键值对<br>Map会产生很多具备同一关键词的值，而化简任务将他们简化为单一的输出值<br>流式处理<br>增量式的MapReduce</p>\n<h1 id=\"KV\"><a href=\"#KV\" class=\"headerlink\" title=\"KV\"></a>KV</h1><p>适用场景</p>\n<ul>\n<li>会话信息</li>\n<li>用户配置信息</li>\n<li>购物车</li>\n</ul>\n<p>不适用场景</p>\n<ul>\n<li>数据间关系</li>\n<li>含有多项操作的事务</li>\n<li>查询value</li>\n</ul>\n<h1 id=\"文档数据库\"><a href=\"#文档数据库\" class=\"headerlink\" title=\"文档数据库\"></a>文档数据库</h1><p><img src=\"/images/nosql精粹/2.png\" alt=\"IMAGE\"><br>感觉格式就是JSON啊</p>\n<p>也支持主从复制<br>副本集通过内部选举得到主节点，但是可以人工干预</p>\n<p>和KV不同的是<br>文档数据库可以查询文档中的数据</p>\n<p>可扩展性<br>就是弹性伸缩<br>动态加机器，减机器<br>和Redis差不多啊</p>\n<h1 id=\"列族数据库\"><a href=\"#列族数据库\" class=\"headerlink\" title=\"列族数据库\"></a>列族数据库</h1><p><img src=\"/images/nosql精粹/3.png\" alt=\"IMAGE\"></p>\n<p>Cassandra能快速执行跨集群写入操作并易于对此扩展的数据库<br>集群中没有主节点，每个节点均可以处理读取和写入请求</p>\n<p>每个列族都可以与关系型数据库的“行容器”相对照<br>两者都用关键字标识行<br>并且每一行都由多个列组成<br>区别在于列族数据库的各行不一定要具备完全相同的列</p>\n<p>还拥有超列族</p>\n<p>Cassandra没有传统意义上的事务<br>写入操作在行级别是原子的  </p>\n<p>Cassandra的可用性极佳</p>\n<p>当<code>W + R &gt; N</code>的时候<br>一致性极佳</p>\n<p>Cassandra和Redis的对比<br>看的网上的，自己简单总结下</p>\n<ul>\n<li>Redis的数据总体还是面向聚合的，适用于快速，数据量小的情况</li>\n<li>Cassandra所支持的数据量可以非常大，同时在灵活性上确实比Redis高一点</li>\n</ul>\n<h1 id=\"图数据库-1\"><a href=\"#图数据库-1\" class=\"headerlink\" title=\"图数据库\"></a>图数据库</h1><p>有大量互相关联的节点</p>\n<p>用节点和边建立好图之后，可用多种方式查询它<br>查询图也叫遍历<br>图数据库的一个好处就是，无需改变节点和边，即可应对新的遍历需求</p>\n<p>一般不支持集群部署<br>Neo4J是兼容ACID事务的数据库</p>\n<p>可用性<br>主从复制</p>\n<p>分片困难<br>因为不是面向聚合的  </p>\n<p>适用场景<br>社交网络关系</p>\n","categories":["读书笔记"],"tags":["NoSQL"]},{"title":"从Netty看对象池实现","url":"https://blog.lovezhy.cc/2018/11/02/从Netty看对象池实现/","content":"<p>我们知道我们最终拿到的是ByteBuf类，分配的是byte[]数组，byte[]确实是池化的，但是每次申请一个都要去创建一个ByteBuf类，不如把ByteBuf也池化，那么就是个对象池了</p>\n<a id=\"more\"></a>\n<p>Netty的对象池不仅仅针对的ByteBuf，是一个通用的类<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Recycler</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> T <span class=\"title\">newObject</span><span class=\"params\">(Handle&lt;T&gt; handle)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>讲一讲正确的使用姿势</p>\n<p>首先定义自己的对象，要想实现对象池的功能，对象需要接受一个参数<code>Recycler.Handle</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> AtomicLong ATOMIC_LONG = <span class=\"keyword\">new</span> AtomicLong();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Recycler.Handle&lt;Student&gt; handle;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Student</span><span class=\"params\">(Recycler.Handle&lt;Student&gt; handle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.id = ATOMIC_LONG.getAndIncrement();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handle = handle;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Long <span class=\"title\">getId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">recycle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        handle.recycle(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里，我们定义了一个学生的类，同时接受Recycler.Handle的参数<br>同时定义一个<code>recycle</code>的方法<br>用处是当我们不用这个方法的时候，调用<code>recycle</code>方法把对象归还到对象池<br>内容比较单一<br>就写<code>handle.recycle(this)</code>就行</p>\n<p>下面定义我们的Recycler类<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Recycler&lt;Student&gt; studentRecycler = <span class=\"keyword\">new</span> Recycler&lt;Student&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Student <span class=\"title\">newObject</span><span class=\"params\">(Handle&lt;Student&gt; handle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Student(handle);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>重写<code>newObject</code>方法，我们直接<code>new</code>一个就好  </p>\n<p>下面进行测试<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Student student = studentRecycler.get();</span><br><span class=\"line\">    System.out.println(student.getId());</span><br><span class=\"line\">    student.recycle();</span><br><span class=\"line\">    System.out.println(studentRecycler.get().getId());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行一下可以看到输出结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure></p>\n<p>说明是同一个对象</p>\n<p>但是这只是简单的测试</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>其实对象池，思路并不难，需要的时候<code>new</code>一个，归还的时候我们保存到一个集合中，再取的时候优先从集合中取。</p>\n<p>但是这会催生一些问题<br>首先最容易想到的就是多线程问题</p>\n<p>多线程并发的具体有两个思路</p>\n<ul>\n<li>加锁，比如使用支持并发的集合类</li>\n<li><code>ThreadLocal</code></li>\n</ul>\n<p>加锁肯定是要消耗性能的，即使是<code>ConcurrentHashMap</code>这种设计优雅的，还是进行了加锁<br>但是优点是设计简单</p>\n<p>ThreadLocal可以不需要进行加锁，但是相应的就会催生更多的问题，编码也更复杂</p>\n<p>什么更多的问题呢<br>比如<br>在<code>Thread1</code>中<code>new</code>了一个对象，然后在<code>Thread2</code>中归还了。<br>如果不加以设计，那么这个对象应该是归还到<code>Thread2</code>中了。  </p>\n<p>如果<code>Thread1</code>疯狂<code>new</code>对象，全部到<code>Thread2</code>中归还呢？<br>那<code>Thread1</code>的对象池就毫无用处，<code>Thread2</code>中塞满了对象<br><code>Thread2</code>中的对象肯定是要释放的，不然会内存泄漏的<br>那么就需要对<code>Thread2</code>的对象池的大小进行规定，同时设置多久没使用就释放的策略  </p>\n<p>而且这种问题还是很常见的，一般代码逻辑定了，这个就定了<br>要代码去兼容这个问题肯定不现实  </p>\n<p>好，那么Thread1的对象，在Thread2中归还了，最终还是要回到Thread1中。<br>问题也好解决，我们把每个对象池记录下所在的Thread，建立一个<code>\\&lt;pool, Thread\\&gt;</code>的Map，归还的时候加以判定<br>那么又有多线程的问题了。<br>而且锁很难避免，需要一个良好的设计，尽可能的减少锁。</p>\n<p>综上所看，使用ThreadLocal确实优点很多，但是设计上需要考虑很多东西</p>\n<p>下面我们看Netty是怎么一一解决这个问题的</p>\n<h2 id=\"设计\"><a href=\"#设计\" class=\"headerlink\" title=\"设计\"></a>设计</h2><p><img src=\"/images/netty对象池/1.png\" alt=\"简单的对象池\"><br>首先看看最简单的设计<br>我们采用ThreadLocal，为每个线程分配一个类似于Stack的结构，Stack内部使用链表或者数组都是可以的。<br>当有请求过来，从Stack中pop出一个对象，使用完之后再push进去  </p>\n<p><hr><br><img src=\"/images/netty对象池/2.png\" alt=\"2\"><br>上文提到，上面一个是有问题的<br>那么怎么办呢，Netty为每个线程又设计了一个Queue，同时维护每个线程和Queue对应的Map，当其他的线程回收对象的时候，如果发现这个对象不属于自己的线程<br>那么就放到Onwer线程的Queue中<br>当线程的Stack进行pop时，如果发现Stack中空了，那么先不执行New一个对象的操作，而是先去对应的Queue中去查看是否为空，如果不为空，那么就从Queue中transfer到Stack中  </p>\n<p>那么问题似乎解决了  这样是行得通的<br>但是再细想，其他线程之间的release操作，其他线程release和owner线程的transder操作，似乎有那么点互斥的意思在里面   </p>\n<p>那么这里面已经怎么设计才能是最佳的呢</p>\n<p><hr><br><img src=\"/images/netty对象池/3.png\" alt=\"3\"></p>\n<p>首先解决多个other线程的release可能存在的race condition问题，这个也好解决，还是ThreadLocal，对于每一个Queue，对其他的每个Other线程建立一个自己的Queue  </p>\n<p>这样每个other线程进行release不属于自己的对象的时候，不会产生竞态条件</p>\n<p><hr><br><img src=\"/images/netty对象池/4.png\" alt=\"4\"></p>\n<p>下面解决other线程的release和owner线程的transfer之间的同步问题<br>其实他们之间的问题并不是互斥的问题，而是同步的问题，而且这个同步也并没有涉及notify，wait之类的操作  </p>\n<p>不管是什么容器，我们维护readIndex和writeIndex这两个指针就行，进行transfer的时候，直接记录下writeIndex，就transfer到这个位置就好  </p>\n<p>那么底层使用什么进行维护呢，这个还是可以讲究一下的<br>我们设想几个方案</p>\n<ul>\n<li>一个大数组  可行吗？感觉不是太好，首先会有扩容和缩容操作，其次writeIndex和readIndex一直往前走，那么小于readIndex的那部分其实不太好管理，容易产生浪费</li>\n<li>链表 可行吗？似乎是可行的 但是对于每一个对象，都会产生一个与之伴随的Entry对象，而且这个Entry可能会较多，都是小对象，对GC不是那么友好。除非能池化。想什么呢，还玩递归？呸！</li>\n</ul>\n<p>似乎陷入了僵局</p>\n<p>再想想，能不能兼容两者的优点<br>记得Redis中的QuickList吗</p>\n<p>对的，Netty中就是这么设计的<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">List</span> </span>&#123;</span><br><span class=\"line\">    Ele[] ele = <span class=\"keyword\">new</span> Ele[CAPCITY];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> readIndex;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> writeIndex;</span><br><span class=\"line\">    List next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>每个节点中，放入一个对象的数组，同时维护readIndex和WriteIndex。<br>当满了之后，再New一个List，把当前的Next指针指向新的List  </p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>终于讲完了<br>还是学到了很多东西<br>代码就不带你们去读了，有了思路之后再去读会容易点</p>\n","categories":["Netty"],"tags":["Java","Netty","对象池"]},{"title":"阅读","url":"https://blog.lovezhy.cc/2018/10/07/阅读/","content":"<p>记录下自己的阅读方式 </p>\n<a id=\"more\"></a>\n<h2 id=\"实体书和PDF\"><a href=\"#实体书和PDF\" class=\"headerlink\" title=\"实体书和PDF\"></a>实体书和PDF</h2><p>自己也在PDF和实体书之间纠结了很久   </p>\n<p>虽然自己买了很多实体书，但是大部分的阅读还是在PDF中进行的  </p>\n<p>主要原因是实体书的携带不方便，而电脑基本可以装下成千上万的PDF  </p>\n<p>第二个原因就是边看实体书边写代码验证很麻烦，不如外接个显示器舒服  </p>\n<h2 id=\"误区\"><a href=\"#误区\" class=\"headerlink\" title=\"误区\"></a>误区</h2><p>最近自己陷入了一个误区，因为自己在看那些偏底层和基础的书，大多比较厚重  </p>\n<p>所以还是选择的PDF   </p>\n<p>怕自己记不住，于是好记性不如烂笔头，开始记笔记  </p>\n<p>但是笔记记多了，严重影响阅读进度  </p>\n<p>记少了，自己再去看，也看不出个啥  还是得去看原书  </p>\n<h2 id=\"抉择\"><a href=\"#抉择\" class=\"headerlink\" title=\"抉择\"></a>抉择</h2><p>所以，我决定，以后还是得买实体书看  </p>\n<p>可以用笔画画重点啥的，一本书多看两遍也不是什么大问题  </p>\n","categories":["总结"],"tags":["Thought"]},{"title":"Netty内存池实现","url":"https://blog.lovezhy.cc/2018/10/03/Netty内存池实现/","content":"<h1 id=\"重点\"><a href=\"#重点\" class=\"headerlink\" title=\"重点\"></a>重点</h1><ul>\n<li>按申请内存大小分类，使用不同的分配策略</li>\n<li>完美二叉树表示内存池占用</li>\n<li>ThreadLocalCache</li>\n<li>Recycler对象池</li>\n</ul>\n<a id=\"more\"></a>\n<h1 id=\"简单使用\"><a href=\"#简单使用\" class=\"headerlink\" title=\"简单使用\"></a>简单使用</h1><p>Netty的内存分为池化和非池化<br>同时又分直接内存和堆内存  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//direct pooled</span></span><br><span class=\"line\">ByteBuf byteBuf = <span class=\"keyword\">new</span> PooledByteBufAllocator(<span class=\"keyword\">true</span>).buffer(); </span><br><span class=\"line\"><span class=\"comment\">//heap pooled</span></span><br><span class=\"line\">ByteBuf byteBuf = <span class=\"keyword\">new</span> PooledByteBufAllocator(<span class=\"keyword\">false</span>).buffer();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//direct unpooled</span></span><br><span class=\"line\">ByteBuf byteBuf = <span class=\"keyword\">new</span> UnpooledByteBufAllocator(<span class=\"keyword\">true</span>).buffer();</span><br><span class=\"line\"><span class=\"comment\">//heap unpooled</span></span><br><span class=\"line\">ByteBuf byteBuf4 = <span class=\"keyword\">new</span> UnpooledByteBufAllocator(<span class=\"keyword\">false</span>).buffer();</span><br></pre></td></tr></table></figure>\n<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><p>对于一些重要抽象的概念  </p>\n<ul>\n<li>PoolArean:  内存分配的上层接口</li>\n<li>PoolChunk: 直接管理内存，一大块byte[]就是在这其中申请的</li>\n<li>Page: Chunk中的内存被<strong>逻辑上</strong>分为很多个Page，逻辑上按照Page进行分配管理  </li>\n</ul>\n<p><img src=\"/images/netty-memorypool/arean.png\" alt=\"arean\"></p>\n<p>上面这个图很好的阐述了三者的关系  </p>\n<p>一个PoolArean中包含很多的PoolChunk  </p>\n<p>同时为了管理这些PoolChunk，Arean根据目前内存占用率建立了对应的几种PoolChunkList并进行双向链表的串联  </p>\n<p><img src=\"/images/netty-memorypool/poolchunkList.png\" alt=\"arean\">  </p>\n<p>某一个PoolChunk并不是一直在一个List中，会根据使用率进行动态调整    </p>\n<p>new一个PoolChunk的时候，也会申请一大块内存  </p>\n<p>对这大块内存进行逻辑上的分配，固定一个大小，每一个大小称为一个Page  </p>\n<h1 id=\"参数设置\"><a href=\"#参数设置\" class=\"headerlink\" title=\"参数设置\"></a>参数设置</h1><p>大体的概念是这样，下面有一些重要的系统参数规定：</p>\n<ul>\n<li><code>DEFAULT_PAGE_SIZE</code> : 是默认一个Page的大小，默认是8k</li>\n<li><code>PageShifts</code>：这个参数很迷，由Integer.SIZE - 1 - Integer.numberOfLeadingZeros(pageSize)这样计算出来，默认是13</li>\n<li><code>DEFAULT_MAX_ORDER</code> 决定设置一个PoolChunk的申请内存的大小，下面可以看到，就是完美二叉树的树高  默认是11</li>\n<li><code>defaultChunkSize</code> PoolChunk的申请的内存大小 =&gt;  DEFAULT_PAGE_SIZE &lt;&lt; DEFAULT_MAX_ORDER 默认是16MB</li>\n<li><code>defaultMinNumArena</code>: 默认的Arean个数: 等于NettyRuntime.availableProcessors() * 2</li>\n<li><code>DEFAULT_NUM_HEAP_ARENA</code>和<code>DEFAULT_NUM_DIRECT_ARENA</code>:<br>当我们初始化PooledByteBufAllocator的时候，会初始化PoolArean，但是为了减少竞争，会建立不只一个PoolArean<br>这两个参数是表示建立几个Heap_Arean和Direct_Arean  我的机器上默认是16<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DEFAULT_NUM_HEAP_ARENA = Math.max(<span class=\"number\">0</span>,</span><br><span class=\"line\">            SystemPropertyUtil.getInt(</span><br><span class=\"line\">                    <span class=\"string\">\"io.netty.allocator.numHeapArenas\"</span>,</span><br><span class=\"line\">                    (<span class=\"keyword\">int</span>) Math.min(</span><br><span class=\"line\">                            defaultMinNumArena,</span><br><span class=\"line\">                            runtime.maxMemory() / defaultChunkSize / <span class=\"number\">2</span> / <span class=\"number\">3</span>)));</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>对于申请的内存块大小 ，分为三类<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> SizeClass &#123;</span><br><span class=\"line\">    Tiny,</span><br><span class=\"line\">    Small,</span><br><span class=\"line\">    Normal</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Tiny是 小于 512的<br>Small是大于512小于PageSize的<br>Normal是大于等于一个PageSize的<br>Netty之所以分为三类，是因为这三类的分配方式不是很一样</p>\n<h1 id=\"Alloc初始化\"><a href=\"#Alloc初始化\" class=\"headerlink\" title=\"Alloc初始化\"></a>Alloc初始化</h1><p>PooledByteBufAllocator进行初始化的时候，会先初始化两个PoolArena<t>数组  <code>PoolArena&lt;T&gt;[]</code><br>分别是堆和直接内存的  就是不管你想用哪个，都会初始化两个<br>同时对数组的成员的每一个成员增加PoolArena<t>对象  </t></t></p>\n<p>如果是堆就是<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HeapArena extends PoolArena&lt;<span class=\"keyword\">byte</span>[]&gt;</span><br></pre></td></tr></table></figure></p>\n<p>如果是直接内存就是</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DirectArena extends PoolArena&lt;ByteBuffer&gt;</span><br></pre></td></tr></table></figure>\n<p>注意两个之中的泛型是不一样的    </p>\n<h1 id=\"分配\"><a href=\"#分配\" class=\"headerlink\" title=\"分配\"></a>分配</h1><p>虽然我们申请内存使用的是PoolArean的方法，但是真正负责分配的还是在PoolChunk中<br>上文中我们提到PoolChunk一下子会直接申请16MB的内存<br>PoolChunk利用两个byte数组来进行内存的管理</p>\n<ul>\n<li><code>byte[] memoryMap = new byte[1 &lt;&lt; maxOrder &lt;&lt; 1] == new byte[4096]</code></li>\n<li><code>byte[] depthMap = new byte[memoryMap.length]</code></li>\n</ul>\n<p>这两个参数构造了一个完美的二叉树<br>在进行初始化的时候按照<code>memoryMap[id] = depth_of_id</code>进行分配<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> memoryMapIndex = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> d = <span class=\"number\">0</span>; d &lt;= maxOrder; ++ d) &#123; <span class=\"comment\">// move down the tree one level at a time</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> depth = <span class=\"number\">1</span> &lt;&lt; d;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> p = <span class=\"number\">0</span>; p &lt; depth; ++ p) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// in each level traverse left to right and set value to the depth of subtree</span></span><br><span class=\"line\">        memoryMap[memoryMapIndex] = (<span class=\"keyword\">byte</span>) d;</span><br><span class=\"line\">        depthMap[memoryMapIndex] = (<span class=\"keyword\">byte</span>) d;</span><br><span class=\"line\">        memoryMapIndex ++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"/images/netty-memorypool/tree.png\" alt=\"tree\">  </p>\n<p>上面我画的图很好的解释了二叉树图到数组的转变<br>有个注意的点就是数组的使用域从Index = 1开始的   </p>\n<p>叶子节点有2048个，每一个叶子节点表示一个逻辑的Page，也就是8k的内存<br>那么叶子节点的父节点就代表16k内存，依次向上，第一个节点表示16MB内存<br>一个PoolChunk有2048个Page</p>\n<p>那么怎么标记那一块内存被使用，那一块没有没使用呢  </p>\n<p>首先既然逻辑单位是Page，那么进行分配的时候都是按照Page来，标记的粒度最小的也是Page<br>不会标记这个Page用了一半的情况  </p>\n<p>这里，类的注释中讲的很清楚  </p>\n<blockquote>\n<p>To allocate a memory segment of size chunkSize/2^k we search for the first node (from left) at height k which is unused</p>\n</blockquote>\n<p>对于MemoryMap而言</p>\n<blockquote>\n<ul>\n<li>1) memoryMap[id] = depth_of_id  =&gt; it is free / unallocated  </li>\n</ul>\n<ul>\n<li>2) memoryMap[id] &gt; depth_of_id  =&gt; at least one of its child nodes is allocated, so we cannot allocate it, but some of its children can still be allocated based on their availability  </li>\n</ul>\n<ul>\n<li>3) memoryMap[id] = maxOrder + 1 =&gt; the node is fully allocated &amp; thus none of its children can be allocated, it is thus marked as unusable</li>\n</ul>\n</blockquote>\n<p><br></p>\n<blockquote>\n<ul>\n<li>1) 如果 memoryMap[id] = depth_of_id 表示这一块还未分配，我们初始化的值就是这样</li>\n<li>2) 如果 memoryMap[id] &gt; depth_of_id 表示下属的内存已经被分配了，但是还未分配完全</li>\n<li>3) 如果 memoryMap[id] = maxOrder + 1 表示下属的内存已经被分配完了 </li>\n</ul>\n</blockquote>\n<p>对于depthMap而言，它的作用是</p>\n<blockquote>\n<p>depthMap[id]= x  indicates that the first node which is free to be allocated is at depth x (from root)  </p>\n</blockquote>\n<p>下面我们仔细走一下流程</p>\n<h2 id=\"size-gt-PageSize\"><a href=\"#size-gt-PageSize\" class=\"headerlink\" title=\"size &gt;  PageSize\"></a>size &gt;  PageSize</h2><p>如果我们申请的内存大于一个PageSize的内存，假设就是(8192 + 1)b的大小  </p>\n<p>首先我们需要对内存进行规整化</p>\n<p>申请大小规整化<br>我们知道Netty把申请的内存分为三类<br>如果小于512，则找到下一个16的倍数最小的<br>2 =&gt; 16<br>3 =&gt; 16<br>15 =&gt; 16<br>17 =&gt; 32</p>\n<p>其中如果大于512，那么就是找到下一个2的次方最小的<br>比如<br>513 =&gt; 1024<br>1050 =&gt; 2048 </p>\n<p>那么8093b被规整化为16k，也就是2个page</p>\n<p>我们知道二叉树depth=11时的节点，分配的是一个Page的<br>depth = 10时的节点，分配的是2个Page的</p>\n<p>然后我们从第一个节点开始迭代<br>判断memoryMap[1]和10的大小</p>\n<p>要判断这个节点下时候还有分配8k的空间，只需要比较<br><code>memoryMap[id] 和 depth_of_memory</code>的大小，这个和下面的分配成功的标记有关 </p>\n<p>如果memoryMap[0]  &gt; 10，则已经分配完了，分配失败<br>否则就肯定还有空间分配16k的内存<br>我们只需要迭代的找子节点，memoryMap[id] == 10，<br>这里不是广度优先搜索，是深度优先，所以只管查找，只要有一个进行  </p>\n<p>那么找到第10层第一个节点  <code>memoryMap[1024]</code><br>那么这个节点代表的内存将被分配出去  </p>\n<p>好，节点找到了，那么下面需要迭代更新父节点的信息<br>因为现在父节点memoryMap[id] = depth_of_id<br>要更新成已经被分配，但是还未分配完全<br>比较子节点的值，选择一个最小的赋给它  </p>\n<p><img src=\"/images/netty-memorypool/alloc.png\" alt=\"tree\">  </p>\n<p>现在父节点的值为10，满足第二个条件<br>父节点的父节点为9，迭代下去，头节点变成1  </p>\n<p>那么假设第10层分了1023个，也就是还剩一个，那么头节点还是10，那么上文的<br>memoryMap[0]  &gt; 10还是不成立，说明还是有空间，这是统一的<br>那么分了1024个，也就是全部分光，那么头节点也就变成12，那么就成立，也就说明没有空间了，也是成立的</p>\n<p>所以总结一下整体流程 </p>\n<ul>\n<li>规整化申请的内存大小 </li>\n<li>找到内存大小在二叉树的哪一层</li>\n<li>从头节点开始找到一个memoryMap[id] == depth_of_memory的节点</li>\n<li>把节点的值置为已使用</li>\n<li>同步更新父节点的值为子节点中的最小的那个</li>\n</ul>\n<h2 id=\"size-lt-PageSize\"><a href=\"#size-lt-PageSize\" class=\"headerlink\" title=\"size &lt; PageSize\"></a>size &lt; PageSize</h2><p>如果申请的内存小于一个Page，那么直接分一个Page有点浪费，但是单个页又标记怎么分又有点麻烦，甚至要消耗更多的空间，不是很值得  </p>\n<p>Netty的做法是直接从PoolChunk中申请一个Page，然后把Page分为等块的大小的内存，大小由第一次来申请的内存决定，下次再来一样的，就直接再从这个Page中找一块给它  </p>\n<p><img src=\"/images/netty-memorypool/tinyalloc.png\" alt=\"tinyalloc\">  </p>\n<p>我们前面知道tiny是小于512字节的，那么规整到16的倍数，也就32种选择<br>small是小于PageSize的，规整到2的次方大小，也就3种选择 1024，2048，4096  </p>\n<p>随意干脆直接创建两个数组，从PoolChunk中申请来一个Page后，直接放到对应的数组位置中，用的时候直接定位到数组就行了<br>因为PoolArean管理很多的PoolChunk，所以这个数组创建在PoolArean中好了  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># PoolArean</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> PoolSubpage&lt;T&gt;[] tinySubpagePools;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> PoolSubpage&lt;T&gt;[] smallSubpagePools;</span><br></pre></td></tr></table></figure>\n<h1 id=\"PoolSubPage\"><a href=\"#PoolSubPage\" class=\"headerlink\" title=\"PoolSubPage\"></a>PoolSubPage</h1><p>由上文我们知道，对于小于一个Page申请的大小，会从PoolChunk中申请一块内存，然后创建一个PoolSubpage来进行管理   </p>\n<p>PoolSubpage的具体管理也不复杂</p>\n<p>首先，假设我们请求一个1k的内存  </p>\n<p>PoolArean会先从PoolChunk直接请求一个Page  </p>\n<p>然后把这一个分为8个1k的内存，并且运用bitmap进行标记  </p>\n<p>同时维护一个numAvail看还有多少可用  </p>\n<h1 id=\"ThreadLocalCache\"><a href=\"#ThreadLocalCache\" class=\"headerlink\" title=\"ThreadLocalCache\"></a>ThreadLocalCache</h1><p>我们知道一个Alloc可能会整个应用只有一个，多线程应用肯定是加锁的<br>为了减少竞争，Netty创建了多个PoolArean  </p>\n<p>同时很多内存资源使用完放回去，如果之后再申请一样大小的，还是要重新走一遍流程  </p>\n<p>如果我们暂时先不放回去，而是放在ThreadLocal中，等再次请求的时候，直接从ThreadLocal中拿，这样高效还不用加锁，减少了申请的次数  </p>\n<p>PoolThreadLocalCache就是做这种工作的<br>这里的运行机制还是蛮绕人的  </p>\n<p>我们先看PoolThreadLocalCache的声明     </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PoolThreadLocalCache</span> <span class=\"keyword\">extends</span> <span class=\"title\">FastThreadLocal</span>&lt;<span class=\"title\">PoolThreadCache</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>FastThreadLocal我们可以看做是ThreadLocal的变种，主要是更改了解决冲突的方法，具体可以看看我的另一个文件，这里我们就把当ThreadLocal理解  </p>\n<p>在Alloc申请内存的时候，会优先调用PoolThreadLocalCache.get方法，得到一个PoolThreadCache<br>我们来看看ThreadLocal的initValue方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">synchronized</span> PoolThreadCache <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> PoolArena&lt;<span class=\"keyword\">byte</span>[]&gt; heapArena = leastUsedArena(heapArenas);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> PoolArena&lt;ByteBuffer&gt; directArena = leastUsedArena(directArenas);</span><br><span class=\"line\"></span><br><span class=\"line\">    Thread current = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (useCacheForAllThreads || current <span class=\"keyword\">instanceof</span> FastThreadLocalThread) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PoolThreadCache(</span><br><span class=\"line\">                heapArena, directArena, tinyCacheSize, smallCacheSize, normalCacheSize,</span><br><span class=\"line\">                DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// No caching so just use 0 as sizes.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PoolThreadCache(heapArena, directArena, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在初始化变量的时候  之前每一个PoolArean里都有一个变量表示自己当前被多少线程持有<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Number of thread caches backed by this arena.</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> AtomicInteger numThreadCaches = <span class=\"keyword\">new</span> AtomicInteger();</span><br></pre></td></tr></table></figure></p>\n<p>leastUsedArena方法就是找到被最少线程持有的PoolArean  </p>\n<p>所以一个Cache和一个PoolArean是绑定的  </p>\n<p>在每个PoolThreadCache内部，有六个MemoryRegionCache<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MemoryRegionCache&lt;<span class=\"keyword\">byte</span>[]&gt;[] tinySubPageHeapCaches;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MemoryRegionCache&lt;<span class=\"keyword\">byte</span>[]&gt;[] smallSubPageHeapCaches;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MemoryRegionCache&lt;ByteBuffer&gt;[] tinySubPageDirectCaches;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MemoryRegionCache&lt;ByteBuffer&gt;[] smallSubPageDirectCaches;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MemoryRegionCache&lt;<span class=\"keyword\">byte</span>[]&gt;[] normalHeapCaches;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MemoryRegionCache&lt;ByteBuffer&gt;[] normalDirectCaches;</span><br></pre></td></tr></table></figure></p>\n<p>每个MemoryRegionCache内部维护了一个Queue<entry<t>&gt; queue<br>当我们调用ByteBuf的release()方法的时候add方法把那一块ByteBuf的信息放进去   </entry<t></p>\n<p>这里还要提一下在PooledByteBufAllocator里面的三个参数</p>\n<ul>\n<li>DEFAULT_TINY_CACHE_SIZE  默认是512</li>\n<li>DEFAULT_SMALL_CACHE_SIZE  默认是256</li>\n<li>DEFAULT_NORMAL_CACHE_SIZE 默认是64</li>\n</ul>\n<p>这三个参数很迷，光看名字还以为是内存的大小<br>其实既然知道MemoryRegionCache内部分了一个queue，那么这里的SIZE就是和queue的大小有关 </p>\n<p>因为如果Queue满了，那么release会直接放到PoolChunk中，而不会缓存起来  </p>\n<p>其中TINY和SMALL的策略和上一节中的分配一样，都是直接建了一个32和3的数组<br>但是这里多了一个对于NORMAL的缓存<br>而且也是建了一个数组，那么这个数组的大小是什么呢？</p>\n<p>这里还牵扯到一个参数</p>\n<ul>\n<li>DEFAULT_MAX_CACHED_BUFFER_CAPACITY 默认是32K</li>\n</ul>\n<p>数组大小<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> max = Math.min(area.chunkSize, maxCachedBufferCapacity);</span><br><span class=\"line\"><span class=\"keyword\">int</span> arraySize = Math.max(<span class=\"number\">1</span>, log2(max / area.pageSize) + <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure></p>\n<p>如果全部按照上面的默认参数来设置  那么arraySize就是3<br>那么数组的Index是这么算出来的<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> idx = log2(normCapacity &gt;&gt; log2(pageSize))</span><br></pre></td></tr></table></figure></p>\n<p>那么<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[8192, 8192 * 2)  =&gt; index = 0</span><br><span class=\"line\">[8192 * 2, 8192 * 4) =&gt; index = 1</span><br><span class=\"line\">[8192 * 4, 8192 * 8) =&gt; index = 2</span><br></pre></td></tr></table></figure></p>\n<p>8192 * 8 刚好是32K，所以Normal的最大到32k，大于这个的内存是不进行缓存的  </p>\n<p>我们知道，内存进行release的时候，会优先进入cache中，那么如果cache之后再没有分配这块，那就会造成内存泄漏  </p>\n<p>所以Netty也做了一个对长时间未使用的cache进行释放的机制   </p>\n<p>主要是维护了一个<code>int allocations</code><br>每次进行allocate的时候，进行+1<br>当分配次数大于一直阈值，默认是8192的时候，就会进行调用MemoryRegionCache的trim方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">trim</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> free = size - allocations;</span><br><span class=\"line\">    allocations = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// We not even allocated all the number that are</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (free &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        free(free);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>MemoryRegionCache的trim方法就是判断size - allocations，如果大于0，那么就会释放多余的不用的Entry</p>\n<h1 id=\"对象池\"><a href=\"#对象池\" class=\"headerlink\" title=\"对象池\"></a>对象池</h1><p>Netty的对象池是一个通用的对象池，可以被用在很多的地方<br>参见我的另外一个文章 </p>\n<h1 id=\"申请\"><a href=\"#申请\" class=\"headerlink\" title=\"申请\"></a>申请</h1><p>看完所有的流程，我们就可以串一遍整体的申请流程了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">allocate</span><span class=\"params\">(PoolThreadCache cache, PooledByteBuf&lt;T&gt; buf, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> reqCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> normCapacity = normalizeCapacity(reqCapacity);   <span class=\"comment\">//先进行申请大小的规整化</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isTinyOrSmall(normCapacity)) &#123; <span class=\"comment\">// capacity &lt; pageSize  如果capacity小于pageSize</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> tableIdx;</span><br><span class=\"line\">        PoolSubpage&lt;T&gt;[] table;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> tiny = isTiny(normCapacity);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tiny) &#123; <span class=\"comment\">// &lt; 512   如果小于512</span></span><br><span class=\"line\">            <span class=\"comment\">//先调用cache进行分配</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cache.allocateTiny(<span class=\"keyword\">this</span>, buf, reqCapacity, normCapacity)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// was able to allocate out of the cache so move on</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//如果分配失败，则找出SubPagePool对应的</span></span><br><span class=\"line\">            tableIdx = tinyIdx(normCapacity);</span><br><span class=\"line\">            table = tinySubpagePools;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cache.allocateSmall(<span class=\"keyword\">this</span>, buf, reqCapacity, normCapacity)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// was able to allocate out of the cache so move on</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            tableIdx = smallIdx(normCapacity);</span><br><span class=\"line\">            table = smallSubpagePools;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> PoolSubpage&lt;T&gt; head = table[tableIdx];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * Synchronize on the head. This is needed as &#123;<span class=\"doctag\">@link</span> PoolChunk#allocateSubpage(int)&#125; and</span></span><br><span class=\"line\"><span class=\"comment\">         * &#123;<span class=\"doctag\">@link</span> PoolChunk#free(long)&#125; may modify the doubly linked list as well.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (head) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> PoolSubpage&lt;T&gt; s = head.next;</span><br><span class=\"line\">            <span class=\"comment\">//如果head != head，说明这个subPage还有空间</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s != head) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">assert</span> s.doNotDestroy &amp;&amp; s.elemSize == normCapacity;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> handle = s.allocate();</span><br><span class=\"line\">                <span class=\"keyword\">assert</span> handle &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">                s.chunk.initBufWithSubpage(buf, handle, reqCapacity);</span><br><span class=\"line\">                incTinySmallAllocation(tiny);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果subPage还未进行初始化，那么就先去PoolChunk申请一块，再放在SubPagePool中</span></span><br><span class=\"line\">            allocateNormal(buf, reqCapacity, normCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        incTinySmallAllocation(tiny);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (normCapacity &lt;= chunkSize) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cache.allocateNormal(<span class=\"keyword\">this</span>, buf, reqCapacity, normCapacity)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// was able to allocate out of the cache so move on</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            allocateNormal(buf, reqCapacity, normCapacity);</span><br><span class=\"line\">            ++allocationsNormal;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Huge allocations are never served via the cache so just call allocateHuge</span></span><br><span class=\"line\">        allocateHuge(buf, reqCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["Netty"],"tags":["Netty","内存池"]},{"title":"Spring Interceptor和Servlet Filter","url":"https://blog.lovezhy.cc/2018/09/20/Spring Interceptor和Servlet Filter/","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>如果想要过滤器，那么Spring Interceptor和Servlet Filer都可以使用<br>但是这两个在实现上还是有本质的区别的。</p>\n<p>这里还是先提一提我之前遇到的问题。 </p>\n<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>在开发Spring的Web应用中</p>\n","categories":["Spring和SpringBoot"],"tags":["Spring"]},{"title":"实习总结","url":"https://blog.lovezhy.cc/2018/09/14/实习总结/","content":"<p>是在<code>3.8</code>号让圭圭帮我投了阿里，当时圭圭问我要投哪个部门，我问他有什么部门比较不错，他就说那就Ads吧。<br>正好Ads在内网都说在招人，他也在和Ads对接服务。<br>我听到Ads是比较懵逼的，不知道这个是做啥的，不过当时也没拒绝，觉得去做一个自己完全不会的方向还挺有意思的，就投了。<br><a id=\"more\"></a></p>\n<p>简历评估面大概在一周后，感觉面试官也没有刻意的准备，在瞎问，想到什么问什么，沟通起来蛮费力的。<br>在面试之前加了一下组里酒哥的微信，面完之后问了下，他说过了，让我接受内推邀请。<br>还挺惊讶的，因为我觉得我面的并不好。<br>一面在周末，是进到组里的师兄面的，面的比较平淡，都是比较基础的问题。<br>二面是老大面的，没问基础，上来就问我看过什么开源项目源码，说了一堆我都不会，后来他说没什么想问的了，就匆匆挂了电话，(后来进组发现他也确实比较忙hhh)<br>三面是高铁面的(fastJson和druid开源项目作者)，问的也比较基础hhh，不过高铁说话比较好玩。<br>最后交叉面是存储部门的Hbase的老大面的，手写了一个代码，然后问了很多的Java问题。<br>两三天后，HR约面，HR面完之后一直是等待消息的状态。</p>\n<p>大概在3.28这儿，我的整个流程就结束了，连HR面一共六面。</p>\n<p>最终的offer是在5.10这儿收到的。<br><img src=\"/images/实习总结/1.jpg\" alt=\"\"></p>\n<p>然后在5.30号，我打包去了杭州，在5.31日正式入职了。</p>\n<h2 id=\"学习\"><a href=\"#学习\" class=\"headerlink\" title=\"学习\"></a>学习</h2><p>组里是做大数据引擎的，通俗点讲就是类似于<code>Spark</code>那种分布式查询的框架。<br>因为之前完全没接触过大数据这些东西，而且对于那个东西不是会用就行，要开发它的话，首先得知道它是怎么运作的。<br>说了这么多，就是说，<strong>我得去看源码</strong><br>这是我最痛苦的事了，但是也是学的最多的一件事<br>而<code>Presto</code>这个框架的文档，而几乎没有解释他们的设计思路，仅仅是几个概念上的讲解<br>所以几乎百度，谷歌上能找到的关于源码的讲解我都看遍了  </p>\n<p>其中也总结了一些心得</p>\n<ul>\n<li><p>学会框架的使用，当然这个是最基本的</p>\n</li>\n<li><p>一开始对源码不要扣的太细，主要学习整个的流程。<br>比如Presto，主要抓住一个Sql过去，从 Parse -&gt; analyse -&gt; schedule -&gt; calc 这四个的流程的串联以及每个阶段大概做了什么<br>学会了大致流程，出现问题基本都能知道大概是哪儿出问题了</p>\n</li>\n<li><p>对特定问题进行Debug，看不懂的时候停下来想一想如果是自己去实现这个功能，自己会怎么做</p>\n</li>\n<li><p>勤做笔记，因为会设计很多类，很多的方法，加上多态继承，会导致Debug起来思路很快就乱掉，这时候也不用太扣具体的方法代码，记得方法到底做了什么</p>\n</li>\n</ul>\n<h2 id=\"工作\"><a href=\"#工作\" class=\"headerlink\" title=\"工作\"></a>工作</h2><p>因为一开始还没有掌握组里的业务，一直在看代码，所以一开始也安排了一些周边的工作<br>在开发的过程最大的体会还是师兄不会手把手的教你，方案也不会给个很具体的。  </p>\n<p>比如：</p>\n<blockquote>\n<p>压力过大怎么办，师兄只会告诉我，搞个缓存吧，你想想怎么搞，搞好了把方案讲给我听听。</p>\n</blockquote>\n<p>所以一般都是我自己设计方案，讲给师兄听，师兄很厉害，一般我提出一个我觉得很完美的方案，师兄总能很快的找出其中的缺陷，然后我再去修改，如此反复，觉得差不多了，就去开发了。</p>\n<p>开发完，都会有codeview，一开始几乎是惨不忍睹，师兄每次codereview完，我几乎都是重构的状态。</p>\n<p>虽然坎坷，但是安排的两个项目，我都是完成了，而且我感觉效果也不错。</p>\n<h2 id=\"感悟\"><a href=\"#感悟\" class=\"headerlink\" title=\"感悟\"></a>感悟</h2><p>其实最大的感悟就是技术前沿性  </p>\n<p>在美团做业务，看不到什么前沿的东西，都是Spring MVC，Mybatis等，老外早就发明出来的东西。</p>\n<p>但是这阿里，你会发现组里都是这个领域很前沿的技术，会很关注最近的会议有什么新的研究成果出来，JDK11会有什么新的特性出来，JIT的运作方式是什么，CodeGen这些，都是网上都很难百度的东西。</p>\n<p>其实就是<strong>沟通能力</strong>，这个真的是<strong>太太太重要了</strong><br>对一个东西的理解，不懂的可以去问<br><strong>如果懂了，也可以去讲给其他人听，一方面可以看自己是不是真的懂了，一方面也可以交换下互相的理解</strong><br><strong>如果懂了，也可以去讲给其他人听，一方面可以看自己是不是真的懂了，一方面也可以交换下互相的理解</strong><br><strong>如果懂了，也可以去讲给其他人听，一方面可以看自己是不是真的懂了，一方面也可以交换下互相的理解</strong>  </p>\n<p>对一个项目的方案，也可以多方讨论，对比利弊，最终得出答案。</p>\n<h2 id=\"百技\"><a href=\"#百技\" class=\"headerlink\" title=\"百技\"></a>百技</h2><p>其中最开心的三天是参加技术大学的培训，百年技术。<br>我参加的那一期是针对实习生的。<br>为期三天，主要是技术实训和创意实训两个部分。</p>\n<p>第一次为大型开源项目编写PR，虽然只是简单的单测哈哈哈。</p>\n<p>认识了好多人好多人，我们这个组本科生出奇的多。<br>有两个还是国外上的本科。<br>实训完的那天晚上听他们讲国外的生活真有意思。</p>\n<h2 id=\"答辩\"><a href=\"#答辩\" class=\"headerlink\" title=\"答辩\"></a>答辩</h2><p>我们答辩通知的很晚，周五答辩，周一才发正式的邮件。<br>而且答辩的内容也是规定好了。<br>基本上整个星期都在做答辩的PPT，组里人也很热心的指导我。<br>（让我一度以为留下来不会有问题了）<br>老大也很热心，时不时的来问我，虽然第一次几乎把我的PPT全盘否定了。<br>最后也是做出来了。 </p>\n<p>结果虽然是没通过，心里稍微有点遗憾。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在阿里的实习的三个月和我想象中的完全不同，总是整个人经历了很多<br>感觉自己也成熟了不少。<br>终究还是离开了，舍不得组里的人，鼎爷，春哥，酒哥，智乔，酷柏，海哥，霄艺，还有联系不多的逍哥 哈哈哈。</p>\n<p>生活还是继续向前！</p>\n","categories":["总结"],"tags":["Life"]},{"title":"从Netty的Connect到lookupAllHostAddr","url":"https://blog.lovezhy.cc/2018/08/27/从Netty的Connect到lookupAllHostAddr/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>用Netty写一个应用，写到Client端的代码，因为之前的模板都是<br><code>ChannelFuture channelFuture = bootstrap.connect().sync();</code><br>这个Connect会阻塞在这儿，但是我不想让他阻塞，于是天经地义的写成了<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ChannelFuture channelFuture = bootstrap.connect();</span><br><span class=\"line\">future.complete(channelFuture.channel());</span><br></pre></td></tr></table></figure></p>\n<p>把channel给complete出去。<br><a id=\"more\"></a></p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>但是我启动的时候发现还是等待了很久，大概等了5s的时间，找了半天，发现是在<code>bootstrap.connect()</code>这儿阻塞了。<br>但是当我改成sync()的时候，发现还是阻塞了5s。<br>这个时候我略崩溃。</p>\n<p>然后问郑阿里星这个方法是不是阻塞的，我是不是记错了。<br>郑阿里星表示他也记得是异步的，不会等很久的。</p>\n<p>我又试了几次发现还是如此，郑阿里星表示把代码发给他，他来试一试。</p>\n<p>然后奇迹出现了，他只花了300ms。</p>\n<p>百思不得其解，为啥我的要5s，他的要300ms。<br>而且我sync()之后也是5s，大概率认为就是没有异步执行。</p>\n<h2 id=\"无头绪\"><a href=\"#无头绪\" class=\"headerlink\" title=\"无头绪\"></a>无头绪</h2><p>一开始我觉得可能是线程池的Reject参数，把connect用户线程做了。<br>于是debug了一下，发现走到了<br><img src=\"/images/netty-connect/1.png\" alt=\"\"><br>这确实是走到了异步的执行里面啊。</p>\n<p>肯定就是中间的哪个部分出现了问题。</p>\n<h2 id=\"定位\"><a href=\"#定位\" class=\"headerlink\" title=\"定位\"></a>定位</h2><p>这时候郑阿里星提供了<code>144.144.144.144</code>这个地址让我试试，我发现还是5s。<br>这个时候基本就是我的电脑的问题，不会是Netty代码的问题了。<br>因为这个就算是sync()的也不会是5s的时间。</p>\n<p>不说了，先重启再说。</p>\n<p>重启完毕，再执行，还是5s。</p>\n<p>好吧，有点崩溃。</p>\n<p>我开个热点，连自己热点看看，<br>然后奇迹出现了，时间变成了300ms，变正常了。</p>\n<p>肯定就是中间的网哪儿的问题啊。</p>\n<p>5s的时间，也不短，我索性把线程全部dump出来，看看main线程block在哪儿了。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> jstack -l `jps | grep Test | awk -F<span class=\"string\">' '</span> <span class=\"string\">'&#123;print $1&#125;'</span>`</span></span><br></pre></td></tr></table></figure></p>\n<p>多试了几次，发现了关键。<br><img src=\"/images/netty-connect/2.png\" alt=\"\"><br>发现都是在<code>java.net.Inet6AddressImpl.lookupAllHostAddr</code>这个方法里。</p>\n<p>去谷歌一搜，似乎真的发现了几个issue。</p>\n<p><a href=\"https://github.com/netty/netty/issues/6454\" target=\"_blank\" rel=\"noopener\">Netty Issue</a></p>\n<p>连block的秒数都和我一样，真的是天才。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>去搜寻了一番，找到了解决办法，修改hosts文件，加上下面两行。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1 zhuyichendeMacBook-Pro.local</span><br><span class=\"line\">::1 zhuyichendeMacBook-Pro.local</span><br></pre></td></tr></table></figure></p>\n","categories":["Netty"],"tags":["Netty"]},{"title":"Presto的Join的细节研究","url":"https://blog.lovezhy.cc/2018/07/22/Presto的Join细节研究/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Presto的Join操作可以说是极为复杂的几个步骤之一<br>加上又无其文档和注释，所以想要了解其细节需要自己去耐心的阅读源码<br>笔者进行了一些研究后，进行了一些自己的理解的整理<br>总结出来，希望对你有用</p>\n<a id=\"more\"></a>\n<h2 id=\"Partition和Broadcast\"><a href=\"#Partition和Broadcast\" class=\"headerlink\" title=\"Partition和Broadcast\"></a>Partition和Broadcast</h2><p>站在整个Presto的体系中，其实数据到底是Partition的分发还是Broadcast的分发在很多环节都有的。<br>那么对于Join而言，Partition肯定是有的。<br>想象对于下面一句话<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> video v <span class=\"keyword\">join</span> <span class=\"keyword\">user</span> u <span class=\"keyword\">on</span> v.user_id = u.id</span><br></pre></td></tr></table></figure></p>\n<p>那么对于整个分布式环境而言，完全可以把video和user表的数据根据join的key按照Hash的方式partition到不同的节点上去进行运算<br>这样提高整体的效率是极好的。  </p>\n<p>那么Join需要Broadcast吗<br>想象下面一句话<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> video v <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> <span class=\"keyword\">user</span> u <span class=\"keyword\">on</span> v.user_id = u.id</span><br></pre></td></tr></table></figure></p>\n<p>那么对于这么一句话，两个表还可以根据key按照Hash的方法partition到不同的节点上去吗？<br>肯定是不行的</p>\n<p>我们可以对左边的表进行partition到不同的节点上，但是对于右边的表，partition肯定是不行了，只有进行Broadcast才能保证数据Join出来是正确的结果  </p>\n<h2 id=\"DistributionType\"><a href=\"#DistributionType\" class=\"headerlink\" title=\"DistributionType\"></a>DistributionType</h2><p>对应到源码级别的就是在JoinNode中<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> DistributionType</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tPARTITIONED,</span><br><span class=\"line\">\tREPLICATED</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个<code>DistributionType</code>的意思就是针对于右表而言的分发方式，那么是怎么进行判断的呢<br>在<code>DetermineJoinDistributionType</code>类<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> JoinNode.<span class=\"function\">DistributionType <span class=\"title\">getTargetJoinDistributionType</span><span class=\"params\">(JoinNode node)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tJoinNode.Type type = node.getType();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (type == RIGHT || type == FULL || (isDistributedJoinEnabled(session) &amp;&amp; !mustBroadcastJoin(node))) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> JoinNode.DistributionType.PARTITIONED;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> JoinNode.DistributionType.REPLICATED;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">mustBroadcastJoin</span><span class=\"params\">(JoinNode node)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> isScalar(node.getRight()) || isCrossJoin(node);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isCrossJoin</span><span class=\"params\">(JoinNode node)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> node.getType() == INNER &amp;&amp; node.getCriteria().isEmpty();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>整体逻辑其实很挺好懂的<br>如果是right join或者是full join，那么右表肯定就是partition的了<br>因为如果是replicated的话，那么肯定就会多出数据来  </p>\n<p>如果是cross join的话，那么也只能是replicated的方式了。<br>这个其实也不难理解，想象下面这句sql<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> video v <span class=\"keyword\">join</span> <span class=\"keyword\">user</span> u <span class=\"keyword\">on</span> v.user_id &gt; u.id</span><br></pre></td></tr></table></figure></p>\n<p>这种情况和下面这种情况是不同的<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> video v <span class=\"keyword\">join</span> <span class=\"keyword\">user</span> u <span class=\"keyword\">on</span> v.user_id = u.id</span><br></pre></td></tr></table></figure></p>\n<p>因为不是等于关系的Join，所以无法根据Hash(user.id) = Hash(u.id)进行partition分发着Join<br>最多只允许一个表去partition，另外一个表是replicated的。<br>那左边的表replicated还是右边的replicated，对于最终的结果是没有区别的。<br>但是在某些情况下并不等同，这个我们留到下面reorder再讲。</p>\n<h2 id=\"Probe和Build\"><a href=\"#Probe和Build\" class=\"headerlink\" title=\"Probe和Build\"></a>Probe和Build</h2><p>对于Presto而言，其实只有一个Join模式。<br>那就是<br>pipeLine0: 读左表 -&gt; LookupJoin<br>pipeLine1: 读右边 -&gt; HashBuilder</p>\n<p>其中是pipeLine1的任务先行，把右表读出来，然后建立一个bucket为N的HashTable。<br>pipeLine0的任务是先读取左边的数据，然后等待HashTable的建立完成，然后进行Join操作。</p>\n<p>其实更细节的话，在pipeLine0的读左表和建立HashTable是两个pipeLine的操作，中间还需要进行数据Hash到Bucket的操作和建立PageIndex的操作。</p>\n<p>那么抽象就是左表是Probe表，然后右表是Build表。<br>永远是右表去Build一个东西，然后左表是Probe数据。</p>\n<p>那你发现问题了吗？<br>如果是这种sql语句呢<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> video v <span class=\"keyword\">right</span> <span class=\"keyword\">join</span> <span class=\"keyword\">user</span> u <span class=\"keyword\">on</span> v.user_id = u.id</span><br></pre></td></tr></table></figure></p>\n<p>对于right join而言，肯定是右表出的是全量的数据，它如果还是build的话，那肯定是不行的。<br>那么怎么解决呢? </p>\n<p><strong>方案：</strong><br>当然这也不是个致命的问题，可选方案也是有好几个。</p>\n<p><strong>1.</strong><br>Reorder<br>就是调换两边的Join顺序<br>把上面的Join变成<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> <span class=\"keyword\">user</span> u <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> video v <span class=\"keyword\">on</span> v.user_id = u.id</span><br></pre></td></tr></table></figure></p>\n<p>这样把左表变成右表，然后把right join变成Left join，可以解决这个问题。</p>\n<p><strong>2.</strong><br>Tracker<br>当然Presto并没有选择上面这种方法，他在build端增加了一个Tracker。<br>这个Tracker的作用就是记录没有被Probe到的行，然后LookupJoin结束后，把那些没有Join扫过的一把抓回去。</p>\n<h2 id=\"Merge-Join和NestLoopJoin\"><a href=\"#Merge-Join和NestLoopJoin\" class=\"headerlink\" title=\"Merge Join和NestLoopJoin\"></a>Merge Join和NestLoopJoin</h2><p>我们分析下可以发现Presto不管对于什么情况的Join，都是由HashBuilderOperator类去进行Build的。<br>这很容易让人理解为Presto中只有Hash Join。<br>但是理论上Hash Join并不是万能的，有些情况是不能解决的。<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> video v <span class=\"keyword\">join</span> <span class=\"keyword\">user</span> u <span class=\"keyword\">on</span> v.user_id &gt; u.is</span><br></pre></td></tr></table></figure></p>\n<p>这种情况，肯定是不可能用HashBuilder去完成的，或者更准确点，不能用HashJoin去完成的。<br>那么肯定是需要NestedLoop Join和Merge Join的存在的。<br>这个其实蕴含在了Hash Join的具体的实现中了。<br>只不过是HashBuilderOperator算子的实现是相同的而已。</p>\n<h2 id=\"Join流程\"><a href=\"#Join流程\" class=\"headerlink\" title=\"Join流程\"></a>Join流程</h2><p>Presto的Join流程还是稍微有点复杂，我花了一天的时间大致梳理一下。<br>这里涉及到几个比较重要的类<br><code>HashBuilderOperator</code><br><code>PagesIndex</code><br><code>PositionLinks</code></p>\n<p>我们假设有这么两张表进行Join，而且Join的语句是这样<br><img src=\"/images/presto-join/demo1.png\" alt=\"\"></p>\n<p>这时候右表的数据以Page为单位进入到HashBuilderOperaor中<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addInput</span><span class=\"params\">(Page page)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        requireNonNull(page, <span class=\"string\">\"page is null\"</span>);</span><br><span class=\"line\">        checkState(!isFinished(), <span class=\"string\">\"Operator is already finished\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        index.addPage(page);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!operatorContext.trySetMemoryReservation(index.getEstimatedSize().toBytes())) &#123;</span><br><span class=\"line\">            index.compact();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        operatorContext.setMemoryReservation(index.getEstimatedSize().toBytes());</span><br><span class=\"line\">        operatorContext.recordGeneratedOutput(page.getSizeInBytes(), page.getPositionCount());</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们假设右表分为了两个Page进入。<br><img src=\"/images/presto-join/demo2.png\" alt=\"\"></p>\n<p>从代码里可以看到的是HashBuilderOperator直接把Page加到了PagesIndex中，从类的名字中我们就可以看出来，这个类是为了建立索引用的。<br>但是具体是如何建立索引呢。让我们再来看看源码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addPage</span><span class=\"params\">(Page page)</span></span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">// ignore empty pages</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (page.getPositionCount() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       positionCount += page.getPositionCount();</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">int</span> pageIndex = (channels.length &gt; <span class=\"number\">0</span>) ? channels[<span class=\"number\">0</span>].size() : <span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; channels.length; i++) &#123;</span><br><span class=\"line\">           Block block = page.getBlock(i);</span><br><span class=\"line\">           channels[i].add(block);</span><br><span class=\"line\">           pagesMemorySize += block.getRetainedSizeInBytes();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> position = <span class=\"number\">0</span>; position &lt; page.getPositionCount(); position++) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">long</span> sliceAddress = encodeSyntheticAddress(pageIndex, position);</span><br><span class=\"line\">           valueAddresses.add(sliceAddress);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       estimatedSize = calculateEstimatedSize();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里比较让人困惑的就是valueAddresses了，这个类是建立Page到channels的索引的类。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyntheticAddress</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SyntheticAddress</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> <span class=\"title\">encodeSyntheticAddress</span><span class=\"params\">(<span class=\"keyword\">int</span> sliceIndex, <span class=\"keyword\">int</span> sliceOffset)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (((<span class=\"keyword\">long</span>) sliceIndex) &lt;&lt; <span class=\"number\">32</span>) | sliceOffset;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">decodeSliceIndex</span><span class=\"params\">(<span class=\"keyword\">long</span> sliceAddress)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((<span class=\"keyword\">int</span>) (sliceAddress &gt;&gt; <span class=\"number\">32</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">decodePosition</span><span class=\"params\">(<span class=\"keyword\">long</span> sliceAddress)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// low order bits contain the raw offset, so a simple cast here will suffice</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>) sliceAddress;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们直接看整个类，就是把Page和每一个Page中的Position进行了编码，编成了一个long类型的字段，前32位为Page的Index，后32位为PostionIndex。<br>那么我们把右表的两个Page加进去的时候，addresses数组和channels就变成了这个样子<br><img src=\"/images/presto-join/demo3.png\" alt=\"\"></p>\n<p><strong>HashRow</strong><br>到上面这一步其实都是为下面做准备的，因为Join而言，如果左表的每个字段都来和右表的每个字段进行比对，那么效率是很低的，这里既然我们准备了t1.col1 = t2.col1，那么不如把col1进行Hash一下好了。</p>\n<p>我们创建一个Key的数据，长度就是所有行数。这里就是4个。<br>然后把col1进行Hash，把addresses的index塞到key数组中，<br><img src=\"/images/presto-join/demo4.png\" alt=\"\"><br>比如图中，第一行的col1是1，我们进行Hash，等于1，于是把addresses对应的数据index放在Key数组中。</p>\n<p>那么下面就是查找了。查找的流程其实和Build的过程类似，先把col1进行Hash，然后去key数组中查找，如果能查到，那么就是拿到了addresses的index，因为addresses中的value是对应的实例的值的pageIndex和PositionIndex的索引，所以再去channels中查找就行。<br>如下图所示<br><img src=\"/images/presto-join/demo5.png\" alt=\"\"></p>\n<p>但是这么还是不够，我们如何处理Hash碰撞的情况呢？<br><img src=\"/images/presto-join/demo6.png\" alt=\"\"><br>像上面这种情况，col1有多个都是1，那么key只是个一维数组，肯定是不行的。<br>那么PositionLinks就排上用场了，思路就是为key的每个Index维护一个一维的链表，<br>在Join的时候，Hash(row)之后去一个一个的找那个链表中的值。</p>\n<p>那么，到现在为止已经很完美了，还有优化的空间吗？<br>答案是有的，看下文。</p>\n<h2 id=\"FastInequalityJoin\"><a href=\"#FastInequalityJoin\" class=\"headerlink\" title=\"FastInequalityJoin\"></a>FastInequalityJoin</h2><p>我们在扩展一下情况，假设col1相等的情况异常的多。</p>\n<p><img src=\"/images/presto-join/demo7.png\" alt=\"\"><br>让我们假设有一千万个，那么单链表就会异常的长，每一行都要去遍历链表吗？<br>显然我们可以再优化一下。</p>\n<p><img src=\"/images/presto-join/demo8.png\" alt=\"\"><br>和图中讲的一样，如果我们修改为Sort，那么在进行col2的查找的时候，直接进行二分查找就行了。</p>\n<p>这个优化在Presto中是默认开启的，叫做<code>fast_inequality_join</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## JoinHashSupplier</span><br><span class=\"line\">PositionLinks.FactoryBuilder positionLinksFactoryBuilder;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sortChannel.isPresent() &amp;&amp;</span><br><span class=\"line\">                isFastInequalityJoin(session)) &#123;</span><br><span class=\"line\">            checkArgument(filterFunctionFactory.isPresent(), <span class=\"string\">\"filterFunctionFactory not set while sortChannel set\"</span>);</span><br><span class=\"line\">            positionLinksFactoryBuilder = SortedPositionLinks.builder(</span><br><span class=\"line\">                    addresses.size(),</span><br><span class=\"line\">                    pagesHashStrategy,</span><br><span class=\"line\">                    addresses);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            positionLinksFactoryBuilder = ArrayPositionLinks.builder(addresses.size());</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们可以看到在JoinHashSupplier的源码中，如果开启了fast_inequality_join，那么默认就会创建<br>SortedPositionLinks，这个和ArrayPositionLinks区别从名字就可以看出是会进行排序的。</p>\n","categories":["Presto"],"tags":["Presto"]},{"title":"Guava库学习之Collections","url":"https://blog.lovezhy.cc/2018/07/21/Guava库学习之Collections/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><code>Collections</code>应该是最最常用的了</p>\n<h2 id=\"MultiMap\"><a href=\"#MultiMap\" class=\"headerlink\" title=\"MultiMap\"></a>MultiMap</h2><p><code>MultiMap</code>是一个接口，形象的用JDK中的形式解释就是<code>Map&lt;K, Collection&lt;V&gt;&gt;</code></p>\n<p><code>MultiMap</code>有很多的实现类  </p>\n<a id=\"more\"></a>\n<h3 id=\"HashMultiMap\"><a href=\"#HashMultiMap\" class=\"headerlink\" title=\"HashMultiMap\"></a>HashMultiMap</h3><p>需要注意的是，<code>HashMultimap</code>每个<code>key</code>对应的<code>value</code>的集合是一个Set<br>所以下面这个输出是</p>\n<blockquote>\n<p>{World=[2], Hello=[1, 3]}</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Multimap&lt;String, Integer&gt; multimap = HashMultimap.create();</span><br><span class=\"line\">multimap.put(<span class=\"string\">\"Hello\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">multimap.put(<span class=\"string\">\"World\"</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">multimap.put(<span class=\"string\">\"Hello\"</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">multimap.put(<span class=\"string\">\"Hello\"</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">System.out.println(multimap);</span><br></pre></td></tr></table></figure>\n<h3 id=\"LinkedListMultimap\"><a href=\"#LinkedListMultimap\" class=\"headerlink\" title=\"LinkedListMultimap\"></a>LinkedListMultimap</h3><p>上面的<code>value</code>是个<code>Set</code>集合，但是如果我们需要是个<code>List</code>集合呢<br>就可以使用<code>LinkedListMultimap</code>这个方法<br>输出</p>\n<blockquote>\n<p>{Hello=[1, 3, 3], World=[2]}</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Multimap&lt;String, Integer&gt; multimap = LinkedListMultimap.create();</span><br><span class=\"line\">multimap.put(<span class=\"string\">\"Hello\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">multimap.put(<span class=\"string\">\"World\"</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">multimap.put(<span class=\"string\">\"Hello\"</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">multimap.put(<span class=\"string\">\"Hello\"</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">System.out.println(multimap);</span><br></pre></td></tr></table></figure>\n<h3 id=\"TreeMultimap\"><a href=\"#TreeMultimap\" class=\"headerlink\" title=\"TreeMultimap\"></a>TreeMultimap</h3><p>和<code>HashMultiMap</code>一样，也是<code>value</code>存的是个<code>Set</code>集合，只是这个使用的是红黑树为底层节点。</p>\n<h2 id=\"MultiSet\"><a href=\"#MultiSet\" class=\"headerlink\" title=\"MultiSet\"></a>MultiSet</h2><p>这个接口的作用大概和<code>Apache Common</code>的<code>Bag</code>的概念类似。<br>虽然名字里带<code>Set</code>，但是其实没有实现Set接口。<br>比如<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Multiset&lt;String&gt; multiset = LinkedHashMultiset.create();</span><br><span class=\"line\">multiset.add(<span class=\"string\">\"1\"</span>);</span><br><span class=\"line\">multiset.add(<span class=\"string\">\"1\"</span>);</span><br><span class=\"line\">multiset.add(<span class=\"string\">\"1\"</span>);</span><br><span class=\"line\">multiset.add(<span class=\"string\">\"2\"</span>);</span><br><span class=\"line\">multiset.add(<span class=\"string\">\"2\"</span>);</span><br><span class=\"line\">multiset.add(<span class=\"string\">\"3\"</span>);</span><br><span class=\"line\">System.out.println(multiset.count(<span class=\"string\">\"1\"</span>)); <span class=\"comment\">// 3</span></span><br><span class=\"line\">System.out.println(multiset.elementSet()); <span class=\"comment\">// 1 2 3</span></span><br></pre></td></tr></table></figure></p>\n<p>理解为<code>Bag</code>，我们往包里放了3个1，2个2，1个3。<br>调用<code>Count</code>我们可以得到里面究竟有多少1。</p>\n<p><code>MultiSet</code>的主要实现有三个类</p>\n<ul>\n<li><code>HashMultiSet</code> 底层使用<code>HashMap</code></li>\n<li><code>LinkedHashMultiSet</code> 底层使用<code>LinkedHashMap</code>，就是元素顺序就依次添加进去的</li>\n<li><code>TreeMultiSet</code> 底层使用的<code>TreeMap</code> </li>\n</ul>\n<h2 id=\"BiMap\"><a href=\"#BiMap\" class=\"headerlink\" title=\"BiMap\"></a>BiMap</h2><p>正常我们维护一个<code>K,V</code>的关系是选用一个<code>Map</code>，但是如果我们不仅仅需要K,V 还需要一个V,K的关系呢 也就是正向是个Map，全部反过来也是个Map。<br>很多人会New两个Map，然后正着放一遍，反着再放一遍<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Integer&gt; nameToId = Maps.newHashMap();</span><br><span class=\"line\">Map&lt;Integer, String&gt; idToName = Maps.newHashMap();</span><br><span class=\"line\"></span><br><span class=\"line\">nameToId.put(<span class=\"string\">\"Bob\"</span>, <span class=\"number\">42</span>);</span><br><span class=\"line\">idToName.put(<span class=\"number\">42</span>, <span class=\"string\">\"Bob\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>但是这样会有问题，因为<code>Map</code>中的<code>value</code>并不保证是个<code>Set</code>集合。</p>\n<p><code>Guava</code>提供了<code>BiMap</code>接口，使得我们不需要创建两个<code>Map</code>，而且也保证<code>Value</code>是个<code>Set</code>集合。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BiMap&lt;String, Integer&gt; biMap = HashBiMap.create();</span><br><span class=\"line\">biMap.put(<span class=\"string\">\"Hello\"</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">biMap.put(<span class=\"string\">\"World\"</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">biMap.put(<span class=\"string\">\"Java\"</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">System.out.println(biMap);</span><br><span class=\"line\"></span><br><span class=\"line\">BiMap&lt;Integer, String&gt; inverse = biMap.inverse();</span><br><span class=\"line\">System.out.println(inverse);</span><br></pre></td></tr></table></figure></p>\n<p>如果我们需要反过来的<code>Map</code>，只需要调用<code>inverse</code>方法就行。</p>\n<h2 id=\"Immutable-Collections\"><a href=\"#Immutable-Collections\" class=\"headerlink\" title=\"Immutable Collections\"></a>Immutable Collections</h2><p>在原生的<code>JDK</code>中，似乎并没有想严格的区分可变集合和不可变集合。<br>但是如果你阅读过<code>Effective Java</code>的话，里面在<strong>第十五条</strong>有提到不可变的对象的好处</p>\n<ul>\n<li>不可变的类比可变类更加易于设计、实现和使用</li>\n<li>不可变对象本质上是线程安全的，它们不要求同步<ul>\n<li>首先作为Map的key等这种场景，肯定是适用的</li>\n<li>因为无法修改，所以在多线程下的迭代不会抛出异常</li>\n</ul>\n</li>\n</ul>\n<p>就像<code>String</code>推荐作为<code>Map</code>的<code>key</code>一样，<code>String</code>天生是不可变类，易用且不会出现什么问题。</p>\n<p>那么怎么理解不可变集合类的用法呢<br>个人觉得就像<code>StringBuilder</code>和<code>String</code>的用法一样</p>\n<h3 id=\"ImmutableList\"><a href=\"#ImmutableList\" class=\"headerlink\" title=\"ImmutableList\"></a>ImmutableList</h3><p>创建不可变的<code>List</code><br>同时这个类的声明中还带有<code>RandomAccess</code>接口<br>所以底层是使用了<code>Array</code>来存储元素</p>\n<p>如果不清楚我们需要多少元素，可以先创建一个<code>builder</code><br><strong>builder()</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;String&gt; arrayList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">arrayList.add(<span class=\"string\">\"Hello\"</span>);</span><br><span class=\"line\">arrayList.add(<span class=\"string\">\"World\"</span>);</span><br><span class=\"line\">arrayList.add(<span class=\"string\">\"Java\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">ImmutableList.Builder&lt;String&gt; stringBuilder = ImmutableList.&lt;String&gt;builder()</span><br><span class=\"line\">    .add(<span class=\"string\">\"Hello\"</span>)</span><br><span class=\"line\">    .add(<span class=\"string\">\"world\"</span>);</span><br><span class=\"line\">    .addAll(arrayList);</span><br><span class=\"line\">stringBuilder.add(<span class=\"string\">\"Java\"</span>);</span><br><span class=\"line\">ImmutableList&lt;String&gt; strings = stringBuilder.build();</span><br></pre></td></tr></table></figure></p>\n<p><strong>of()</strong><br>或者我们可以直接调用<code>of</code>方法如果我们知道已经知道成员变量。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ImmutableList&lt;String&gt; list = ImmutableList.of(<span class=\"string\">\"Hello\"</span>, <span class=\"string\">\"World\"</span>, <span class=\"string\">\"Java\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>因为<code>ImmutableList</code>是实现了<code>List</code>接口，所以我们这样也行<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = ImmutableList.of(<span class=\"string\">\"Hello\"</span>, <span class=\"string\">\"World\"</span>, <span class=\"string\">\"Java\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>如果我们拿到的是<code>List</code>方法，那么他的企图修改List的方法已经被标记为<code>@Deprecated</code><br>并且如果强行调用会抛出<strong><code>UnsupportedOperationException</code></strong></p>\n<p><strong>copyOf()</strong><br>如果我们已经有了一个List，想要根据他来创建一个不可变的<code>List</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;String&gt; arrayList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">arrayList.add(<span class=\"string\">\"Hello\"</span>);</span><br><span class=\"line\">arrayList.add(<span class=\"string\">\"World\"</span>);</span><br><span class=\"line\">arrayList.add(<span class=\"string\">\"Java\"</span>);</span><br><span class=\"line\">ImmutableList&lt;String&gt; immutableList = ImmutableList.copyOf(arrayList);</span><br></pre></td></tr></table></figure></p>\n<p><strong>sortedCopyOf()</strong><br>之前的<code>List</code>是可以进行<code>Collections.sort()</code>方法进行修改的<br>但是<code>ImmutableList</code>是不可变的，所以不可以进行<code>sort</code>，或者说在<code>build</code>完成之前是不可以进行<code>sort</code>的<br>那么我们可以调用<code>sortedCopyOf()</code>方法进行构建<br>那么如果我使用的是<code>Builder</code>方法进行构建，可不可以在<code>build()</code>之前对里面的元素进行排序呢？<br>似乎没看到方法。</p>\n<h3 id=\"ImmutableSet\"><a href=\"#ImmutableSet\" class=\"headerlink\" title=\"ImmutableSet\"></a>ImmutableSet</h3><p>其实和上面的<code>ImmutableList</code>差不是很多，就不讲了。</p>\n<h3 id=\"ImmutableBiMap\"><a href=\"#ImmutableBiMap\" class=\"headerlink\" title=\"ImmutableBiMap\"></a>ImmutableBiMap</h3><p>同时<code>BiMap</code>也提供了不可变的类型<br>我们可以使用<code>Builder</code>类方法或者<code>of</code>方法去进行创建<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ImmutableBiMap.Builder&lt;String, Integer&gt; builder = ImmutableBiMap.builder();</span><br><span class=\"line\">        builder.put(<span class=\"string\">\"Hello\"</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        builder.put(<span class=\"string\">\"World\"</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        builder.put(<span class=\"string\">\"Java\"</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">        ImmutableBiMap&lt;String, Integer&gt; biMap = builder.build();</span><br><span class=\"line\">        System.out.println(biMap);</span><br><span class=\"line\">        BiMap&lt;Integer, String&gt; inverse = biMap.inverse();</span><br><span class=\"line\">        System.out.println(inverse);</span><br></pre></td></tr></table></figure></p>\n","categories":["Guava"],"tags":["Guava"]},{"title":"Presto源码-ExchangeClient和OutputBuffer详解","url":"https://blog.lovezhy.cc/2018/07/20/Presto源码-ExchangeClient和OutputBuffer详解/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><code>Presto</code>在数据进行<code>shuffle</code>的时候，并不是<code>PPT</code>中经常看到的<code>Push</code>模式，而是<code>Pull</code>模式。<br>在两端负责分发和交换数据的类分别是<code>ExchangClient</code>和<code>OutputBuffer</code>。</p>\n<a id=\"more\"></a>\n<p>比如：<br><code>Source Stage</code>把数据从<code>Connector</code>中拉取出来，这时候需要给下一个<code>FixedStage</code>进行处理。<br>他会先把数据放在<code>OutputBuffer</code>中，等待上游把数据请求过去，而上游请求数据的类就是<code>ExchangeClient</code>。</p>\n<h2 id=\"ExchangeClient\"><a href=\"#ExchangeClient\" class=\"headerlink\" title=\"ExchangeClient\"></a>ExchangeClient</h2><p><img src=\"/images/presto-exchangeclient/ExchangeClient.png\" alt=\"\"><br>大体的过程是这样，但是一些细节还是没发画出来，尽力了。<br>下面详细解释下。</p>\n<h3 id=\"ExchangOperator\"><a href=\"#ExchangOperator\" class=\"headerlink\" title=\"ExchangOperator\"></a>ExchangOperator</h3><p>一般来说负责从下游的<code>Stage</code>拉数据有个专门的<code>Operator</code>是<code>ExchangeOperator</code>。<br>在创建<code>ExchangeOperator</code>的时候，会加上一个<code>ExchangClient</code>。<br>所以和图中不同的是，这个<code>ExchangeClient</code>其实是在<code>ExchangeOperator</code>里面。</p>\n<p>在<code>PipeLine</code>的下一个<code>Operator</code>和<code>ExchangeClient</code>拉数据的时候，会调用上一个的<code>getOutput()</code>，返回的是一个<code>Page</code>。<br>在<code>ExchangeOperator</code>的<code>getOutput()</code>方法中<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Page <span class=\"title\">getOutput</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    SerializedPage page = exchangeClient.pollPage();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (page == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    operatorContext.recordGeneratedInput(page.getSizeInBytes(), page.getPositionCount());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> serde.deserialize(page);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>就是调用的<code>exchangeClient</code>的<code>pollPage()</code>方法得到一个Page。</p>\n<h3 id=\"RemoteSplit\"><a href=\"#RemoteSplit\" class=\"headerlink\" title=\"RemoteSplit\"></a>RemoteSplit</h3><p><code>RemoteSplit</code>是<code>Source Stage</code>的<code>Task</code>在生成的时候，会添加给<code>FixedStage</code>的。<br>成员变量特别简单，就是一个标记数据位置的URL。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RemoteSplit</span></span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">ConnectorSplit</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> URI location;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"HttpPageBufferClient\"><a href=\"#HttpPageBufferClient\" class=\"headerlink\" title=\"HttpPageBufferClient\"></a>HttpPageBufferClient</h3><p>在进行<code>addSplit</code>到<code>ExchangOperator</code>的时候，会把每个<code>URL</code>封装成一个<code>HttpPageBufferClient</code>，同时传递进去的还有</p>\n<ul>\n<li>httpClient 整个Task共享的一个，用于发送请求的。</li>\n<li>maxResponseSize 一次相应最多的数据量大小，默认是1M</li>\n<li>new ExchangeClientCallback() 当拿到数据后的回调，把Page加到ExchangeClient的队列中</li>\n<li>executor 所有的http请求都是通过这个线程池发送</li>\n<li>minErrorDuration </li>\n<li>maxErrorDuration<br>上面这两个参数会随之构建一个Backoff的对象。</li>\n</ul>\n<h3 id=\"HttpSchedule\"><a href=\"#HttpSchedule\" class=\"headerlink\" title=\"HttpSchedule\"></a>HttpSchedule</h3><p>如果我们进入到<code>HttpPageBufferClient</code>的<code>scheduleRequest</code>方法，会发现里面并不是立即发送请求，而是运用了一个<code>schedule</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleRequest</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> delayNanos = backoff.getBackoffDelayNanos();</span><br><span class=\"line\">    executor.schedule(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            initiateRequest();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// should not happen, but be safe and fail the operator</span></span><br><span class=\"line\">            clientCallback.clientFailed(HttpPageBufferClient.<span class=\"keyword\">this</span>, t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, delayNanos, NANOSECONDS);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这就涉及了请求的失败重试的问题。<br>简单的说，每一次请求失败，会有一个等待时间，而且随着失败次数的增加，这个等待的时间会越来越长。在这个等待的时间内，不会再去进行请求。<br>我们看创建<code>backoff</code>的代码。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.backoff = <span class=\"keyword\">new</span> Backoff(</span><br><span class=\"line\">    minErrorDuration,</span><br><span class=\"line\">    maxErrorDuration,</span><br><span class=\"line\">    ticker,</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Duration(<span class=\"number\">0</span>, MILLISECONDS),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Duration(<span class=\"number\">50</span>, MILLISECONDS),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Duration(<span class=\"number\">100</span>, MILLISECONDS),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Duration(<span class=\"number\">200</span>, MILLISECONDS),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Duration(<span class=\"number\">500</span>, MILLISECONDS));</span><br></pre></td></tr></table></figure></p>\n<p>分别是50MS，100MS，200MS和500MS。<br>同时有个最小时间和最大时间，防止传递了一个超长的时间，那么就永远挂在这儿了。</p>\n<p>这在一定的程度上缓解了请求的压力，同时为节约了下游的<code>cpu</code>资源。因为如果那台服务器挂了，那么一直无意义的<code>http</code>请求是毫无意义的，还会一直浪费cpu资源。<br>但是这个</p>\n<h3 id=\"流控\"><a href=\"#流控\" class=\"headerlink\" title=\"流控\"></a>流控</h3><p>如果上游的数据来不及消费会怎么样。<br>那么，上游来不及消费的信号是什么呢？<br>整个<code>buffer</code>肯定有个阈值的。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExchangeClientConfig</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> DataSize maxBufferSize = <span class=\"keyword\">new</span> DataSize(<span class=\"number\">32</span>, Unit.MEGABYTE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个阈值就是最大的bufferSize，默认是32M。</p>\n<p>在<code>ExchangClient</code>中，有一个<code>long</code>类型的<code>bufferBytes</code>，用来标记当前的<code>buffer</code>中有多少<code>buffer</code>。<br>在<code>scheduleRequestIfNecessary()</code>方法中，会把<code>bufferBytes</code>和<code>maxBufferSize</code>进行比较，如果已经满足了，那么就不会请求<code>HttpPageBufferClient</code>去请求数据。</p>\n<p>同时<code>HttpPageBufferClient</code>不是划了个定时任务去做拉数据的，整个拉取入口函数都是<code>scheduleRequestIfNecessary()</code>中，需要进行手动调用的。</p>\n<p>那么是在什么时候会进行手动调用呢，查看了一些，在下面情况下会发生：</p>\n<ul>\n<li>在新增<code>URL</code>的时候</li>\n<li>在所有的<code>RemoteSplit</code>分配结束的时候</li>\n<li>在<code>ExchangeOperator</code>进行<code>pollPage</code>时</li>\n</ul>\n<p>其中保证第三个条件是最重要的。</p>\n<h2 id=\"OutputBuffer\"><a href=\"#OutputBuffer\" class=\"headerlink\" title=\"OutputBuffer\"></a>OutputBuffer</h2><p><img src=\"/images/presto-exchangeclient/SqlTask.png\" alt=\"\"></p>\n<p>大体的创建流程如上。</p>\n<h3 id=\"TaskResource\"><a href=\"#TaskResource\" class=\"headerlink\" title=\"TaskResource\"></a>TaskResource</h3><p>一般来说创建Task和更新Task的信息的接口都是<code>/v1/task/{TaskId}</code>。<br>所以<code>Presto</code>使用了一个<code>Guava Cache</code>来进行<code>SqlTask</code>的<code>cache</code>，当是第一次来的时候，会自动创建一个新的<code>SqlTask</code>，而当是进行<code>update</code>的时候，就从<code>cache</code>中拿出来之前创建的。</p>\n<h3 id=\"LazyOutputBuffer\"><a href=\"#LazyOutputBuffer\" class=\"headerlink\" title=\"LazyOutputBuffer\"></a>LazyOutputBuffer</h3><p>当一个请求过来的时候，会从Cache中拿出对应的SqlTask，创建LazyOutputBuffer，这个OutputBuffer只是对外的一个封装，里面还包含了一个类别不同的OutputBuffer。</p>\n<h3 id=\"BroadcastOutputBuffer和PartitionedOutputBuffer\"><a href=\"#BroadcastOutputBuffer和PartitionedOutputBuffer\" class=\"headerlink\" title=\"BroadcastOutputBuffer和PartitionedOutputBuffer\"></a>BroadcastOutputBuffer和PartitionedOutputBuffer</h3><p>具体是哪一种，要根据<code>OutputBuffer</code>的类别来判定。<br>如果是<code>Broadcast</code>类别的，就会创建<code>BroadcastOutputBuffer</code>，如果是<code>Partition</code>类别的，就会创建<code>PartitionedOutputBuffer</code>。<br>然后就会根据<code>OutputBuffers</code>的个数具体创建<code>ClientBuffer</code>。</p>\n<p>然后在<code>TaskOutputOperator</code>或者是<code>PartitionOutputOperator</code>进行<code>finish</code>的时候，都是把<code>Page</code>放到<code>ClientBuffer</code>中。</p>\n<p>如果是<code>BroadcastOutputBuffer</code>类别的，就是把<code>PageReference</code>放到所有的<code>ClientBuffer</code>中，如果是<code>Partition</code>类别的，就是放到指定的<code>ClientBuffer</code>中。</p>\n<h3 id=\"token机制\"><a href=\"#token机制\" class=\"headerlink\" title=\"token机制\"></a>token机制</h3><p><code>Presto</code>的数据传输怎么保证可靠性呢？<br><code>Page</code>什么时候会从下游的<code>OutputBuffer</code>中<code>Remove</code>呢？<br>这个就需要了解一下<code>Presto</code>拿数据时的<code>Token</code>机制。<br>我们查看下游去上游的<code>Stage</code>拿数据的接口是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@GET</span><br><span class=\"line\">@Path(&quot;&#123;taskId&#125;/results/&#123;bufferId&#125;/&#123;token&#125;&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>这里的<code>TaskId</code>很好理解，<code>bufferId</code>就是下游的<code>Task</code>的<code>Id</code>，也就是标记下游的哪个<code>Task</code>来拿的数据，那么这个<code>Token</code>是怎么回事呢？</p>\n<p>我们想象纯粹的没有<code>token</code>这个参数。<br>来一次请求，从<code>Buffer</code>中取出一部分数据回送回去，然后把这部分<code>Page</code>进行<code>Remove</code>。<br>那么问题来了，如果对方接收失败了这部分数据呢？<br>最终问题就是，你怎么知道对方已经拿到了多少数据？<br>要是接收失败，你怎么处理这种失败的情况。</p>\n<p>解答是<code>Presto</code>模拟了<code>Tcp</code>中的<code>Seq</code>和<code>Ack</code>机制。<br>但是因为只有上游需要把数据传送给下游，所以是半双工的。<br><img src=\"/images/presto-exchangeclient/token.png\" alt=\"\"></p>\n<p>首先下游请求数据的时候，会带上Token，也就是Start，然后还会标记你最多给我多少数据，对应图中的就是MaxSize，其中每个Buffer会有一个叫curSeq的游标。</p>\n<p>假设第一次来的时候，上游的队列中有很多Page，前三个大小分别是8，2，6。因为start = 0，也就是从0开始，MaxSize = 12。所以上游会回送前两个Page给下游，同时回送一个NextStart = 2，告诉下游下一次的数据从什么地方开始请求。</p>\n<p>第二次请求，start就是上一次上游回送的2，<code>maxSize</code>依然是12。这时候请求发过来时，上游会把前2个<code>Page</code>给<code>Remove</code>掉。然后把下两个<code>Page</code>回送回去，同时标记下一个从4开始。</p>\n<p>同样的，当第三次请求过来，<code>start = 4</code>，上游继续把4之前的<code>Page</code>给<code>Remove</code>掉。</p>\n<p>那么假设第二次的回复对方没有接收到，那么游标<code>curSeq</code>还是不会变，等下游再次请求的时候，还是从<code>Start=2</code>开始的，就是不会受到影响。</p>\n<p>这就是<code>Presto</code>的传输数据的<code>Token</code>机制，类似于<code>Tcp</code>中的<code>Seq</code>和<code>Ack</code>，保证了数据传输的可靠性。</p>\n<h3 id=\"流控-1\"><a href=\"#流控-1\" class=\"headerlink\" title=\"流控\"></a>流控</h3><p>上次提到了<code>ExchangeClient</code>端的流控，当数据来不及消费的时候，那么<code>ExchangClient</code>就不会来请求数据了。<br>那么这时候<code>OutputBuffer</code>端会出现什么样子的情况呢？</p>\n<p>同样的，也是有一个配置标记一个Task的Buffer最大能存多少。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OutputBufferMemoryManager</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> maxBufferedBytes;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个类，每一个<code>BroadcastOutputBuffer</code>或者<code>PartitionedOutputBuffer</code>都会含有一个，用来监控当前已经的<code>buffer</code>的大小。</p>\n<p>如果我们简单的想一想其实监控已经很简单，每来一个<code>Page</code>，把大小加进去，每出一个<code>Page</code>把大小减去，如果当前攒着的大小超过了阈值，那么就返回<code>Blocked</code>，把整个<code>Driver</code>给<code>Block</code>掉，不去执行了。</p>\n<p>这种想法其实没错，实现起来也不是很难，足以应付<code>partition</code>的情形，因为每一个<code>Page</code>进来，只会分到<strong>指定</strong>的<strong>一个</strong><code>ClientBuffer</code>中，移除的时候直接减去就行了。<br><img src=\"/images/presto-exchangeclient/partition.png\" alt=\"\"></p>\n<p>但是如果是<code>broadcast</code>情形呢。<br>每个<code>ClientBuffer</code>中其实都有一个<code>Page</code>的引用，只有当所有的下游<code>Task</code>把对应的<code>ClientBuffer</code>里面的<code>Page</code>取走了才能把大小给减去，那么你怎么知道已经被所有的<code>Task</code>取走了呢？<br><img src=\"/images/presto-exchangeclient/broadcast.png\" alt=\"\"></p>\n<p>如果我们看代码，其实<code>Presto</code>并没有直接把<code>Page</code>放进<code>Buffer</code>中，而是包装了一个<code>PageReference</code>类，传递进去原先的<code>Page</code>和一个回调，这个回调就是把当前的<code>BufferSize</code>减去<code>CurPageSize</code>。<br>再进去看发现这是个引用计数的实现，每<code>add</code>到<code>Buffer</code>中一次，计数就加一，每从<code>buffer</code>中移除一次，计数就减一，当为0的时候，就调用回调把<code>size</code>减去。<br>这真的是很精妙了。</p>\n","categories":["Presto"],"tags":["Presto"]},{"title":"Guava学习之异步编程","url":"https://blog.lovezhy.cc/2018/07/20/Guava学习之异步编程/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>其实<code>Java</code>里的异步的情况不是特别多，之前处处都是同步的处理的。<br>但是感觉自从<code>Node</code>火起来之后，<code>Java</code>中的异步也开始火了起来。<br>比如<code>Vertx</code>这个被称为<code>Java</code>版的<code>Node</code>库。</p>\n<a id=\"more\"></a>\n<p>之前一直用的是<code>JDK8</code>自带的<code>CompletableFuture</code>，在<code>Presto</code>的代码里经常看到<code>Guava</code>的异步的<code>Listener</code>，所以这里也来学习一番。</p>\n<p><br></p>\n<h2 id=\"ListeningExecutorService\"><a href=\"#ListeningExecutorService\" class=\"headerlink\" title=\"ListeningExecutorService\"></a>ListeningExecutorService</h2><p><code>Guava</code>为了支持自己的<code>Listener</code>模式，新建了一种<code>ExecutorService</code>，叫做<code>ListeningExecutorService</code>。<br>我们可以使用<code>MoreExecutor</code>去创建它。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建一个由invode线程去运行的线程池</span></span><br><span class=\"line\">ListeningExecutorService executorService = MoreExecutors.newDirectExecutorService();</span><br><span class=\"line\"><span class=\"comment\">//装饰一个自己的线程池返回</span></span><br><span class=\"line\">ListeningExecutorService executorService = MoreExecutors.listeningDecorator(Executors.newCachedThreadPool());</span><br></pre></td></tr></table></figure></p>\n<p>创建完毕之后我们就可以创建自己的<code>ListenableFuture</code>了<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ListenableFuture&lt;?&gt; listenableFuture = executorService.submit(() -&gt; &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"Hello\"</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h2 id=\"addListener\"><a href=\"#addListener\" class=\"headerlink\" title=\"addListener\"></a>addListener</h2><p>上面创建完成自己的<code>ListenableFuture</code>之后，可以为他添加<code>Listener</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ListenableFuture&lt;?&gt; listenableFuture = executorService.submit(() -&gt; &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"Hello\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">listenableFuture.addListener(() -&gt; &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"world\"</span>);</span><br><span class=\"line\">&#125;, executorService);</span><br></pre></td></tr></table></figure></p>\n<p>上面这是没有返回值的情况，如果我们的是有返回值的呢。<br>就是调用下面的<code>CallBack</code>了</p>\n<p><br></p>\n<h2 id=\"addCallBack\"><a href=\"#addCallBack\" class=\"headerlink\" title=\"addCallBack\"></a>addCallBack</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ListenableFuture&lt;String&gt; listenableFuture = executorService.submit(() -&gt; &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"Hello\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">Futures.addCallback(listenableFuture, <span class=\"keyword\">new</span> FutureCallback&lt;String&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(@Nullable String result)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"get \"</span> + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Throwable t)</span> </span>&#123;</span><br><span class=\"line\">        t.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, executorService);</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h2 id=\"Futures-allAsList\"><a href=\"#Futures-allAsList\" class=\"headerlink\" title=\"Futures.allAsList\"></a>Futures.allAsList</h2><p>这个方法用来把多个<code>ListenableFuture</code>组合成一个。<br>当其中一个<code>Future</code>失败或者取消的时候，将会进入失败或者取消。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ListenableFuture&lt;String&gt; future1 = executorService.submit(() -&gt; <span class=\"string\">\"Hello\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">ListenableFuture&lt;Integer&gt; future2 = executorService.submit(() -&gt; <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">ListenableFuture&lt;List&lt;Object&gt;&gt; future = Futures.allAsList(future1, future2);</span><br><span class=\"line\"></span><br><span class=\"line\">future.addListener(() -&gt; &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"Done!\"</span>);</span><br><span class=\"line\">&#125;, executorService);</span><br><span class=\"line\"></span><br><span class=\"line\">Futures.addCallback(future, <span class=\"keyword\">new</span> FutureCallback&lt;List&lt;Object&gt;&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(@Nullable List&lt;Object&gt; result)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Throwable t)</span> </span>&#123;</span><br><span class=\"line\">        t.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, executorService);</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h2 id=\"Futures-transform-Async\"><a href=\"#Futures-transform-Async\" class=\"headerlink\" title=\"Futures.transform[Async]\"></a>Futures.transform[Async]</h2><p>这个方法用于转换返回值<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ListenableFuture&lt;String&gt; future1 = executorService.submit(() -&gt; <span class=\"string\">\"Hello\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">ListenableFuture&lt;Integer&gt; listenableFuture = Futures.transform(future1, String::length, executorService);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(listenableFuture.get());</span><br></pre></td></tr></table></figure></p>\n<p>这个是同步的方法，如果需要异步的执行<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ListenableFuture&lt;String&gt; future1 = executorService.submit(() -&gt; <span class=\"string\">\"Hello\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">ListenableFuture&lt;Integer&gt; listenableFuture = Futures.transformAsync(future1, input -&gt; Futures.immediateFuture(input.length()), executorService);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(listenableFuture.get());</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h2 id=\"Futures-successfulAsList\"><a href=\"#Futures-successfulAsList\" class=\"headerlink\" title=\"Futures.successfulAsList\"></a>Futures.successfulAsList</h2><p>和allAsList相似，唯一差别是对于失败或取消的Future返回值用null代替。不会进入失败或者取消流程。</p>\n<p><br></p>\n<h2 id=\"immediateFuture和immediateCancelledFuture\"><a href=\"#immediateFuture和immediateCancelledFuture\" class=\"headerlink\" title=\"immediateFuture和immediateCancelledFuture\"></a>immediateFuture和immediateCancelledFuture</h2><p>这个两个类主要就是包装同步结果返回一个Future的。<br>其实内部结果已经确定了。<br>这两个的isDone的返回值不同。<br>immediateFuture是True而immediateCancelledFuture是false</p>\n<p><br></p>\n<h2 id=\"SettableFuture\"><a href=\"#SettableFuture\" class=\"headerlink\" title=\"SettableFuture\"></a>SettableFuture</h2><p>感觉这是个异步执行，同步获取的方法，只是用起来很方便。<br>如果我们在一个线程中需要等待另外一个线程的异步任务。<br>那么我们就可以去设置一个SettableFuture<br>但是在进行get获取的时候，是同步阻塞的。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SettableFuture&lt;String&gt; settableFuture = SettableFuture.create();</span><br><span class=\"line\"></span><br><span class=\"line\">executorService.submit(() -&gt; &#123;</span><br><span class=\"line\">    settableFuture.set(<span class=\"string\">\"Hello\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(settableFuture.isDone());</span><br><span class=\"line\">System.out.println(settableFuture.get()); <span class=\"comment\">//blocked</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h2 id=\"JdkFutureAdapters\"><a href=\"#JdkFutureAdapters\" class=\"headerlink\" title=\"JdkFutureAdapters\"></a>JdkFutureAdapters</h2><p>一个适配器的类，把<code>JDK</code>的<code>Future</code>转化成<code>ListenableFuture</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class=\"line\">Future&lt;String&gt; stringFuture = executorService.submit(() -&gt; <span class=\"string\">\"hello,world\"</span>);</span><br><span class=\"line\">ListenableFuture&lt;String&gt; listenableFuture = JdkFutureAdapters.listenInPoolThread(stringFuture);</span><br></pre></td></tr></table></figure></p>\n","categories":["Guava"],"tags":["Guava"]},{"title":"Presto源码解析 - Slice实现","url":"https://blog.lovezhy.cc/2018/07/19/Presto源码解析-Slice实现/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Presto的Slice并不在Presto包中，是在一个独立的包<code>org.airlift.slice</code>中<br><code>org.airlift</code>是个工具类，作者也是Presto的主要开发者，主要是服务于Presto的，但是我们也可以单独取出来用。<br><a id=\"more\"></a></p>\n<h2 id=\"ClassLayout和Unsafe\"><a href=\"#ClassLayout和Unsafe\" class=\"headerlink\" title=\"ClassLayout和Unsafe\"></a>ClassLayout和Unsafe</h2><p>在Java中一般是无法取得类的大小的，需要通过一些特殊的手段，例如Unsafe包中的方法。<br><code>org.openjdk.jol</code>包封装了很多Unsafe的方法。<br>我们可以通过<code>ClassLayout</code>类来或者我们创建的Java对象在内存中的大小。</p>\n<p>通过Unsafe我们可以对对象的内存直接进行操作。<br>假设我们创建一个int类型的数组，每个元素的值是他Index的位置<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">20</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        nums[i] = i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面这种写法是常规的写法。<br>我们也可以用Unsafe。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 调用反射获得Unsafe实例</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        Field field = Unsafe.class.getDeclaredField(<span class=\"string\">\"theUnsafe\"</span>);</span><br><span class=\"line\">        field.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        Unsafe unsafe = (Unsafe) field.get(<span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">20</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>  i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            unsafe.putInt(nums, (<span class=\"keyword\">long</span>) i * Unsafe.ARRAY_INT_INDEX_SCALE + Unsafe.ARRAY_INT_BASE_OFFSET, i);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>Unsafe实例我们需要通过反射获得，直接获得会抛出异常。<br>ARRAY_INT_BASE_OFFSET表示数组对象的第一个元素在内存中的位置。<br>ARRAY_INT_INDEX_SCALE表示每一个真正的元素的数据中的占据空间。<br>这些变量都在Unsafe中，还有许多，对应byte数组，long数组等。</p>\n<p>同样的，只要能获得对象的地址，那么我们就可以对任意的对象进行写入。<br>我们尝试在Object对象中写入两个Long元素<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 调用反射获得Unsafe实例</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        Field field = Unsafe.class.getDeclaredField(<span class=\"string\">\"theUnsafe\"</span>);</span><br><span class=\"line\">        field.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        Unsafe unsafe = (Unsafe) field.get(<span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Object object = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\">        System.out.println(object);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> size  = ClassLayout.parseClass(Object.class).instanceSize();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"size: \"</span> + size); <span class=\"comment\">// 16</span></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 把Object写为两个long</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        unsafe.putLong(object, <span class=\"number\">0L</span>, <span class=\"number\">13L</span>);</span><br><span class=\"line\">        unsafe.putLong(object, (<span class=\"keyword\">long</span>) SizeOf.SIZE_OF_LONG, <span class=\"number\">19L</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(unsafe.getLong(object, <span class=\"number\">0L</span>)); <span class=\"comment\">// 13</span></span><br><span class=\"line\">        System.out.println(unsafe.getLong(object, (<span class=\"keyword\">long</span>)SizeOf.SIZE_OF_LONG)); <span class=\"comment\">// 19</span></span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(object); <span class=\"comment\">// upe</span></span><br></pre></td></tr></table></figure></p>\n<p>需要注意的是，这样Object对象就是<strong>不可用</strong>了。<br>如果我们强行输出的话，会抛出空指针异常。</p>\n<p>同样的，我们可以对对象进行设值，这个时候我们可以借助ClassLayout封装好的方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//get set...</span></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder(<span class=\"string\">\"Person&#123;\"</span>);</span><br><span class=\"line\">            sb.append(<span class=\"string\">\"name='\"</span>).append(name).append(<span class=\"string\">'\\''</span>);</span><br><span class=\"line\">            sb.append(<span class=\"string\">\", age=\"</span>).append(age);</span><br><span class=\"line\">            sb.append(<span class=\"string\">'&#125;'</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person person = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">        ClassLayout personClassLayout = ClassLayout.parseClass(Person.class);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> size = personClassLayout.instanceSize();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"size: \"</span> + size);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"header size: \"</span> + personClassLayout.headerSize());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 得到所有的field的信息</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        SortedSet&lt;FieldLayout&gt; fields = personClassLayout.fields();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (FieldLayout layout : fields) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (layout.name()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">\"name\"</span>:</span><br><span class=\"line\">                    unsafe.putObject(person, ((<span class=\"keyword\">long</span>) layout.offset()), <span class=\"string\">\"Zhu\"</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">\"age\"</span>:</span><br><span class=\"line\">                    unsafe.putInt(person, ((<span class=\"keyword\">long</span>) layout.offset()), <span class=\"number\">20</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(person); <span class=\"comment\">// Person&#123;name='Zhu', age=20&#125;</span></span><br></pre></td></tr></table></figure>\n<p><strong>总之，这就给了一个类似于利用大对象的内存配合Unsafe直接操作内存的方法做一个内存池的思路</strong></p>\n<h2 id=\"Slices\"><a href=\"#Slices\" class=\"headerlink\" title=\"Slices\"></a>Slices</h2><p>我们无法直接创建Slice类，可以通过Slices类提供的很多的静态方法来进行创建。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Slice <span class=\"title\">allocate</span><span class=\"params\">(<span class=\"keyword\">int</span> capacity)</span></span>; </span><br><span class=\"line\"><span class=\"comment\">//利用这个方法我们可以直接创建一个容量为capacity的Slice，底层就是创建了一个byte[capacity]的数组，不过这个对象是在堆内的</span></span><br><span class=\"line\"><span class=\"function\">Slice <span class=\"title\">allocateDirect</span><span class=\"params\">(<span class=\"keyword\">int</span> capacity)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//利用这个方法我们可以在堆外创建一块内存，底层是使用的nio的ByteBuffer.allocateDirect</span></span><br></pre></td></tr></table></figure>\n<p>创建了Slice之后，就可以往里面添加元素了。<br>在Presto中最重要的两个用法就是FixedWidthBlock和VariableWidthBlock了。<br>创建者两种Block运用他的Builder类FixedWidthBlockBuilder和VariableWidthBlockBuilder类。</p>\n<h3 id=\"FixedWidthBlockBuilder\"><a href=\"#FixedWidthBlockBuilder\" class=\"headerlink\" title=\"FixedWidthBlockBuilder\"></a>FixedWidthBlockBuilder</h3><p><img src=\"/images/presto-slice/FixedBlock.png\" alt=\"\"></p>\n<p>定长的Block，所以会固定一个FixedSize，然后底层就是一个byte数组。<br>不管我们往里面写什么，只要一个entry的长度是FixedSize就行。<br>同时这个不提供自动扩展内存的功能，当超出大小时，会抛出异常。</p>\n<h3 id=\"VariableWidthBlockBuilder\"><a href=\"#VariableWidthBlockBuilder\" class=\"headerlink\" title=\"VariableWidthBlockBuilder\"></a>VariableWidthBlockBuilder</h3><p><img src=\"/images/presto-slice/varBlock.png\" alt=\"\"><br>变长的Block，没有固定的大小，所以需要一个额外的数组记录指定entry的位置<br>同时在每次增加之前会确保内存空间足够，如果不够会进行自动扩容。</p>\n","categories":["Presto"],"tags":["Presto"]},{"title":"Presto的分段源码解析","url":"https://blog.lovezhy.cc/2018/07/10/Presto的分段源码解析/","content":"<h2 id=\"先行流程\"><a href=\"#先行流程\" class=\"headerlink\" title=\"先行流程\"></a>先行流程</h2><p>在进行分段之前，已经建立好计划数PlanNode，并且已经进行了所有的planOptimizers进行优化。<br>最后在SqlQueryExecution#doAnalyzeQuery()的PlanFragmenter中进行分段。</p>\n<a id=\"more\"></a>\n<h2 id=\"Stage抽象\"><a href=\"#Stage抽象\" class=\"headerlink\" title=\"Stage抽象\"></a>Stage抽象</h2><blockquote>\n<p>Stage：unit of work that does not require shuffling  </p>\n</blockquote>\n<p>这个定义是抄的某个PPT上面的，虽然有点抽象，但是也算是个通俗的原则。</p>\n<h2 id=\"PlanFragmenter\"><a href=\"#PlanFragmenter\" class=\"headerlink\" title=\"PlanFragmenter\"></a>PlanFragmenter</h2><p>在进行分段的流程同样是Visit模式，这里的Visit类是PlanFragmenter的内部类Fragmenter。</p>\n<p>每一段之间的分段标记符是RemoteSourceNode</p>\n<p>在看Fragmenter源码时，我们会发现每遇到一个Remote的ExchangeNode，都会创建一个RemoteSourceNode。在其他的地方都不会创建。<br>所以核心在ExchangeNode上。</p>\n<h2 id=\"AddExchanges\"><a href=\"#AddExchanges\" class=\"headerlink\" title=\"AddExchanges\"></a>AddExchanges</h2><p>既然是Remote的ExchangeNode决定了分段，那么这些ExchangeNode是什么时候添加进去的呢。</p>\n<p>经过查找发现是在AddExchanges的Optimizer类中。</p>\n<p>他在进行优化的时候，也是运用的Visit模式。</p>\n<p><strong>聚合数据节点</strong><br>首先在OutputNode的时候，如果Child计划不是运行在一个Node上的，就会加上一个Remote的ExchangeNode，同时Type是GATHER，意思就是Child节点的数据远程传输集中到这个OutPutNode上来。</p>\n<p>在SortNode上，如果底层的Child计划不是SingleNode运行的，那么就会加上Remote的ExchangeNode，同时Type是GATHER</p>\n<p>在TopNNode上，同样的，如果是FINAL级别的TopN(因为TopN是可以先进行Partition的)，并且Child不是在一个节点上，那么就会创建一个Remote的ExchangeNode，同时Type是GATHER。</p>\n<p>同时在LimitNode节点上也是如此。</p>\n<p><strong>总结：</strong><br>在进行OutputNode，SortNode，TopNNode，或者是LimitNode这种需要聚合所有节点的数据来进行操作的，如果Child的执行计划是在多个节点上运行，那么就会加上RemoteExchangeNode来进行分段。</p>\n<p><strong>Join节点</strong><br>和上面的聚合数据的节点不同，Join节点的处理方式较为复杂。<br><code>select * from video v join user u on v.user_id = u.user_id</code><br>想象这么一句话。<br>如果不考虑数据分布的情况，正常的处理就是</p>\n<ul>\n<li>随机选择Fixed阶段处理节点</li>\n<li>从Source把数据读出</li>\n<li>video的数据按照user_id的Hash进行shuffle到Fixed节点</li>\n<li>user的数据按照user_id的Hash进行shuffle到Fixed节点</li>\n</ul>\n<p>但是如果video的原先数据分布就是按照user_id进行分布的呢。<br>那我们这时候，把user的数据按照user_id分到video的节点上。<br>是不是更好呢。</p>\n<p>那么这样的话，原先是这样的结构。<br><img src=\"/images/presto-stage/JoinStage1.png\" alt=\"\"></p>\n<p>那么就可以变成这样的结构<br><img src=\"/images/presto-stage/JoinStage2.png\" alt=\"\"><br>如果左表特别大的话，那么就省去了很多的shuffle时间。</p>\n","categories":["Presto"],"tags":["Presto"]},{"title":"行列存储的区别","url":"https://blog.lovezhy.cc/2018/06/05/行列存储的区别/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>行列存储的区别，上次在串讲的时候被问到了。<br>因为没有作为具体的分析，所以今天就来全方面的分析一下。<br><a id=\"more\"></a></p>\n<h2 id=\"存储方式\"><a href=\"#存储方式\" class=\"headerlink\" title=\"存储方式\"></a>存储方式</h2><p>假设我们拥有一张表，有两个字段为name和age</p>\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th>age</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Zhao</td>\n<td>19</td>\n</tr>\n<tr>\n<td>Qian</td>\n<td>20</td>\n</tr>\n<tr>\n<td>Sun</td>\n<td>21</td>\n</tr>\n<tr>\n<td>Li</td>\n<td>22</td>\n</tr>\n</tbody>\n</table>\n<p>我们知道磁盘的存储是以页为单位的，每一页的存储地址是连续的<br>下面看看两种不同的存储方式的区别</p>\n<h3 id=\"行式\"><a href=\"#行式\" class=\"headerlink\" title=\"行式\"></a>行式</h3><p>那么假设我们以行来存储<br><img src=\"/images/行列存储/行式存储.png\" alt=\"\"><br>简单的看就是每一行的数据都是存在连续的一块地址中</p>\n<h3 id=\"列式\"><a href=\"#列式\" class=\"headerlink\" title=\"列式\"></a>列式</h3><p>列式存储根据字段进行切割，把每一个字段的数据存在一起。<br><img src=\"/images/行列存储/列式存储.png\" alt=\"\"></p>\n<h2 id=\"压缩\"><a href=\"#压缩\" class=\"headerlink\" title=\"压缩\"></a>压缩</h2><p>一般来说数据可以进行压缩，以减少存储的空间。<br>对于行式来说，很难进行压缩，因为每个表的字段的类型是不统一的，除非预先确认，否则无法动态的进行压缩。<br>但是列式的就不一样了，每一个字段的类型是确定的，占用大小也是确定的，所以很容易进行压缩。</p>\n<p><strong>字典压缩：</strong><br>假设年龄字段基本就是在18到25之间，那么我们可以建立一个字典，如下<br><img src=\"/images/行列存储/字典压缩.png\" alt=\"\"><br>当数据量达到亿级或者千亿级，这样其实是可以省下大量的空间，提高了IO的效率</p>\n<h2 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h2><p>对于查询而言，针对不同的查询场景，行式和列式的区别较大。<br>还是以上面的表为例</p>\n<p><strong>1.</strong><br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">avg</span>(age) <span class=\"keyword\">from</span> <span class=\"keyword\">table</span></span><br></pre></td></tr></table></figure></p>\n<p>对于这句Query，如果是行式，我们需要</p>\n<ul>\n<li>读取<strong>所有</strong>的Page</li>\n<li>在内存中<strong>跳着读</strong>所有的age字段的数据</li>\n<li>进行计算</li>\n</ul>\n<p>而对于列式而言</p>\n<ul>\n<li>读取<strong>存储age字段</strong>的page</li>\n<li>在内存中<strong>连续读</strong>取所有的age字段</li>\n<li>进行计算</li>\n</ul>\n<p>显而易见的是肯定是列式的效率更高一点。<br>同时列式还可以更好的利用Cpu Cache的特性加快读取。</p>\n<p><strong>Cpu Cache</strong><br>对于Cpu的缓存而言，一次的缓存大小是固定的，比如是64KB，叫做一个Cache Line。<br>那么我们在读age为19的地址的时候，由于那部分凑不齐64KB，那么cpu就是把读取地址附近的数据也读过去以补齐一个Cache Line。<br>那么可能读18的时候，把后面的19，20，21一起读到Cache中了。<br>下面在进行读的时候，就不用继续读取内存了，直接在缓存中拿就行了。</p>\n<p><strong>2.</strong><br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> <span class=\"keyword\">table</span> <span class=\"keyword\">where</span> age = <span class=\"number\">18</span></span><br></pre></td></tr></table></figure></p>\n<p>对于这句Query，假设行式都有索引的情况下<br>行式</p>\n<ul>\n<li>读取Page1</li>\n<li>连续读一块内存</li>\n<li>进行计算</li>\n</ul>\n<p>列式</p>\n<ul>\n<li>读取Page1和Page2</li>\n<li>跳着读出所有指定行的字段数据</li>\n<li>计算输出</li>\n</ul>\n<p>显而易见是行式更好一点。<br>拥有更好的IO效率和更好的运用了Cpu Cache</p>\n<p><strong>总结：</strong><br>对于只需要指定字段的查询，那么行式拥有更好的效率</p>\n<h2 id=\"Insert和Update\"><a href=\"#Insert和Update\" class=\"headerlink\" title=\"Insert和Update\"></a>Insert和Update</h2><p>对于传统的数据库需求<br>插入和更新的语句较多的情况</p>\n<p><strong>行式</strong><br>如果是行式的话，更新只需要找到指定的行的地址，进行修改就行了。<br>对于插入操作，只需要在将上一行的指向下一行的指针修改为插入的那一行的数据就行了。</p>\n<p><strong>列式</strong><br>对于列式而言，如果没有开启压缩，那么对于更新操作而言其实和行式的差不多。<br>但是如果开启了压缩，那么还需要解压缩-&gt;修改-&gt;压缩的操作，消耗的时间更久。<br>同样的，对于插入操作，即使没有开启压缩，那么需要的时间也很久，因为指定行的数据是连续的放在一起，在其中插入一个，必然导致后面的会进行后移。</p>\n<p><strong>总结：</strong><br>对于行式而言，频繁的插入和更新操作损耗较小<br>对于列式而言，频繁的插入和更新操作损耗较大</p>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>正常来说</p>\n<blockquote>\n<p>行式存储比较适合OLTP，列式存储比较适合OLTP</p>\n</blockquote>\n<p>因为对于OLTP而言</p>\n<ul>\n<li>查询需要全字段，只需要指定的几行的语句较多</li>\n<li>插入，删除，更新操作较多</li>\n</ul>\n<p>对于OLAP而言</p>\n<ul>\n<li>插入，删除，更新操作较少</li>\n<li>经常只需要相关的列</li>\n</ul>\n<p>而这恰恰是运用了行式和列式的优点和缺点。</p>\n","categories":["数据库"],"tags":["数据库"]},{"title":"Presto基本概念","url":"https://blog.lovezhy.cc/2018/06/03/Presto基本概念/","content":"<h2 id=\"基本介绍\"><a href=\"#基本介绍\" class=\"headerlink\" title=\"基本介绍\"></a>基本介绍</h2><p>Presto是FaceBook开源的一个分布式的Sql Engine。<br>对标的是Impala之类的Mpp引擎。<br>主打的是实时分析和多数据源支持。<br>更详细的介绍和同类框架的对于可以参见 </p>\n<p><a href=\"http://www.ouyangchen.com/wp-content/uploads/2017/03/Meetup-Druid%E5%92%8CKylin%E5%9C%A8%E7%BE%8E%E5%9B%A2%E7%82%B9%E8%AF%84%E7%9A%84%E9%80%89%E5%9E%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5.pdf\" target=\"_blank\" rel=\"noopener\">Druid和Kylin在美团点评的选型与实践</a></p>\n<p>这个PPT总结的很好</p>\n<a id=\"more\"></a>\n<h2 id=\"基本抽象\"><a href=\"#基本抽象\" class=\"headerlink\" title=\"基本抽象\"></a>基本抽象</h2><h3 id=\"Stage\"><a href=\"#Stage\" class=\"headerlink\" title=\"Stage\"></a>Stage</h3><blockquote>\n<p>Stage: unit of work that does not require shuffling</p>\n</blockquote>\n<p>这是内部分享总结的，仔细品味一下还是很有道理的。<br>正常的讲，Stage就是查询的执行阶段。<br>一般分为四种Stage:</p>\n<ul>\n<li>Source Stage: 从数据源读取数据</li>\n<li>Fixed Stage: 进行中间的运算</li>\n<li>Single Stage: 也称为Root Stage，这个是必不可少的，用于最后把数据汇总给Coordinator</li>\n<li>Coordinator_Only：用于执行DDL语句等不需要进行计算的语句</li>\n</ul>\n<h3 id=\"Task\"><a href=\"#Task\" class=\"headerlink\" title=\"Task\"></a>Task</h3><p>Task是Stage的具体分布式查询计划，由Coordinator进行划分<br>Task需要通过Http接口发送到具体的Node上去，然后生成对应的本地执行计划<br>一个Stage可以分解为多个<strong>同构</strong>的Task</p>\n<h3 id=\"Driver\"><a href=\"#Driver\" class=\"headerlink\" title=\"Driver\"></a>Driver</h3><p>Task是发送到本地的执行计划<br>Task被分为<strong>多种</strong>Driver去并发的执行</p>\n<h3 id=\"Operator\"><a href=\"#Operator\" class=\"headerlink\" title=\"Operator\"></a>Operator</h3><p>一个Driver内包含多个Operator<br>真正操作Page数据的是Operator<br>一个Operator代表一种操作，比如Scan-&gt;读取数据, Filter -&gt; 过滤数据</p>\n<h3 id=\"Block和Page\"><a href=\"#Block和Page\" class=\"headerlink\" title=\"Block和Page\"></a>Block和Page</h3><p><img src=\"/images/presto-basic/page.png\" alt=\"\"><br>Block是一张表的一个字段对应的队列<br>Page由Block构成，一个Page包含多个Block，多个Block横切为一行。</p>\n","categories":["Presto"],"tags":["Presto"]},{"title":"OLAP基本知识","url":"https://blog.lovezhy.cc/2018/05/23/OLAP基本知识/","content":"<h2 id=\"OLAP和OLTP\"><a href=\"#OLAP和OLTP\" class=\"headerlink\" title=\"OLAP和OLTP\"></a>OLAP和OLTP</h2><p><code>OLTP</code>（<code>OnLine Transaction Processing</code> ，联机事务处理），如<code>MySQL</code>, <code>MicroSoft SQL Server</code>等关系数据库系统，这些关系数据库系统擅长事务处理，在数据操作中保持着很强的一致性和原子性，能够很好的支持频繁的数据插入和修改，但是，一旦需要进行计算的数据量过大，达到数千万甚至数十亿条，或需要进行的计算非常复杂的情况下，<code>OLTP</code>类数据库系统便力不从心了。</p>\n<a id=\"more\"></a>\n<p>这个时候，我们便需要<code>OLAP</code>（<code>On-Line Analytical Processing</code>，联机分析处理）系统，来进行处理。从广义上，<code>OLAP</code>系统是针对<code>OLTP</code>系统而言的，暨不特别关心对数据进行输入、修改等事务性处理，而是关心对已有的大量数据进行多维度的、复杂的分析的一类数据系统。</p>\n<h2 id=\"数据仓库\"><a href=\"#数据仓库\" class=\"headerlink\" title=\"数据仓库\"></a>数据仓库</h2><blockquote>\n<p>英文名称为Data Warehouse，可简写为DW或DWH。</p>\n<p>是为企业所有级别的决策制定过程，提供所有类型数据支持的战略集合。它是单个数据存储，出于分析性报告和决策支持目的而创建。</p>\n</blockquote>\n<p>简单的理解就是把OLTP的数据抽取出来，按照主题分类，存到数据仓库里，然后通过OLAP进行分析。<br>所以数据仓库的数据一般都很大很大，因为包含了很多的历史数据</p>\n<p>当然更深的理论我还要继续去学习。<br>等我学到了再来补充这个。</p>\n<h2 id=\"实时数据仓库\"><a href=\"#实时数据仓库\" class=\"headerlink\" title=\"实时数据仓库\"></a>实时数据仓库</h2><p>我去实习的组有个业务是实时数据仓库。<br>说实话一开始我是懵逼的，因为我看到的概念里，数据仓库的查询一般是很慢的，但是现在加上实时两个字是啥意思。<br>后来我去百度了一下，发现还真有这个概念。 </p>\n<p>实时数仓的实时主要体现在两个方面</p>\n<ul>\n<li>实时插入：数据除了可以通过离线Batch的行为导入仓库，还可以像Mysql那样进行实时的插入。</li>\n<li>查询快速：运用Mpp等大规模的分布式的查询引擎，可以在秒级或者毫秒级返回结果。</li>\n</ul>\n<h2 id=\"Ad-hoc\"><a href=\"#Ad-hoc\" class=\"headerlink\" title=\"Ad-hoc\"></a>Ad-hoc</h2><p>Ad-hoc是数据仓库领域的专业术语。<br>表示没有预先计划或者按很低的计划或不可预期的事件。</p>\n<p>即席查询与通常查询从SQL语句上来说，并没有本质的差别。<br>它们之间的差别在于，通常的查询在系统设计和实施时是已知的，所有我们可以在系统实施时通过建立索引、分区等技术来优化这些查询，使这些查询的效率很高。<br>而即席查询是用户在使用时临时生产的，系统无法预先优化这些查询，所以即席查询也是评估数据仓库的一个重要指标</p>\n<p>所以Ad-hoc查询对数据仓库的要求很高。</p>\n<h2 id=\"MPP\"><a href=\"#MPP\" class=\"headerlink\" title=\"MPP\"></a>MPP</h2><p>Mpp：大规模并行处理 (Massively Parallel Processor)<br>简单的说就是分布式计算。<br>一般像Presto这种，可以处理PB级别的数据</p>\n<h2 id=\"维度表和事实表\"><a href=\"#维度表和事实表\" class=\"headerlink\" title=\"维度表和事实表\"></a>维度表和事实表</h2><p>是数据仓库中或者BI中的概念</p>\n<p>比如描述人可以有两个维度：姓名和年级。<br>我们又有这个人的大学表。<br>这时候我们可以做一个表是姓名 - 年级 - 大学<br>那么这个表就是事实表，而单独的姓名和年级和大学表都是维度表。</p>\n<h2 id=\"数据库分区\"><a href=\"#数据库分区\" class=\"headerlink\" title=\"数据库分区\"></a>数据库分区</h2><p>之前只听过分库分表，但是分区真的没听过。<br>查了一下其实Mysql也是支持分区的。</p>\n<p>一般来说分区需要指名一个字段和分区数。<br>每插入一条数据，根据分区列进行Hash，然后插入<strong>指定分区</strong>。</p>\n<p>Mysql的分区大多是指的分文件，几个分区就会被分成几个文件。</p>\n<p>但是真正在分布式数据库中的分区就不仅仅是这样了。<br>相当于一个文件就代表着一个数据节点。<br>每插入一个数据，根据分区列进行Hash，然后插入<strong>指定Node</strong>。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://help.aliyun.com/document_detail/26387.html?spm=a2c4g.11186623.6.566.xHxTVZ\" target=\"_blank\" rel=\"noopener\">https://help.aliyun.com/document_detail/26387.html?spm=a2c4g.11186623.6.566.xHxTVZ</a></p>\n<p>(<a href=\"https://help.aliyun.com/document_detail/64020.html?spm=a2c4g.11186623.6.632.S3SGxf)[https://help.aliyun.com/document_detail/64020.html?spm=a2c4g.11186623.6.632.S3SGxf\" target=\"_blank\" rel=\"noopener\">https://help.aliyun.com/document_detail/64020.html?spm=a2c4g.11186623.6.632.S3SGxf)[https://help.aliyun.com/document_detail/64020.html?spm=a2c4g.11186623.6.632.S3SGxf</a>]</p>\n","categories":["数据库"],"tags":["大数据"]},{"title":"分布式基础知识","url":"https://blog.lovezhy.cc/2018/05/01/分布式基础知识/","content":"<h2 id=\"分布式，集群，单点问题\"><a href=\"#分布式，集群，单点问题\" class=\"headerlink\" title=\"分布式，集群，单点问题\"></a>分布式，集群，单点问题</h2><p>与分布式相对应的就是单机的概念。<br>比如一个服务，依赖<code>nginx</code>，<code>tomcat</code>，<code>mysql</code>，<code>redis</code> 这么多组件。<br>单机的话可能就部署在一个服务器上。<br>这样的话容易服务器挂了，整个服务就不可用了。<br>同时可扩展性不是很好，一台普通的机器用来跑简单的服务还是可以的，万一是个需要高并发的，数据量比较大的呢，那就只能去买大型机了，但是大型机价格昂贵。同时还是避免不了如果机器挂了，整个服务就不可用的问题。<br><a id=\"more\"></a><br>好，那我们从单机的状态下转移出来<br>现在我们<code>Redis</code>，<code>Tomcat</code>，<code>Mysql</code>，<code>Nginx</code>都是单独在一台服务器上。<br>那么整个服务就可以称为是分布式的。</p>\n<p>那么集群是怎么回事呢？<br>就比如跑<code>Nginx</code>这个服务器挂了，<code>Nginx</code>也就挂了，那么即使<code>Mysql</code>没挂，整个服务还是不能正常运行。<br>这个<code>Nginx</code>服务器就是个单点问题。<br>所以即使把服务都分开部署，还是无法解决不可用的问题，那么怎么提高服务的可用性呢。</p>\n<p>那就是使用集群了。<br>我们部署三个机器都是跑<code>Nginx</code>，那么一台挂了不至于导致整个服务不可用。<br>当然<code>Nginx</code>一般来说是无状态的，如果整个集群是有状态的呢。<br>那就需要一些一致性协议来进行实现。<br>真正做起来还是比较复杂的。</p>\n<h2 id=\"CAP\"><a href=\"#CAP\" class=\"headerlink\" title=\"CAP\"></a>CAP</h2><p>CAP理论由Eric Brewer教授在2000年提出的<br>主要说明了一点，在一个分布式环境中<br>Consistency一致性、Availability可用性、Partition-tolerance分区容错性<br>这三个条件不能同时满足，最多只能满足其中的两个。</p>\n<p>其实我们在仔细斟酌下，按照我的理解，其实这个是针对集群的，比如Zookeeper集群，称为是分布式环境中的其实不太准确。<br>再而这个针对的是什么集群呢，nginx集群吗，显然不是，看第一条，一致性，nginx需要什么一致性？那么在仔细想下，这个理论应该是针对提供数据相关功能的服务的。比如数据库之类。  </p>\n<p><img src=\"images/分布式/cap.png\" alt=\"\"></p>\n<p>从上图我们可以看到，一个服务最多满足<code>CAP</code>中的两个而放弃另外一个，像<code>Redis</code>放弃了可用性，选择了一致性和分区容错性。当然这是单机的Redis。</p>\n<p>那么这三个条件具体是什么意思呢</p>\n<ul>\n<li><p>一致性  简单的说，同样的数据在多个集群的所有机器上是否是一样的<br>或者这么说，同一个请求在一个集群中所有的机器上的结果应当是一样的。不允许出现不一样的状态。</p>\n</li>\n<li><p>可用性  整个集群对于别的服务的请求必须在有限时间内返回结果。</p>\n</li>\n<li><p>分区容错性  这个比较难理解，首先什么是分区呢，正常来说，整个集群应该是一个整体，每台机器可以通过网络互相沟通，但是可能因为网络分区的原因，出现了两个分区，每个分区的机器都可以互相沟通，但是跨分区的机器不能沟通。<br>如果数据项只在一个节点中，那么分区出现后，和这个节点之前连通的部分就访问不到这个数据了，那么这就是分区不容忍的。<br>提高分区容忍性的办法就是一个数据项复制到多个节点上，那么出现分区之后，这一数据项就可能分布到各个区里。容忍性就提高了。<br>然而，要把数据复制到多个节点，就会带来一致性的问题，就是多个节点上面的数据可能是不一致的。要保证一致，每次写操作就都要等待全部节点写成功，而这等待又会带来可用性的问题。总的来说就是，数据存在的节点越多，分区容忍性越高，但要复制更新的数据就越多，一致性就越难保证。为了保证一致性，更新所有节点数据所需要的时间就越长，可用性就会降低。  </p>\n</li>\n</ul>\n<p>所以正常情况下，分布式系统中，都要满足分区容错性，然后在一致性和可用性之间做出权衡。  </p>\n<h2 id=\"BASE\"><a href=\"#BASE\" class=\"headerlink\" title=\"BASE\"></a>BASE</h2><p>BASE理论在CAP提出之后，因为CAP提出三个条件，提供数据服务的集群最多保证其中两个。<br>同时一般来说我们P是不可能放弃的，基本都是在C和A之间权衡。<br>那么具体怎么权衡呢，BASE就是一种讨论的结果。</p>\n<p>BASE是Basically Available, Soft state, Eventually consistent三个短语的缩写。<br>也就是基本可用，软状态，最终一致性。</p>\n<h3 id=\"基本可用\"><a href=\"#基本可用\" class=\"headerlink\" title=\"基本可用\"></a>基本可用</h3><p>基本可用不代表不可用，而是在一些情况下在高可用上有稍许的宽松<br>比较典型的就是</p>\n<ul>\n<li>响应时间上的损失  </li>\n<li>功能上的损失，降级等。</li>\n</ul>\n<h3 id=\"弱状态\"><a href=\"#弱状态\" class=\"headerlink\" title=\"弱状态\"></a>弱状态</h3><p>允许系统出现中间状态<br>即允许数据同步的过程中存在延迟</p>\n<h3 id=\"最终一致性\"><a href=\"#最终一致性\" class=\"headerlink\" title=\"最终一致性\"></a>最终一致性</h3><p>强一致性的条件比较严格，就比如我提出了一个写请求，那么我写完之后，必须保证每个机器上都能得到体现，数据必须是一样的。这是强一致性。</p>\n<p>最终一致性就是允许中间有延迟时间，但是保证一定会达到一致，至于多久，这个并没有严格的限制。</p>\n<h2 id=\"2PC\"><a href=\"#2PC\" class=\"headerlink\" title=\"2PC\"></a>2PC</h2><p>2PC =&gt;  Two Phase Commitment Protocol<br>也就是二阶段提交协议  </p>\n<p>在分布式事务中，事务协调器和资源管理器进行事务的过程。  </p>\n<p><img src=\"images/分布式/2pc.png\" alt=\"\"></p>\n<p>第一阶段<br>TM像所有的RM发送prepare指令，相当于执行start transection并执行sql语句，但是并不提交。<br>RM执行完之后会向TM发送反馈。</p>\n<p>第二阶段<br>接收完RM的反馈后，如果有返回NO的，那么TM向所有的RM发送abort指令，放弃事务提交<br>如果反馈全是Yes，那么发送commit指令。</p>\n<p>整个过程很简单，各个书上对这个过程的描述也是一致的。</p>\n<h2 id=\"3PC\"><a href=\"#3PC\" class=\"headerlink\" title=\"3PC\"></a>3PC</h2><p>由2PC的名字可以联想到，其实这个是三阶段提交协议的意思</p>\n<p>三阶段提交协议主要把2PC的第二阶段拆分为两个阶段 preCommit和doCommit阶段</p>\n<p><img src=\"images/分布式/3pc.png\" alt=\"\"></p>\n<h2 id=\"2PC和3PC对比\"><a href=\"#2PC和3PC对比\" class=\"headerlink\" title=\"2PC和3PC对比\"></a>2PC和3PC对比</h2><p>首先对一下细节的探究。</p>\n<ul>\n<li><p>2PC中TM有主备机制吗？<br>这个问题困扰了我很久，最后得到的结论是没有的，只有一个TM，挂了就全局阻塞。<br>参见文章<a href=\"https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-2003-96.pdf\" target=\"_blank\" rel=\"noopener\">链接</a><br>文章的3.3节中提到</p>\n<blockquote>\n<p>They have usually attempted to “fix” the Two-Phase Commit protocol by<br>choosing another TM if the first TM fails.</p>\n</blockquote>\n</li>\n<li><p>2PC中如果TM挂了，那么RM有超时机制吗<br>从众多描述中可以发现是没有的<br>参见问题<br><a href=\"https://stackoverflow.com/questions/44301852/why-is-two-phase-commit-2pc-blocking\" target=\"_blank\" rel=\"noopener\">链接1</a><br><a href=\"https://cs.stackexchange.com/questions/76192/why-is-two-phase-commit-2pc-blocking\" target=\"_blank\" rel=\"noopener\">链接2</a><br>注意这种情况是TM挂了的情况，如果是RM挂了，TM是可以具有超时abort机制的。</p>\n</li>\n<li><p>2PC的数据不一致的情况<br><a href=\"https://blog.csdn.net/yyd19921214/article/details/68953629\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<blockquote>\n<p>2PC协议中，如果出现协调者和参与者都挂了的情况，有可能导致数据不一致。<br>这里解释一下他说的不一致是什么情景，就是协调者进入第二阶段，发送Commit请求了，当发给第一个RM时挂了，第一个RM收到请求，Commit后也挂了。</p>\n</blockquote>\n</li>\n</ul>\n<p>但是如果这么想的话，因为RM没有超时机制，下面就只有等TM被repair，这时候其实并不是严格处于一个数据不一致的状态。</p>\n<ul>\n<li>3PC怎么解决这么问题的<br>其实仔细看的话，3PC确实解决了一些问题，但是3PC本身还是有问题的。<ul>\n<li>引入RM超时机制，如果发出canCommit后TM挂了，那么RM超时后会自动取消事务，同样的，如果preCommit后TM挂了，那么RM超时后会自动提交事务，一部分情况下避免了无线阻塞。</li>\n<li>引入TM重新选举</li>\n</ul>\n</li>\n</ul>\n<p>但是3PC解决了2PC的问题了吗，阻塞问题算了解决了一下，但是数据不一致的问题确实依然存在的。<br>加入TM发出一个preCommit后挂了，然后一个RM接收到preCommit，其他的没接收到，超时后其他的abort了，只有一个commit了，那么数据不一致还是存在的，而且似乎更严重了一些。</p>\n<p>下面是一些资料：<br>摘自维基百科 <a href=\"https://en.wikipedia.org/wiki/Two-phase_commit_protocol#Disadvantages\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<blockquote>\n<p>The greatest disadvantage of the two-phase commit protocol is that it is a blocking protocol. If the coordinator fails permanently, some cohorts will never resolve their transactions: After a cohort has sent an agreement message to the coordinator, it will block until a commit or rollback is received.</p>\n</blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/Three-phase_commit_protocol\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<blockquote>\n<p>A two-phase commit protocol cannot dependably recover from a failure of both the coordinator and a cohort member during the Commit phase. If only the coordinator had failed, and no cohort members had received a commit message, it could safely be inferred that no commit had happened. If, however, both the coordinator and a cohort member failed, it is possible that the failed cohort member was the first to be notified, and had actually done the commit. Even if a new coordinator is selected, it cannot confidently proceed with the operation until it has received an agreement from all cohort members, and hence must block until all cohort members respond.</p>\n</blockquote>\n<p><a href=\"https://blog.csdn.net/yyd19921214/article/details/68953629\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<blockquote>\n<p>2PC协议中，如果出现协调者和参与者都挂了的情况，有可能导致数据不一致。<br>这里解释一下他说的不一致是什么情景，就是协调者进入第二阶段，发送Commit请求了，当发给第一个RM时挂了，第一个RM收到请求，Commit后也挂了。</p>\n</blockquote>\n<p><a href=\"http://www.win.tue.nl/~atif/reports/paper4ICET.pdf\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<blockquote>\n<p>Blocking: The Two-Phase Commit Protocol goes to a<br>blocking state by the failure of the coordinator when the<br>participants are in uncertain state. The participants keep<br>locks on resources until they receive the next message<br>from the coordinator after its recovery.</p>\n</blockquote>\n<p><a href=\"https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-2003-96.pdf\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<blockquote>\n<p>In a transaction commit protocol, if one or more RMs fail, the transaction<br>is usually aborted. For example, in the Two-Phase Commit protocol, if the<br>TM does not receive a Prepared message from some RM soon enough after<br>sending the Prepare message, then it will abort the transaction by sending<br>Abort messages to the other RMs. However, the failure of the TM can cause<br>the protocol to block until the TM is repaired. In particular, if the TM fails<br>right after every RM has sent a Prepared message, then the other RMs have<br>no way of knowing whether the TM committed or aborted the transaction.</p>\n</blockquote>\n<p>总结一下，主要还是两个问题</p>\n<ul>\n<li>阻塞问题</li>\n<li>数据不一致问题<br>但是优点也是显而易见的</li>\n<li>容易实现</li>\n</ul>\n<h2 id=\"XA协议\"><a href=\"#XA协议\" class=\"headerlink\" title=\"XA协议\"></a>XA协议</h2><p>XA是一个分布式事务的规范，由X/Open组织提出的。<br>X/Open组织定义了分布式事务处理模型 -&gt; X/Open DTP模型。<br>在DTP模型中定义了三个组件</p>\n<ul>\n<li>Application Program (AP)，应用程序，使用DTP模型的程序</li>\n<li>Resource Manager (RM)，资源管理器，可以理解未一个DBMS系统，或者消息服务器管理系统，应用程序通过资源管理器对资源进行控制，资源必须实现XA定义的接口。</li>\n<li>Transaction Manager(TM)，事务管理器，负责协调和管理事务，提供给AP应用程序变成接口并管理资源管理器。事务管理器向事务指定标识，监视它们的进程，并负责处理事务的完成和失败。</li>\n</ul>\n<p><img src=\"images/分布式/XA.png\" alt=\"\"></p>\n<p><img src=\"images/分布式/XA1.png\" alt=\"\"></p>\n<p>一个例子:</p>\n<ul>\n<li>AP与RM之间，可以使用RM自身提供的native API进行交互，这种方式就是使用RM的传统方式，并且这个交互不在TM的管理范围内，另外，当AP和RM之间需要进行分布式事务的时候，AP需要得到对RM的链接(此链接由TM管理)，然后使用XA的native API来进行交互。</li>\n<li>AP和TM之间，该例子中使用的是TX接口，也是由X/Open所规范的。它用于对事务进行控制，包括事务启动，提交事务和回滚事务。</li>\n<li>TM与RM之间是通过XA接口进行交互。TM管理了到RM的连接，并实现了两阶段提交。</li>\n</ul>\n<p>总结：2PC和3PC一定程度上其实是实现了XA协议的。</p>\n<h2 id=\"Paxos\"><a href=\"#Paxos\" class=\"headerlink\" title=\"Paxos\"></a>Paxos</h2><h3 id=\"Paxos和2PC\"><a href=\"#Paxos和2PC\" class=\"headerlink\" title=\"Paxos和2PC\"></a>Paxos和2PC</h3><p>上文提到了数据服务集群的一致性问题，那么怎么保证数据的强一致性呢。<br>这里就需要用到Paxos算法。<br>很多人会认为2PC和Paxos解决了同样的问题，Paxos更为先进，可以放弃2PC了。<br>但是这个其实也是不准确的。<br>因为2PC和Paxos本质上解决的不是同一个问题。<br>2PC是为了分布式事务，Paxos是维持多个副本之间的数据一致。 </p>\n<h2 id=\"Raft和Zab\"><a href=\"#Raft和Zab\" class=\"headerlink\" title=\"Raft和Zab\"></a>Raft和Zab</h2><p>Raft和Zab也是一致性算法。</p>\n<p>上文说我们已经有了Paxos，那么为什么还提出Raft和Zab呢，因为Paxos的理解较为复杂，也没有提出技术细节的解决方案，较为理论，虽然解决的一致性问题很通用，对于一些细节的阐述不是很清晰。</p>\n<p>为了需要一个能实现的算法，于是有了Raft和Zab。</p>\n<p>Raft和Zab的区别其实不是很大，Zab主要是用在Zookeeper上。</p>\n<p>下面主要说说Raft协议。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><p>CAP部分的分区容错性 =&gt;<br><a href=\"https://www.zhihu.com/question/54105974/answer/139037688\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/54105974/answer/139037688</a></p>\n</li>\n<li><p>BASE部分参考=&gt; 《从Paxos到Zookeeper，分布式一致性原理与实践》  </p>\n</li>\n<li><p>XA协议部分参考=&gt; 《大型网站系统与JAVA中间件实践》</p>\n</li>\n</ul>\n<h2 id=\"课外阅读\"><a href=\"#课外阅读\" class=\"headerlink\" title=\"课外阅读\"></a>课外阅读</h2><p><a href=\"https://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html\" target=\"_blank\" rel=\"noopener\">https://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html</a></p>\n","categories":["分布式"],"tags":["分布式"]},{"title":"brpc-doc笔记","url":"https://blog.lovezhy.cc/2018/04/11/brpc-doc笔记/","content":"<h2 id=\"原子指令\"><a href=\"#原子指令\" class=\"headerlink\" title=\"原子指令\"></a>原子指令</h2><p>在涉及到多线程时一般会用到锁。</p>\n<p>但是重量级锁带来的race condition又会大量的消耗性能。</p>\n<p>于是有了乐观锁，典型的就是借助原子指令，CAS来进行操作。这个还依赖的是硬件的发展。<br><a id=\"more\"></a></p>\n<p>但是原子指令又会带来ABA问题和memory face问题。</p>\n<p>如果只是简单的变值的ABA其实是没什么问题的，但是链表的ABA问题就大了。</p>\n<p><a href=\"https://www.zhihu.com/question/23281499\" target=\"_blank\" rel=\"noopener\">ABA</a></p>\n<p>Memory face之前没有了解过，看了看是内存屏障的意思。</p>\n<p>有点像volatile的禁止指令局部指令重排序的样子。</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Memory_barrier\" target=\"_blank\" rel=\"noopener\">memory face</a></p>\n<h2 id=\"Cacheline\"><a href=\"#Cacheline\" class=\"headerlink\" title=\"Cacheline\"></a>Cacheline</h2><p>Cache Entry </p>\n<blockquote>\n<p>Data is transferred between memory and cache in blocks of fixed size, called <em>cache lines</em> or <em>cache blocks</em>. When a cache line is copied from memory into the cache, a cache entry is created. The cache entry will include the copied data as well as the requested memory location (called a tag).</p>\n</blockquote>\n<p><br></p>\n<blockquote>\n<p>When the processor needs to read or write a location in main memory, it first checks for a corresponding entry in the cache. The cache checks for the contents of the requested memory location in any cache lines that might contain that address. If the processor finds that the memory location is in the cache, a cache hit has occurred. However, if the processor does not find the memory location in the cache, a cache miss has occurred. In the case of a cache hit, the processor immediately reads or writes the data in the cache line. For a cache miss, the cache allocates a new entry and copies data from main memory, then the request is fulfilled from the contents of the cache.</p>\n<p>​                                                                                                                                                            — wiki</p>\n</blockquote>\n<p>这里涉及到修改common memory让其他cpu的cache line中的值失效的问题。</p>\n<blockquote>\n<p>当另一个核心读或写同一处内存时，它得确认看到其他核心中对应的cacheline。对于软件来说，这个过程是原子的，不能在中间穿插其他代码，只能等待CPU完成<a href=\"https://en.wikipedia.org/wiki/Cache_coherence\" target=\"_blank\" rel=\"noopener\">一致性同步</a>，这个复杂的硬件算法使得原子操作会变得很慢，在E5-2620上竞争激烈时fetch_add会耗费700纳秒左右。</p>\n<p>访问被多个线程频繁共享的内存往往是比较慢的。</p>\n</blockquote>\n<p><br> </p>\n<blockquote>\n<p>要提高性能，就要避免让CPU频繁同步cacheline。这不单和原子指令本身的性能有关，还会影响到程序的整体性能。最有效的解决方法很直白：<strong>尽量避免共享</strong>。</p>\n</blockquote>\n<p><br> </p>\n<blockquote>\n<p>一个依赖全局多生产者多消费者队列(MPMC)的程序难有很好的多核扩展性，因为这个队列的极限吞吐取决于同步cache的延时，而不是核心的个数。最好是用多个SPMC或多个MPSC队列，甚至多个SPSC队列代替，在源头就规避掉竞争。</p>\n</blockquote>\n<p><br></p>\n<blockquote>\n<p> 另一个例子是计数器，如果所有线程都频繁修改一个计数器，性能就会很差，原因同样在于不同的核心在不停地同步同一个cacheline。如果这个计数器只是用作打打日志之类的，那我们完全可以让每个线程修改thread-local变量，在需要时再合并所有线程中的值，性能可能有几十倍的差别</p>\n</blockquote>\n<p><br></p>\n<h2 id=\"缓存一致性\"><a href=\"#缓存一致性\" class=\"headerlink\" title=\"缓存一致性\"></a>缓存一致性</h2><p>之前感觉在JMM中理解过类似的。</p>\n<p><a href=\"https://kb.cnblogs.com/page/504824/\" target=\"_blank\" rel=\"noopener\">缓存一致性</a></p>\n<p>重点还是在多核心的pc中，每个核心都有自己的一级或者二级的缓存。</p>\n<p>然后如果一个核去修改主存中的值，如果其他的核没有收到信号，那么可能会导致并发问题。</p>\n<p>这个问题的解决就是缓存一致性，从文章里我们可以看到其实现代的cpu已经自带的缓存一致性。</p>\n<p>那么问题来了，那为什么volatile还要发明出来。</p>\n<p>cpu不直接和主存通信，那么修改了变量之后，什么时候把修改过得值写到主存中呢？</p>\n<p>一般有两种方式</p>\n<ul>\n<li>直写</li>\n</ul>\n<blockquote>\n<p>我们透过本级缓存，直接把数据写到下一级缓存（或直接到内存）中，如果对应的段被缓存了，我们同时更新缓存中的内容（甚至直接丢弃）</p>\n</blockquote>\n<ul>\n<li><p>回写</p>\n<blockquote>\n<p><strong>回写定律</strong>：当所有的脏段被回写后，任意级别缓存中的缓存段的内容，等同于它对应的内存中的内容。</p>\n<p>换句话说，回写模式的定律中，我们去掉了“在任意时刻”这个修饰语</p>\n</blockquote>\n</li>\n</ul>\n<p><br><br>如果都是直写，那么当然没什么问题，但是如果出现回写，数据写回不及时，在并发情况下就会出问题。</p>\n<p><br><br>那么<code>volatile</code>的增强写语义就很好理解了。</p>\n<p>那么增强的读语义呢？</p>\n<p>这个我还是觉得有点奇怪的</p>\n<p>首先读写主存是独占的，一个核写了之后，因为缓存一致性的存在，那么必然会导致其他核的缓存失效。</p>\n<p>那么这时候就只能去读主存中的值了。</p>\n<p>所以<code>volatile</code>的读语义其实并没有被<code>Jvm</code>增强，这是硬件所必然的结果。</p>\n<p>那么另外一个经典的<code>volatile</code>修饰<code>boolean</code>变量，如果不修饰，另外一个线程可能永远读不到修改后的值的问题。</p>\n<p>再仔细想想的话，真的是没读到吗，肯定是读到了，因为缓存一致性的存在，那么那个线程中的值肯定是修改之后的，但是为什么表现的还是没读到的样子呢，那是指令重排序的问题。</p>\n<p>所以<code>JSR133</code>增强了<code>volatile</code>，就是在指令重排序上。</p>\n<p><br><br></p>\n<h2 id=\"内存屏障\"><a href=\"#内存屏障\" class=\"headerlink\" title=\"内存屏障\"></a>内存屏障</h2><blockquote>\n<p><strong>重排指令</strong>导致了读写顺序的变化。只要没有依赖，代码中在后面的指令就可能跑到前面去</p>\n<p><a href=\"http://preshing.com/20120625/memory-ordering-at-compile-time/\" target=\"_blank\" rel=\"noopener\">编译器</a>和<a href=\"https://en.wikipedia.org/wiki/Out-of-order_execution\" target=\"_blank\" rel=\"noopener\">CPU</a>都会这么做。</p>\n<p>这么做的动机非常自然，CPU要尽量塞满每个cycle，在单位时间内运行尽量多的指令。</p>\n<p>如上节中提到的，访存指令在等待cacheline同步时要花费数百纳秒，最高效地自然是同时同步多个cacheline，而不是一个个做。</p>\n<p>一个线程在代码中对多个变量的依次修改，可能会以不同的次序同步到另一个线程所在的核心上。</p>\n<p>不同线程对数据的需求不同，按需同步也会导致cacheline的读序和写序不同。</p>\n</blockquote>\n<p>简单说就是为了结果指令重排序带来的并发问题。</p>\n<p><code>Java</code>内存模型中引入了<code>happens-before原则</code>和<code>volatile</code>来解决。</p>\n<p><br><br></p>\n<h2 id=\"wait-free-amp-lock-free\"><a href=\"#wait-free-amp-lock-free\" class=\"headerlink\" title=\"wait-free &amp; lock-free\"></a>wait-free &amp; lock-free</h2><blockquote>\n<p>原子指令能为我们的服务赋予两个重要属性：<a href=\"http://en.wikipedia.org/wiki/Non-blocking_algorithm#Wait-freedom\" target=\"_blank\" rel=\"noopener\">wait-free</a>和<a href=\"http://en.wikipedia.org/wiki/Non-blocking_algorithm#Lock-freedom\" target=\"_blank\" rel=\"noopener\">lock-free</a>。</p>\n<p>前者指不管OS如何调度线程，每个线程都始终在做有用的事；</p>\n<p>后者比前者弱一些，指不管OS如何调度线程，至少有一个线程在做有用的事。</p>\n</blockquote>\n<p><br></p>\n<blockquote>\n<p>如果我们的服务中使用了锁，那么OS可能把一个刚获得锁的线程切换出去，这时候所有依赖这个锁的线程都在等待，而没有做有用的事，所以用了锁就不是lock-free，更不会是wait-free。</p>\n<p>为了确保一件事情总在确定时间内完成，实时系统的关键代码至少是lock-free的。</p>\n</blockquote>\n<p><br></p>\n<blockquote>\n<p>在百度广泛又多样的在线服务中，对时效性也有着严苛的要求，如果RPC中最关键的部分满足wait-free或lock-free，就可以提供更稳定的服务质量。事实上，brpc中的读写都是wait-free的。</p>\n<p>值得提醒的是，常见想法是lock-free或wait-free的算法会更快，但事实可能相反，因为：</p>\n<p>lock-free和wait-free必须处理更多更复杂的race condition和ABA problem，完成相同目的的代码比用锁更复杂。代码越多，耗时就越长。<br>使用mutex的算法变相带“后退”效果。后退(backoff)指出现竞争时尝试另一个途径以临时避免竞争，mutex出现竞争时会使调用者睡眠，使拿到锁的那个线程可以很快地独占完成一系列流程，总体吞吐可能反而高了。</p>\n<p>mutex导致低性能往往是因为临界区过大（限制了并发度），或竞争过于激烈（上下文切换开销变得突出）。</p>\n<p>lock-free/wait-free算法的价值在于其保证了一个或所有线程始终在做有用的事，而不是绝对的高性能。</p>\n<p>但在一种情况下lock-free和wait-free算法的性能多半更高：就是算法本身可以用少量原子指令实现。实现锁也是要用原子指令的，当算法本身用一两条指令就能完成的时候，相比额外用锁肯定是更快了。</p>\n</blockquote>\n<p>就是说其实CAS如果使用不当，并不比同步加锁来的性能更高。</p>\n<p>但是<code>wait-free</code>则是很有必要的。</p>\n<h2 id=\"雪崩\"><a href=\"#雪崩\" class=\"headerlink\" title=\"雪崩\"></a>雪崩</h2><blockquote>\n<p>“雪崩”指的是访问服务集群时绝大部分请求都超时，且在流量减少时仍无法恢复的现象。</p>\n</blockquote>\n<p><br></p>\n<blockquote>\n<p>当流量超出服务的最大qps时，服务将无法正常服务；当流量恢复正常时（小于服务的处理能力），积压的请求会被处理，虽然其中很大一部分可能会因为处理的不及时而超时，但服务本身一般还是会恢复正常的。这就相当于一个水池有一个入水口和一个出水口，如果入水量大于出水量，水池子终将盛满，多出的水会溢出来。但如果入水量降到出水量之下，一段时间后水池总会排空。雪崩并不是单一服务能产生的。</p>\n</blockquote>\n<p><br></p>\n<blockquote>\n<p>如果一个请求经过两个服务，情况就有所不同了。比如请求访问A服务，A服务又访问了B服务。当B被打满时，A处的client会大量超时，如果A处的client在等待B返回时也阻塞了A的服务线程（常见），且使用了固定个数的线程池（常见），那么A处的最大qps就从<strong>线程数 / 平均延时</strong>，降到了<strong>线程数 / 超时</strong>。由于超时往往是平均延时的3~4倍，A处的最大qps会相应地下降3~4倍，从而产生比B处更激烈的拥塞。如果A还有类似的上游，拥塞会继续传递上去。但这个过程还是可恢复的。B处的流量终究由最前端的流量触发，只要最前端的流量回归正常，B处的流量总会慢慢降下来直到能正常回复大多数请求，从而让A恢复正常。</p>\n</blockquote>\n<p><br></p>\n<blockquote>\n<p>但有两个例外：</p>\n<ol>\n<li>A可能对B发起了过于频繁的基于超时的重试。这不仅会让A的最大qps降到<strong>线程数 / 超时</strong>，还会让B处的qps翻<strong>重试次数</strong>倍。这就可能陷入恶性循环了：只要<strong>线程数 / 超时 * 重试次数</strong>大于B的最大qps<strong>，</strong>B就无法恢复 -&gt; A处的client会继续超时 -&gt; A继续重试 -&gt; B继续无法恢复。</li>\n<li>A或B没有限制某个缓冲或队列的长度，或限制过于宽松。拥塞请求会大量地积压在那里，要恢复就得全部处理完，时间可能长得无法接受。由于有限长的缓冲或队列需要在填满时解决等待、唤醒等问题，有时为了简单，代码可能会假定缓冲或队列不会满，这就埋下了种子。即使队列是有限长的，恢复时间也可能很长，因为清空队列的过程是个追赶问题，排空的时间取决于<strong>积压的请求数 / (最大qps - 当前qps)</strong>，如果当前qps和最大qps差的不多，积压的请求又比较多，那排空时间就遥遥无期了。</li>\n</ol>\n</blockquote>\n<p>然后我们知道，处理雪崩问题，需要正确的处理超时重试和服务的等待队列问题。</p>\n<blockquote>\n<p>了解这些因素后可以更好的理解brpc中相关的设计。</p>\n<ol>\n<li>拥塞时A服务最大qps的跳变是因为线程个数是<strong>硬限</strong>，单个请求的处理时间很大程度上决定了最大qps。而brpc server端默认在bthread中处理请求，个数是软限，单个请求超时只是阻塞所在的bthread，并不会影响为新请求建立新的bthread。brpc也提供了完整的异步接口，让用户可以进一步提高io-bound服务的并发度，降低服务被打满的可能性。</li>\n<li>brpc中<a href=\"client.md#重试\">重试</a>默认只在连接出错时发起，避免了流量放大，这是比较有效率的重试方式。如果需要基于超时重试，可以设置<a href=\"client.md#重试\">backup request</a>，这类重试最多只有一次，放大程度降到了最低。brpc中的RPC超时是deadline，超过后RPC一定会结束，这让用户对服务的行为有更好的预判。在之前的一些实现中，RPC超时是单次超时*重试次数，在实践中容易误判。</li>\n<li>brpc server端的<a href=\"server.md#限制最大并发\">max_concurrency选项</a>控制了server的最大并发：当同时处理的请求数超过max_concurrency时，server会回复client错误，而不是继续积压。这一方面在服务开始的源头控制住了积压的请求数，尽量避免延生到用户缓冲或队列中，另一方面也让client尽快地去重试其他server，对集群来说是个更好的策略。</li>\n</ol>\n</blockquote>\n<p><br></p>\n<blockquote>\n<p>对于brpc的用户来说，要防止雪崩，主要注意两点：</p>\n<ol>\n<li>评估server的最大并发，设置合理的max_concurrency值。这个默认是不设的，也就是不限制。无论程序是同步还是异步，用户都可以通过 <strong>最大qps * 非拥塞时的延时</strong>（秒）来评估最大并发，原理见<a href=\"https://en.wikipedia.org/wiki/Little%27s_law\" target=\"_blank\" rel=\"noopener\">little’s law</a>，这两个量都可以在brpc中的内置服务中看到。max_concurrency与最大并发相等或大一些就行了。</li>\n<li>注意考察重试发生时的行为，特别是在定制RetryPolicy时。如果你只是用默认的brpc重试，一般是安全的。但用户程序也常会自己做重试，比如通过一个Channel访问失败后，去访问另外一个Channel，这种情况下要想清楚重试发生时最差情况下请求量会放大几倍，服务是否可承受。</li>\n</ol>\n</blockquote>\n<p><br><br></p>\n<h2 id=\"hash表\"><a href=\"#hash表\" class=\"headerlink\" title=\"hash表\"></a>hash表</h2><p>解决冲突的方法除了常见的开地址和线性探测及变种，还提供了其他的一些。</p>\n<blockquote>\n<p>混合开链和闭链：一般是把桶数组中的一部分拿出来作为容纳冲突元素的空间，典型如<a href=\"http://en.wikipedia.org/wiki/Coalesced_hashing\" target=\"_blank\" rel=\"noopener\">Coalesced hashing</a>，但这种结构没有解决开链的内存跳转问题，结构又比闭链复杂很多，工程效果并不好。</p>\n</blockquote>\n<p><br></p>\n<blockquote>\n<p>多次哈希：一般用多个哈希表代替一个哈希表，当发生冲突时（用另一个哈希值）尝试另一个哈希表。典型如<a href=\"http://en.wikipedia.org/wiki/Cuckoo_hashing\" target=\"_blank\" rel=\"noopener\">Cuckoo hashing</a>，这个结构也没有解决内存跳转。</p>\n</blockquote>\n<p><br><br></p>\n<h2 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h2><blockquote>\n<p>一般有三种操作IO的方式：</p>\n<ul>\n<li>blocking IO: 发起IO操作后阻塞当前线程直到IO结束，标准的同步IO，如默认行为的posix <a href=\"http://linux.die.net/man/2/read\" target=\"_blank\" rel=\"noopener\">read</a>和<a href=\"http://linux.die.net/man/2/write\" target=\"_blank\" rel=\"noopener\">write</a>。</li>\n<li>non-blocking IO: 发起IO操作后不阻塞，用户可阻塞等待多个IO操作同时结束。non-blocking也是一种同步IO：“批量的同步”。如linux下的<a href=\"http://linux.die.net/man/2/poll\" target=\"_blank\" rel=\"noopener\">poll</a>,<a href=\"http://linux.die.net/man/2/select\" target=\"_blank\" rel=\"noopener\">select</a>, <a href=\"http://linux.die.net/man/4/epoll\" target=\"_blank\" rel=\"noopener\">epoll</a>，BSD下的<a href=\"https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;sektion=2\" target=\"_blank\" rel=\"noopener\">kqueue</a>。</li>\n<li>asynchronous IO: 发起IO操作后不阻塞，用户得递一个回调待IO结束后被调用。如windows下的<a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/ms684342(v=vs.85\" target=\"_blank\" rel=\"noopener\">OVERLAPPED</a>.aspx) + <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/aa365198(v=vs.85\" target=\"_blank\" rel=\"noopener\">IOCP</a>.aspx)。linux的native AIO只对文件有效</li>\n</ul>\n</blockquote>\n<p>这个<em>批量的同步</em>真的用的厉害，佩服。</p>\n<blockquote>\n<p>linux一般使用non-blocking IO提高IO并发度。</p>\n<p>当IO并发度很低时，non-blocking IO不一定比blocking IO更高效，因为后者完全由内核负责，而read/write这类系统调用已高度优化，效率显然高于一般得多个线程协作的non-blocking IO。</p>\n<p>不过non-blocking IO也有自己的问题，</p>\n<p>它需要调用更多系统调用，比如<a href=\"http://man7.org/linux/man-pages/man2/epoll_ctl.2.html\" target=\"_blank\" rel=\"noopener\">epoll_ctl</a>，由于epoll实现为一棵红黑树，epoll_ctl并不是一个很快的操作，特别在多核环境下，依赖epoll_ctl的实现往往会面临棘手的扩展性问题。non-blocking需要更大的缓冲，否则就会触发更多的事件而影响效率。</p>\n<p>non-blocking还得解决不少多线程问题，代码比blocking复杂很多。</p>\n<p>IO线程的问题在于一个线程同时只能读一个fd，当多个繁忙的fd聚集在一个IO线程中时，一些读取就被延迟了。</p>\n<p>多租户、复杂分流算法，<a href=\"streaming_rpc.md\">Streaming RPC</a>等功能会加重这个问题。高负载下常见的某次读取卡顿会拖慢一个IO线程中所有fd的读取，对可用性的影响幅度较大。</p>\n</blockquote>\n<p><br><br></p>\n<h2 id=\"超时回调的设计。\"><a href=\"#超时回调的设计。\" class=\"headerlink\" title=\"超时回调的设计。\"></a>超时回调的设计。</h2><p>这个问题在设计http server的时候也遇到过。</p>\n<p>因为是事件驱动，一个连接一个fd，放进epoll中等事件发生。</p>\n<p>但是如果用户关闭连接我们自然就要把fd从epoll中拿出来丢掉，不然一直堆积在epoll中不好。</p>\n<p>那么问题来了，用户的关闭其实是封装在read事件中，这个还好解决，如果我们read不到数据大概就是关闭了。</p>\n<p>但是用户断电了，突然关闭了，那么是无感知的，也不会产生事件，那么这个fd其实是没用的，但是还是会存在我们的epoll中。</p>\n<p>这时候就需要引入超时。</p>\n<p>在libevent中提供了一个超时事件，可以传入一个callback，然后丢到事件管理器中。</p>\n<p>libevent是基于最小堆实现的，也就是说</p>\n<p>把所有的超时事件构造成一个堆，事件最短的放在最上面。</p>\n<p>当触发的时候，先一个一个检查，把已经过了时间的事件移出去。</p>\n<p>这样其实我们就知道这个超时是有延迟的，并不是到点就执行，但是延迟的时间应该不会太长。</p>\n<blockquote>\n<p>一般是以<a href=\"https://en.wikipedia.org/wiki/Heap_(data_structure\" target=\"_blank\" rel=\"noopener\">小顶堆</a>)记录触发时间。<a href=\"http://man7.org/linux/man-pages/man2/epoll_wait.2.html\" target=\"_blank\" rel=\"noopener\">epoll_wait</a>前以堆顶的时间计算出参数timeout的值，如果在该时间内没有其他事件，epoll_wait也会醒来，从堆中弹出已超时的元素，调用相应的回调函数。</p>\n</blockquote>\n<p>但是这是单线程的情况，在多线程中应该怎么设计呢。</p>\n<p>看brpc文档</p>\n<blockquote>\n<p>在多线程框架中，任何线程都可能被用户逻辑阻塞较长的时间，我们需要独立的线程实现timer，这种线程我们叫它TimerThread。一个非常自然的做法，就是使用用锁保护的小顶堆。当一个线程需要创建timer时，它先获得锁，然后把对应的时间插入堆，如果插入的元素成为了最早的，唤醒TimerThread。TimerThread中的逻辑和单线程类似，就是等着堆顶的元素超时，如果在等待过程中有更早的时间插入了，自己会被插入线程唤醒，而不会睡过头。这个方法的问题在于每个timer都需要竞争一把全局锁，操作一个全局小顶堆，就像在其他文章中反复谈到的那样，这会触发cache bouncing。同样数量的timer操作比单线程下的慢10倍是非常正常的，尴尬的是这些timer基本不触发。</p>\n</blockquote>\n<p><code>cache bouncing</code>好像和多线程自旋锁有关，暂时也没太看明白</p>\n<p><a href=\"https://www.quora.com/What-is-cache-line-bouncing-How-may-a-spinlock-trigger-this-frequently\" target=\"_blank\" rel=\"noopener\">cacheline bouncing</a></p>\n<blockquote>\n<p>一个惯例思路是把timer的需求散列到多个TimerThread，但这对TimerThread效果不好。注意我们上面提及到了那个“制约因素”：一旦插入的元素是最早的，要唤醒TimerThread。假设TimerThread足够多，以至于每个timer都散列到独立的TimerThread，那么每次它都要唤醒那个TimerThread。 “唤醒”意味着触发linux的调度函数，触发上下文切换。在非常流畅的系统中，这个开销大约是3-5微秒，这可比抢锁和同步cache还慢。这个因素是提高TimerThread扩展性的一个难点。多个TimerThread减少了对单个小顶堆的竞争压力，但同时也引入了更多唤醒。</p>\n<p>另一个难点是删除。一般用id指代一个Timer。通过这个id删除Timer有两种方式：1.抢锁，通过一个map查到对应timer在小顶堆中的位置，定点删除，这个map要和堆同步维护。2.通过id找到Timer的内存结构，做个标记，留待TimerThread自行发现和删除。第一种方法让插入逻辑更复杂了，删除也要抢锁，线程竞争更激烈。第二种方法在小顶堆内留了一大堆已删除的元素，让堆明显变大，插入和删除都变慢。</p>\n</blockquote>\n<p>这个，还有删除操作。。。</p>\n<p>这个之前真没考虑到，最小堆得删除的话，可能要另外一个数据结构去删除，然后可能只有遍历去找了。</p>\n<p>文档中说使用一个<code>HashMap</code>。但是维护起来成本太高了。</p>\n<blockquote>\n<p>第三个难点是TimerThread不应该经常醒。一个极端是TimerThread永远醒着或以较高频率醒过来（比如每1ms醒一次），这样插入timer的线程就不用负责唤醒了，然后我们把插入请求散列到多个堆降低竞争，问题看似解决了。但事实上这个方案提供的timer精度较差，一般高于2ms。</p>\n<p>你得想这个TimerThread怎么写逻辑，它是没法按堆顶元素的时间等待的，由于插入线程不唤醒，一旦有更早的元素插入，TimerThread就会睡过头。它唯一能做的是睡眠固定的时间，但这和现代OS scheduler的假设冲突：频繁sleep的线程的优先级最低。在linux下的结果就是，即使只sleep很短的时间，最终醒过来也可能超过2ms，因为在OS看来，这个线程不重要。一个高精度的TimerThread有唤醒机制，而不是定期醒。</p>\n</blockquote>\n<p>这个延迟的问题，我不是很有概念到底可接受的范围是多大。</p>\n<p>文档里说高于2ms就算是差的了。</p>\n<p>照这个频率的话，那么如果是高频率的醒来的话，那么间隔肯定在2ms内。。。</p>\n<p>那还不如一直醒着</p>\n<blockquote>\n<p>另外，更并发的数据结构也难以奏效，感兴趣的同学可以去搜索”concurrent priority queue”或”concurrent skip list”，这些数据结构一般假设插入的数值较为散开，所以可以同时修改结构内的不同部分。但这在RPC场景中也不成立，相互竞争的线程设定的时间往往聚集在同一个区域，因为程序的超时大都是一个值，加上当前时间后都差不多。</p>\n</blockquote>\n<p>这就是说，ConcurrentHashMap的效率其实也没有那么恐怖。</p>\n<blockquote>\n<p>那新TimerThread是如何做到的？</p>\n<ul>\n<li>一个TimerThread而不是多个。</li>\n<li>创建的timer散列到多个Bucket以降低线程间的竞争，默认12个Bucket。</li>\n<li>Bucket内不使用小顶堆管理时间，而是链表 + nearest_run_time字段，当插入的时间早于nearest_run_time时覆盖这个字段，之后去和全局nearest_run_time（和Bucket的nearest_run_time不同）比较，如果也早于这个时间，修改并唤醒TimerThread。链表节点在锁外使用<a href=\"memory_management.md\">ResourcePool</a>分配。</li>\n<li>删除时通过id直接定位到timer内存结构，修改一个标志，timer结构总是由TimerThread释放。</li>\n<li>TimerThread被唤醒后首先把全局nearest_run_time设置为几乎无限大(max of int64)，然后取出所有Bucket内的链表，并把Bucket的nearest_run_time设置为几乎无限大(max of int64)。TimerThread把未删除的timer插入小顶堆中维护，这个堆就它一个线程用。在每次运行回调或准备睡眠前都会检查全局nearest_run_time， 如果全局更早，说明有更早的时间加入了，重复这个过程。</li>\n</ul>\n</blockquote>\n<p>删除时直接通过id定位到timer内存结构，修改一个标志位。</p>\n<p>唤醒的过程还没看懂。。。</p>\n<p>还是c++强啊，这个在Java里就没法实现了。</p>\n<blockquote>\n<p>这个方法之所以有效：</p>\n<ul>\n<li>Bucket锁内的操作是O(1)的，就是插入一个链表节点，临界区很小。节点本身的内存分配是在锁外的。</li>\n<li>由于大部分插入的时间是递增的，早于Bucket::nearest_run_time而参与全局竞争的timer很少。</li>\n<li>参与全局竞争的timer也就是和全局nearest_run_time比一下，临界区很小。</li>\n<li>和Bucket内类似，极少数Timer会早于全局nearest_run_time并去唤醒TimerThread。唤醒也在全局锁外。</li>\n<li>删除不参与全局竞争。</li>\n<li>TimerThread自己维护小顶堆，没有任何cache bouncing，效率很高。 </li>\n<li>TimerThread醒来的频率大约是RPC超时的倒数，比如超时=100ms，TimerThread一秒内大约醒10次，已经最优。</li>\n</ul>\n</blockquote>\n<p>干货 !</p>\n<blockquote>\n<p>下面是一些和linux下时间管理相关的知识：</p>\n<ul>\n<li>epoll_wait的超时精度是毫秒，较差。pthread_cond_timedwait的超时使用timespec，精度到纳秒，一般是60微秒左右的延时。</li>\n<li>出于性能考虑，TimerThread使用wall-time，而不是单调时间，可能受到系统时间调整的影响。具体来说，如果在测试中把系统时间往前或往后调一个小时，程序行为将完全undefined。未来可能会让用户选择单调时间。</li>\n<li>在cpu支持nonstop_tsc和constant_tsc的机器上，brpc和bthread会优先使用基于rdtsc的cpuwide_time_us。那两个flag表示rdtsc可作为wall-time使用，不支持的机器上会转而使用较慢的内核时间。我们的机器（Intel Xeon系列）大都有那两个flag。rdtsc作为wall-time使用时是否会受到系统调整时间的影响，未测试不清楚。</li>\n</ul>\n</blockquote>\n<h2 id=\"常见线程模型\"><a href=\"#常见线程模型\" class=\"headerlink\" title=\"常见线程模型\"></a>常见线程模型</h2><blockquote>\n<h2 id=\"连接独占线程或进程\"><a href=\"#连接独占线程或进程\" class=\"headerlink\" title=\"连接独占线程或进程\"></a>连接独占线程或进程</h2><p>在这个模型中，线程/进程处理来自绑定连接的消息，在连接断开前不退也不做其他事情。当连接数逐渐增多时，线程/进程占用的资源和上下文切换成本会越来越大，性能很差，这就是<a href=\"http://en.wikipedia.org/wiki/C10k_problem\" target=\"_blank\" rel=\"noopener\">C10K问题</a>的来源。这种方法常见于早期的web server，现在很少使用。</p>\n</blockquote>\n<p>C10k问题还是挺经典的。</p>\n<blockquote>\n<h2 id=\"单线程reactor\"><a href=\"#单线程reactor\" class=\"headerlink\" title=\"单线程reactor\"></a>单线程<a href=\"http://en.wikipedia.org/wiki/Reactor_pattern\" target=\"_blank\" rel=\"noopener\">reactor</a></h2><p>以<a href=\"http://libevent.org/\" target=\"_blank\" rel=\"noopener\">libevent</a>, <a href=\"http://software.schmorp.de/pkg/libev.html\" target=\"_blank\" rel=\"noopener\">libev</a>等event-loop库为典型。这个模型一般由一个event dispatcher等待各类事件，待事件发生后<strong>原地</strong>调用对应的event handler，全部调用完后等待更多事件，故为”loop”。这个模型的实质是把多段逻辑按事件触发顺序交织在一个系统线程中。一个event-loop只能使用一个核，故此类程序要么是IO-bound，要么是每个handler有确定的较短的运行时间（比如http server)，否则一个耗时漫长的回调就会卡住整个程序，产生高延时。在实践中这类程序不适合多开发者参与，一个人写了阻塞代码可能就会拖慢其他代码的响应。由于event handler不会同时运行，不太会产生复杂的race condition，一些代码不需要锁。此类程序主要靠部署更多进程增加扩展性。</p>\n</blockquote>\n<p>主要问题不在IO上其实，因为这种模型无锁，不可控的问题在用户的代码中。</p>\n<p>多线程Reactor，比如Netty，其实也有这个问题。</p>\n<blockquote>\n<h2 id=\"N-1线程库\"><a href=\"#N-1线程库\" class=\"headerlink\" title=\"N:1线程库\"></a>N:1线程库</h2><p>又称为<a href=\"http://en.wikipedia.org/wiki/Fiber_(computer_science\" target=\"_blank\" rel=\"noopener\">Fiber</a>)，以<a href=\"http://www.gnu.org/software/pth/pth-manual.html\" target=\"_blank\" rel=\"noopener\">GNU Pth</a>, <a href=\"http://state-threads.sourceforge.net/index.html\" target=\"_blank\" rel=\"noopener\">StateThreads</a>等为典型，一般是把N个用户线程映射入一个系统线程。同时只运行一个用户线程，调用阻塞函数时才会切换至其他用户线程。N:1线程库与单线程reactor在能力上等价，但事件回调被替换为了上下文(栈,寄存器,signals)，运行回调变成了跳转至上下文。和event loop库一样，单个N:1线程库无法充分发挥多核性能，只适合一些特定的程序。只有一个系统线程对CPU cache较为友好，加上舍弃对signal mask的支持的话，用户线程间的上下文切换可以很快(100~200ns)。N:1线程库的性能一般和event loop库差不多，扩展性也主要靠多进程。</p>\n<h2 id=\"多线程reactor\"><a href=\"#多线程reactor\" class=\"headerlink\" title=\"多线程reactor\"></a>多线程reactor</h2><p>以<a href=\"http://www.boost.org/doc/libs/1_56_0/doc/html/boost_asio.html\" target=\"_blank\" rel=\"noopener\">boost::asio</a>为典型。一般由一个或多个线程分别运行event dispatcher，待事件发生后把event handler交给一个worker线程执行。 这个模型是单线程reactor的自然扩展，可以利用多核。由于共用地址空间使得线程间交互变得廉价，worker thread间一般会更及时地均衡负载，而多进程一般依赖更前端的服务来分割流量，一个设计良好的多线程reactor程序往往能比同一台机器上的多个单线程reactor进程更均匀地使用不同核心。不过由于<a href=\"atomic_instructions.md#cacheline\">cache一致性</a>的限制，多线程reactor并不能获得线性于核心数的性能，在特定的场景中，粗糙的多线程reactor实现跑在24核上甚至没有精致的单线程reactor实现跑在1个核上快。由于多线程reactor包含多个worker线程，单个event handler阻塞未必会延缓其他handler，所以event handler未必得非阻塞，除非所有的worker线程都被阻塞才会影响到整体进展。事实上，大部分RPC框架都使用了这个模型，且回调中常有阻塞部分，比如同步等待访问下游的RPC返回。</p>\n</blockquote>\n<p>那么netty有没有这个问题呢。。。。</p>\n<p>感觉考虑了好多关于缓存一致性的问题</p>\n<blockquote>\n<h2 id=\"M-N线程库\"><a href=\"#M-N线程库\" class=\"headerlink\" title=\"M:N线程库\"></a>M:N线程库</h2><p>即把M个用户线程映射入N个系统线程。M:N线程库可以决定一段代码何时开始在哪运行，并何时结束，相比多线程reactor在调度上具备更多的灵活度。但实现全功能的M:N线程库是困难的，它一直是个活跃的研究话题。我们这里说的M:N线程库特别针对编写网络服务，在这一前提下一些需求可以简化，比如没有时间片抢占，没有(完备的)优先级等。M:N线程库可以在用户态也可以在内核中实现，用户态的实现以新语言为主，比如GHC threads和goroutine，这些语言可以围绕线程库设计全新的关键字并拦截所有相关的API。而在现有语言中的实现往往得修改内核，比如<a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/dd627187(v=vs.85\" target=\"_blank\" rel=\"noopener\">Windows UMS</a>.aspx)和google SwicthTo(虽然是1:1，但基于它可以实现M:N的效果)。相比N:1线程库，M:N线程库在使用上更类似于系统线程，需要用锁或消息传递保证代码的线程安全。</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><h2 id=\"多核扩展性\"><a href=\"#多核扩展性\" class=\"headerlink\" title=\"多核扩展性\"></a>多核扩展性</h2><p>理论上代码都写成事件驱动型能最大化reactor模型的能力，但实际由于编码难度和可维护性，用户的使用方式大都是混合的：回调中往往会发起同步操作，阻塞住worker线程使其无法处理其他请求。一个请求往往要经过几十个服务，线程把大量时间花在了等待下游请求上，用户得开几百个线程以维持足够的吞吐，这造成了高强度的调度开销，并降低了TLS相关代码的效率。任务的分发大都是使用全局mutex + condition保护的队列，当所有线程都在争抢时，效率显然好不到哪去。更好的办法也许是使用更多的任务队列，并调整调度算法以减少全局竞争。比如每个系统线程有独立的runqueue，由一个或多个scheduler把用户线程分发到不同的runqueue，每个系统线程优先运行自己runqueue中的用户线程，然后再考虑其他线程的runqueue。这当然更复杂，但比全局mutex + condition有更好的扩展性。这种结构也更容易支持NUMA。</p>\n<p>当event dispatcher把任务递给worker线程时，用户逻辑很可能从一个核心跳到另一个核心，并等待相应的cacheline同步过来，并不很快。如果worker的逻辑能直接运行于event dispatcher所在的核心上就好了，因为大部分时候尽快运行worker的优先级高于获取新事件。类似的是收到response后最好在当前核心唤醒正在同步等待RPC的线程。</p>\n</blockquote>\n<p>回调中往往发起的是同步操作。</p>\n<p>非阻塞read也算吗？</p>\n<blockquote>\n<h2 id=\"异步编程\"><a href=\"#异步编程\" class=\"headerlink\" title=\"异步编程\"></a>异步编程</h2><p>异步编程中的流程控制对于专家也充满了陷阱。任何挂起操作，如sleep一会儿或等待某事完成，都意味着用户需要显式地保存状态，并在回调函数中恢复状态。异步代码往往得写成状态机的形式。当挂起较少时，这有点麻烦，但还是可把握的。问题在于一旦挂起发生在条件判断、循环、子函数中，写出这样的状态机并能被很多人理解和维护，几乎是不可能的，而这在分布式系统中又很常见，因为一个节点往往要与多个节点同时交互。另外如果唤醒可由多种事件触发（比如fd有数据或超时了），挂起和恢复的过程容易出现race condition，对多线程编码能力要求很高。语法糖(比如lambda)可以让编码不那么“麻烦”，但无法降低难度。</p>\n<p>共享指针在异步变成中很普遍，这看似方便，但也使内存的ownership变得难以捉摸，如果内存泄漏了，很难定位哪里没有释放；如果segment fault了，也不知道哪里多释放了一下。大量使用引用计数的用户代码很难控制代码质量，容易长期在内存问题上耗费时间。如果引用计数还需要手动维护，保持质量就更难了，维护者也不会愿意改进。没有上下文会使得<a href=\"http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization\" target=\"_blank\" rel=\"noopener\">RAII</a>无法充分发挥作用, 有时需要在callback之外lock，callback之内unlock，实践中很容易出错。</p>\n</blockquote>\n<p>讲了这么多线程模型，好像都有缺点。</p>\n<h2 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h2><blockquote>\n<p>最常见的分流算法是round robin和随机。这两个方法的前提是下游的机器和网络都是类似的，但在目前的线上环境下，特别是混部的产品线中，已经很难成立，因为：</p>\n<ul>\n<li>每台机器运行着不同的程序组合，并伴随着一些离线任务，机器的可用资源在持续动态地变化着。</li>\n<li>机器配置不同。</li>\n<li>网络延时不同。</li>\n</ul>\n</blockquote>\n<p>干货！</p>\n<blockquote>\n<p>这些问题其实一直有，但往往被OP辛勤的机器监控和替换给隐藏了。框架层面也有过一些努力，比如UB中的<a href=\"https://svn.baidu.com/public/trunk/ub/ub_client/ubclient_weightstrategy.h\" target=\"_blank\" rel=\"noopener\">WeightedStrategy</a>是根据下游的cpu占用率来进行分流，但明显地它解决不了延时相关的问题，甚至cpu的问题也解决不了：因为它被实现为定期reload一个权值列表，可想而知更新频率高不了，等到负载均衡反应过来，一大堆请求可能都超时了。并且这儿有个数学问题：怎么把cpu占用率转为权值。假设下游差异仅仅由同机运行的其他程序导致，机器配置和网络完全相同，两台机器权值之比是cpu idle之比吗？假如是的，当我们以这个比例给两台机器分流之后，它们的cpu idle应该会更接近对吧？而这会导致我们的分流比例也变得接近，从而使两台机器的cpu idle又出现差距。你注意到这个悖论了吗？这些因素使得这类算法的实际效果和那两个基本算法没什么差距，甚至更差，用者甚少。</p>\n<p>我们需要一个能自适应下游负载、规避慢节点的通用分流算法。</p>\n</blockquote>\n<p><code>Pigeon</code>也是进行了<code>weight</code></p>\n<p>但是问题也提出来了，就是更新频率高不了，导致会有一些超时问题只能，你懂得。。</p>\n","categories":["文档笔记"],"tags":["Network"]},{"title":"在ubunut16.04上搭建hadoop环境","url":"https://blog.lovezhy.cc/2018/04/01/在ubuntu16.04上搭建hadoop环境/","content":"<p>首先我们需要安装几个常用的软件</p>\n<a id=\"more\"></a>\n<p>这里的shell我选的是zsh，因为这个语法兼容bash</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 建立一个hadoop用户</span></span><br><span class=\"line\">useradd -d /home/zhuyichen -m -s /bin/zsh hadoop</span><br><span class=\"line\">&lt;!--more--&gt;  </span><br><span class=\"line\"><span class=\"comment\"># 安装git</span></span><br><span class=\"line\">apt install git -y</span><br><span class=\"line\"><span class=\"comment\"># 安装wget </span></span><br><span class=\"line\">apt install wget -y</span><br><span class=\"line\"><span class=\"comment\"># 安装htop</span></span><br><span class=\"line\">apt install htop -y</span><br><span class=\"line\"><span class=\"comment\"># 安装openjdk8</span></span><br><span class=\"line\">apt install openjdk-8-jdk -y</span><br><span class=\"line\">    </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 切换为hadoop用户</span></span><br><span class=\"line\">su</span><br><span class=\"line\"><span class=\"comment\"># 下载hadoop-2.9.1</span></span><br><span class=\"line\">wget http://www-us.apache.org/dist/hadoop/common/hadoop-2.9.1/hadoop-2.9.1.tar.gz</span><br><span class=\"line\"><span class=\"comment\"># 解压文件</span></span><br><span class=\"line\">tar -xvf hadoop-2.9.1.tar.gz</span><br><span class=\"line\">    </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 配置一下PATH环境变量，打开.zshrc后添加</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64</span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$PATH</span>:~hadoop/hadoop-2.9.1/bin</span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$PATH</span>:~hadoop/hadoop-2.9.1/sbin</span><br><span class=\"line\"><span class=\"built_in\">export</span> HADOOP_HOME=~hadoop/hadoop-2.9.1</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\"># hadoop-env.sh配置中还要单独配置一下JAVA_HOME</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">'export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64'</span> &gt;&gt; ~hadoop/hadoop-2.9.1/etc/hadoop/hadoop-env.sh</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\"># 配置ssh</span></span><br><span class=\"line\">ssh_keygen</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 把自己的key加到authorized_keys文件中</span></span><br><span class=\"line\">cat .ssh/id_rsa.pub &gt;&gt; .ssh/authorized_keys</span><br></pre></td></tr></table></figure>\n<p>下面开始分布式环境的配置<br>因为分布式需要多态机器<br>可以把上面这个克隆一下，这样就避免了很多的重复配置</p>\n<p>我现在有两台虚拟机<br>ip分别为<code>[ip:1]</code>和<code>[ip:2]</code><br>(<code>[ip:1]</code>和<code>[ip:2]</code>替换为真实ip，如192.168.168.3)</p>\n<p>把<code>[ip:1]</code>作为<code>master</code>，<code>[ip:2]</code>作为<code>slave1</code></p>\n<p>首先修改<code>/etc/hostname</code>文件<br><code>[ip:1]</code>的机器改为<code>master</code>, <code>[ip:2]</code>的机器改为<code>slave1</code></p>\n<p>再在<code>/etc/hosts</code>中添加ip映射<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ip:1] master</span><br><span class=\"line\">[ip:2] slave1</span><br></pre></td></tr></table></figure></p>\n<p>然后<code>master</code>的机器需要可以<code>ssh</code>进<code>slave</code>机器，所以还需要把<code>master</code>的<code>.ssh/id_rsa.pub</code>的内容加进<code>slave1</code>的<code>.ssh/authorized_keys</code>中。</p>\n<p>下面进行配置文件的修改</p>\n<p>在<code>hadoop</code>的<code>etc</code>的文件夹下配置一下文件<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- core-site.xml --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>hadoop.tmp.dir<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>file:/usr/local/hadoop/tmp<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>fs.defaultFS<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>hdfs://master:9000<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"comment\">&lt;!-- hdfs-site.xml --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.replication<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.namenode.name.dir<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>file:/usr/local/hadoop/data/namenode<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>dfs.datanode.data.dir<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>file:/usr/local/hadoop/data/datanode<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- mapred-site.xml --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>mapreduce.framework.name<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>yarn<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">&lt;!-- yarn-site.xml --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.resourcemanager.hostname<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>master<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>yarn.nodemanager.aux-services<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>mapreduce_shuffle<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>同时还需要建立<code>/usr/local/hadoop</code>目录</p>\n<p>如果机器是<code>master</code>的话，还需要手动指定<code>slaves</code><br>在<code>$HADOOP_HOME/etc/hadoop/slaves</code>文件中加上<code>slave1</code></p>\n<p>下面就可以启动了<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hdfs namenode -format</span><br><span class=\"line\">start-dfs.sh</span><br><span class=\"line\">start-yarn.sh</span><br></pre></td></tr></table></figure></p>\n<p>如果成功的话，<code>jps</code>命令在<code>master</code>上应该除了<code>jps</code>本身外还显示3个进程<br>分别为<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NameNode</span><br><span class=\"line\">SecondaryNameNode</span><br><span class=\"line\">ResourceManager</span><br></pre></td></tr></table></figure></p>\n<p>在slave上应该还额外显示2两进程<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DataNode</span><br><span class=\"line\">NodeManager</span><br></pre></td></tr></table></figure></p>\n<p>下面如果我们需要自己写一些<code>java</code>文件进行练手的话<br>我推荐的模式是利用<code>idea</code>的远程文件的功能在本地编辑，然后上传到服务器<br>运行一个脚本<br>这样的话我们就可以利用强大的idea写程序同时又可以在服务器很方便的跑了</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\">javac -classpath /home/hadoop/hadoop-2.9.1/etc/hadoop:/home/hadoop/hadoop-2.9.1/share/hadoop/common/lib/*:/home/hadoop/hadoop-2.9.1/share/hadoop/common/*:/home/hadoop/hadoop-2.9.1/share/hadoop/hdfs:/home/hadoop/hadoop-2.9.1/share/hadoop/hdfs/lib/*:/home/hadoop/hadoop-2.9.1/share/hadoop/hdfs/*:/home/hadoop/hadoop-2.9.1/share/hadoop/yarn:/home/hadoop/hadoop-2.9.1/share/hadoop/yarn/lib/*:/home/hadoop/hadoop-2.9.1/share/hadoop/yarn/*:/home/hadoop/hadoop-2.9.1/share/hadoop/mapreduce/lib/*:/home/hadoop/hadoop-2.9.1/share/hadoop/mapreduce/*:/home/hadoop/hadoop-2.9.1/contrib/capacity-scheduler/*.jar Main.java</span><br><span class=\"line\">jar cvf main.jar Main.class</span><br><span class=\"line\">hadoop jar main.jar Main $*</span><br></pre></td></tr></table></figure>\n<p>这样我们在idea本地编辑好<code>Main.java</code>文件，然后上传到服务器，在服务器执行<code>./start.sh</code>就可以执行了。</p>\n","categories":["技术却无分类"],"tags":["Hadoop"]},{"title":"Vim技巧","url":"https://blog.lovezhy.cc/2018/04/01/vim技巧/","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>其实我们不一定所有配置都要写在.vimrc里面的<br>偶尔在vim的命令行里执行一些小程序也是很方便的</p>\n<h3 id=\"改tab为space\"><a href=\"#改tab为space\" class=\"headerlink\" title=\"改tab为space\"></a>改tab为space</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:<span class=\"built_in\">set</span> expandtab</span><br><span class=\"line\">:%retab</span><br></pre></td></tr></table></figure>\n<h3 id=\"翻半页\"><a href=\"#翻半页\" class=\"headerlink\" title=\"翻半页\"></a>翻半页</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下半页</span></span><br><span class=\"line\">&lt;C<span class=\"_\">-d</span>&gt;</span><br><span class=\"line\"><span class=\"comment\"># 上半页</span></span><br><span class=\"line\">&lt;C-u&gt;</span><br></pre></td></tr></table></figure>\n","categories":["技术却无分类"],"tags":["Vim"]},{"title":"spi和破坏双亲委派","url":"https://blog.lovezhy.cc/2018/03/03/spi和破坏双亲委派/","content":"<h2 id=\"Java-SPI\"><a href=\"#Java-SPI\" class=\"headerlink\" title=\"Java SPI\"></a>Java SPI</h2><p>Java的spi约定是在源代码目录下的<code>META-INF/services</code>中，新建一个文件，文件名是接口的全限定名，内容是我们想要进行动态Loader的类的全限定名。</p>\n<a id=\"more\"></a>\n<p>比如我们有一个NameLog的接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> cc.lovezhy.spi;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">NameLog</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printName</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们设定了两个实现<code>FirstNameLog</code>和<code>SecondNameLog</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> cc.lovezhy.spi;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FirstNameLog</span> <span class=\"keyword\">implements</span> <span class=\"title\">NameLog</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"here is First\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> cc.lovezhy.spi;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecondNameLog</span> <span class=\"keyword\">implements</span> <span class=\"title\">NameLog</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"here is second\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在源码的目录下新建<code>META-INF/services</code>目录<br>再新建一个名字为<code>cc.lovezhy.spi.NameLog</code>的文件<br>在里面写上<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cc.lovezhy.spi.FirstNameLog</span><br></pre></td></tr></table></figure></p>\n<p>测试程序<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ServiceLoader&lt;NameLog&gt; services = ServiceLoader.load(NameLog.class);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (NameLog nameLog : services) &#123;</span><br><span class=\"line\">            nameLog.printName();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>结果：<br><code>here is First</code></p>\n<p>一样的，如果我们改成<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cc.lovezhy.spi.SecondNameLog</span><br></pre></td></tr></table></figure></p>\n<p>那么就是打印出<br><code>here is second</code></p>\n<p>我们也可以同时写上<br>就会两个都拿到<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">here is First</span><br><span class=\"line\">here is second</span><br></pre></td></tr></table></figure></p>\n<p>我一开始想的是运行时的实现，后来发现不是，运行时改了时候似乎并没有重新Load</p>\n<p>在最近看的pigeon的源代码中其实也看到了很多这样的用法。<br><img src=\"/images/spi.png\" alt=\"\"></p>\n<p>经典用法莫过于经常提到的<code>jdbc</code>驱动了，我们只要引入了数据库的jar包，就可以自动找到数据库驱动。</p>\n<h2 id=\"破坏双亲委派\"><a href=\"#破坏双亲委派\" class=\"headerlink\" title=\"破坏双亲委派\"></a>破坏双亲委派</h2><p>这也是意外在某个文章里看到的，之前看Java虚拟机书的时候也看到了，但是没太注意。</p>\n<h3 id=\"双亲委派\"><a href=\"#双亲委派\" class=\"headerlink\" title=\"双亲委派\"></a>双亲委派</h3><p>jvm的类加载机制，最经典的就是双亲委派机制。<br>jvm类加载器，系统中一般有三个</p>\n<ul>\n<li>BootstrapClassloader<br>这个是虚拟机层次的，对用户是不可见的，lang包中的类一般是由这个加载器加载。如果我们输出<code>String.class.getClassLoader()</code>会得到null。    </li>\n<li>ExtClassloader 一般是<code>JAVA_HOME/jre/lib/ext/</code>目录下的</li>\n<li>AppClassloader 一般我们自定义的类都是由这个加载器加载。</li>\n</ul>\n<p>JVM中类确认需要两个条件</p>\n<ul>\n<li>加载它的类加载器</li>\n<li>它的全路径名<br>也就是说，及时两个类类名一样，但是加载它们的类加载器不同，那么还是两个类。</li>\n</ul>\n<p>双亲委派就是一个加载器加载一个类的时候，会先让父类加载，如果父类加载不了，才自己加载。<br>这样就可以保证这个类在虚拟机中不被重复加载，还有唯一性。</p>\n<p>还有一个规则，如果一个类引用了另外一个类，那么这两个类的类加载器就必须是一样的。</p>\n<p>那么问题就来了，<code>BootStrapClassLoader</code>并不能认识我们的实现的第三方代码。那怎么办呢？</p>\n<p>如果我们看ClassLoader的类加载器，会发现它是null的，也就是它是由<code>BootstrapClassloader</code>加载的。<br>但是再去看我们那些实现类的类加载器，会发现它们是由<code>AppClassloader</code>加载的。</p>\n<p>这是怎么做到的呢，这里需要引入线程上下文加载器。<br>我们可以通过这样得到线程上下文类加载器。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException </span>&#123;</span><br><span class=\"line\">    Thread thread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    System.out.println(thread.getContextClassLoader());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出结果为<br><code>sun.misc.Launcher$AppClassLoader@6b482747</code></p>\n<p>由此可见，虽然<code>Thread</code>的类加载器为<code>BootstrapClassloader</code>加载的，但是它的上下文类加载器却是<code>AppClassLoader</code>。</p>\n<p>从<code>ServiceLoader</code>源码中也可以看到<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;S&gt; <span class=\"function\">ServiceLoader&lt;S&gt; <span class=\"title\">load</span><span class=\"params\">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class=\"line\">    ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ServiceLoader.load(service, cl);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;S&gt; <span class=\"function\">ServiceLoader&lt;S&gt; <span class=\"title\">load</span><span class=\"params\">(Class&lt;S&gt; service,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                            ClassLoader loader)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ServiceLoader&lt;&gt;(service, loader);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","categories":["Java基础"],"tags":["Java"]},{"title":"AQS和ReentrantLock","url":"https://blog.lovezhy.cc/2018/02/24/AQS和ReentrantLock/","content":"<h2 id=\"AQS子类\"><a href=\"#AQS子类\" class=\"headerlink\" title=\"AQS子类\"></a>AQS子类</h2><p>继承于AQS的子类。<br><img src=\"/images/AQS/AQS1.png\" alt=\"AQS\"></p>\n<a id=\"more\"></a>\n<h2 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h2><p>在ReentrantLock中的lock方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    sync.lock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>就是对Sync类的调用。</p>\n<h3 id=\"锁的获取\"><a href=\"#锁的获取\" class=\"headerlink\" title=\"锁的获取\"></a>锁的获取</h3><p>大体的思路，就是先尝试获取一个锁，如果失败，说明锁正在被人占着，这时候需要把当前线程放到一个容器里，然后挂起。<br>下面看看具体的实现是啥。</p>\n<p>如果是非公平锁<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        acquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在AQS类中有个state状态，用cas去改变他， 0代表空闲，1代表正在被占用。这个就相当于一个锁。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> state;</span><br></pre></td></tr></table></figure></p>\n<p>如果state=0的话，代表当前锁没有被任何线程锁起来。<br>所以首先尝试获取这个锁，如果成功了，那么把当前的独占线程设为当前线程。</p>\n<p>不然，调用acquire方法，加1。为什么加1呢，因为ReentantLock是可重入锁，同一个线程每一次获取都是加1，每一次释放就减1。下面我们会看到。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class=\"line\">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>acquire方法在AQS中。<br>但是tryAcquire是交给子类去实现的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nonfairTryAcquire(acquires);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为是非公平锁，所以调用nonfairTryAcquire。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">nonfairTryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">            setExclusiveOwnerThread(current);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">        setState(nextc);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在nonfairTryAcquire中，先再次尝试获取一下state。<br>如果失败，再判断下当前的独占线程是不是自己，如果是自己，就把acquire加上去。<br>这里就是可重入的逻辑。</p>\n<p>如果获取失败，而且当前独占线程也不是自己，那么返回false。<br>再返回到AQS中的acquire逻辑，if中第一个条件失败了，那么执行第二个条件acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，就是把当前线程丢到一个等待锁的容器中并挂起。</p>\n<p>Node的mode有下面这几种<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//独占</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Node EXCLUSIVE = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"comment\">//这个线程取消获取锁</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CANCELLED =  <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SIGNAL    = -<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">//这个线程在等待某个条件</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CONDITION = -<span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"comment\">//节点唤醒需要向下传播，和读写锁有关</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> PROPAGATE = -<span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure></p>\n<p>上面调用的是独占的EXCLUSIVE。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node tail;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">addWaiter</span><span class=\"params\">(Node mode)</span> </span>&#123;</span><br><span class=\"line\">    Node node = <span class=\"keyword\">new</span> Node(Thread.currentThread(), mode);</span><br><span class=\"line\">    <span class=\"comment\">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class=\"line\">    Node pred = tail;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pred != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        node.prev = pred;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class=\"line\">            pred.next = node;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    enq(node);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看到node应该可以猜到这个放等待线程的容器是链表。<br>先cas尝试一下把当前线程包装的node放到末尾。<br>如果失败进入enq()中。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">enq</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Node t = tail;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// Must initialize</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetHead(<span class=\"keyword\">new</span> Node()))</span><br><span class=\"line\">                tail = head;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            node.prev = t;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class=\"line\">                t.next = node;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>enq的逻辑就是不断自旋，cas加到末尾。其中也包含了head未初始化的情况。</p>\n<p>好，现在成功加到末尾，调用acquireQueued方法。在这里进行挂起之类的操作。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">acquireQueued</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node, <span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> interrupted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Node p = node.predecessor();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class=\"line\">                setHead(node);</span><br><span class=\"line\">                p.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> interrupted;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                parkAndCheckInterrupt())</span><br><span class=\"line\">                interrupted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>node.predecessor得到的是节点的prev节点。<br>这里假设当前节点前面有很多节点，那么第一个条件肯定不满足，进入到第二个if中。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">shouldParkAfterFailedAcquire</span><span class=\"params\">(Node pred, Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ws = pred.waitStatus;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws == Node.SIGNAL)</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * This node has already set status asking a release</span></span><br><span class=\"line\"><span class=\"comment\">         * to signal it, so it can safely park.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//表示前一个线程已经取消获取锁</span></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            node.prev = pred = pred.prev;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (pred.waitStatus &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">        pred.next = node;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果状态为0或者为PROPAGATE</span></span><br><span class=\"line\">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>判断前一个节点的waitStatus。<br>如果是SIGNAL，返回true<br>如果大于0，那就是cancelled了，那就跳过<br>不然就是cas把当前的pred的node的waitStatus设为SIGNAL</p>\n<p>如果成功<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">parkAndCheckInterrupt</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Thread.interrupted();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>那么parkAndCheckInterrupt就把当前线程挂起。</p>\n<h3 id=\"释放锁\"><a href=\"#释放锁\" class=\"headerlink\" title=\"释放锁\"></a>释放锁</h3><p>在unLock中<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    sync.release(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState() - releases;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> free = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        free = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        setExclusiveOwnerThread(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    setState(c);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> free;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">release</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryRelease(arg)) &#123;</span><br><span class=\"line\">        Node h = head;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h.waitStatus != <span class=\"number\">0</span>)</span><br><span class=\"line\">            unparkSuccessor(h);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>tryRelease方法，就是把state减掉，然后把当前的独占线程置空。<br>在回到release方法，那个unparkSuccessor调用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">unparkSuccessor</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class=\"line\"><span class=\"comment\">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class=\"line\"><span class=\"comment\">     * fails or if status is changed by waiting thread.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ws = node.waitStatus;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        compareAndSetWaitStatus(node, ws, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Thread to unpark is held in successor, which is normally</span></span><br><span class=\"line\"><span class=\"comment\">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class=\"line\"><span class=\"comment\">     * traverse backwards from tail to find the actual</span></span><br><span class=\"line\"><span class=\"comment\">     * non-cancelled successor.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Node s = node.next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.waitStatus &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        s = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Node t = tail; t != <span class=\"keyword\">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t.waitStatus &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                s = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        LockSupport.unpark(s.thread);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到这里就是唤醒了下一个node节点中的等待线程。</p>\n<p>那么ReentrantLock的公平和非公平体现在哪里呢。<br>我一开始以为的是head节点会唤醒所有的后缀节点，结果不是。<br>已经排队的节点还是按照排队顺序来唤醒。<br>不过在头节点唤醒时，可以有其他的线程来插队。<br>再回到lock方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        acquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在获取失败，加到队列的过程中，也尝试了两次插队，最后都失败了，才加入到队列中。</p>\n<p>另外，AQS的等待队列只是FIFO的，也就是说不支持优先权。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>AQS为独占和共享提供了基本的接口，需要我们自己去实现tryAcquire等方法。</p>\n<h3 id=\"获取锁\"><a href=\"#获取锁\" class=\"headerlink\" title=\"获取锁\"></a>获取锁</h3><p>正常来说，如果tryAcquire失败，那么AQS就会把当前线程包在Node中，加到等待队列中。<br>等待队列是一个FIFO的双向链表。<br>如果是独占的锁，那么就很简单，ReentrantLock就是借助一个int的变量表明被占用还是空闲。<br>如果是共享锁，这就要看具体的情况了，在CountDownLatch中，就是看当前的钥匙是不是0，如果不是0，说明还是有线程没有countdown，那就加到等待队列去。<br>在读写锁中，如果当前有读锁或者写锁，那就失败。</p>\n<h3 id=\"释放锁-1\"><a href=\"#释放锁-1\" class=\"headerlink\" title=\"释放锁\"></a>释放锁</h3><p>然后每次head节点在临界区执行完成，就会选择唤醒下一个节点。<br>如果是独占的，就唤醒下一个，如果是共享的，那么就唤醒下一波所有的要获取共享锁的线程。</p>\n","categories":["Java源码解读"],"tags":["Java"]},{"title":"LongAdder解析","url":"https://blog.lovezhy.cc/2018/02/23/LongAdder解析/","content":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LongAdder</span> <span class=\"keyword\">extends</span> <span class=\"title\">Striped64</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Striped64</span> <span class=\"keyword\">extends</span> <span class=\"title\">Number</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Cell[] cells;</span><br><span class=\"line\">    <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> base;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>主要思路就先cas那个base变量，如果<code>race condition</code>不严重的话，那么就成功返回。</p>\n<p>但是如果<code>race condition</code>比较严重，那么就新建很多的<code>cell</code>，在<code>cell</code>里增加<code>value</code>，这样就降低了很多的并发阻塞。</p>\n<p>最后汇总的时候，除了<code>base</code>，还需要把每个<code>cell</code>中的<code>value</code>也加上去。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">long</span> x)</span> </span>&#123;</span><br><span class=\"line\">    Cell[] as; <span class=\"keyword\">long</span> b, v; <span class=\"keyword\">int</span> m; Cell a;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((as = cells) != <span class=\"keyword\">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> uncontended = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (as == <span class=\"keyword\">null</span> || (m = as.length - <span class=\"number\">1</span>) &lt; <span class=\"number\">0</span> ||</span><br><span class=\"line\">            (a = as[getProbe() &amp; m]) == <span class=\"keyword\">null</span> ||</span><br><span class=\"line\">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class=\"line\">            longAccumulate(x, <span class=\"keyword\">null</span>, uncontended);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第一个if，表示如果cells还是为空，并且cas增加到base中失败，那么就进行第二个if中的操作。<br>第二个if中，如果as为空，或者as未完全初始化</p>\n<p>getProbe() &amp; m相当于一次hash找到对应的cell，如果cell为空，<br>或者cell不为空，但是cell自身的cas加值还是失败，那么最终会调用longAccumulate方法。</p>\n<p>longAccumulate方法在Striped64类中，其中我们由add中传入的参数是</p>\n<ul>\n<li>要增加的x</li>\n<li>null</li>\n<li>false</li>\n</ul>\n<p>下面的方法就是对引入的cell就行操作，包括增加，扩容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> cellsBusy;    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">longAccumulate</span><span class=\"params\">(<span class=\"keyword\">long</span> x, LongBinaryOperator fn,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              <span class=\"keyword\">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"comment\">//得到与线程相关的hashCode。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((h = getProbe()) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        ThreadLocalRandom.current(); <span class=\"comment\">// force initialization</span></span><br><span class=\"line\">        h = getProbe();</span><br><span class=\"line\">        wasUncontended = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> collide = <span class=\"keyword\">false</span>;                <span class=\"comment\">// True if last slot nonempty</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Cell[] as; Cell a; <span class=\"keyword\">int</span> n; <span class=\"keyword\">long</span> v;</span><br><span class=\"line\">        <span class=\"comment\">//如果cell已经不为null，完成初始化。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((as = cells) != <span class=\"keyword\">null</span> &amp;&amp; (n = as.length) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//找到与当前线程有关的cell，和HashMap有点像</span></span><br><span class=\"line\">            <span class=\"comment\">//如果当前cell为空，那么就进行初始化</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((a = as[(n - <span class=\"number\">1</span>) &amp; h]) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//cellsBusy相当于一个锁，用volatile修饰，== 0时表示可以对cells进行操作。</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cellsBusy == <span class=\"number\">0</span>) &#123;       <span class=\"comment\">// Try to attach new Cell</span></span><br><span class=\"line\">                    Cell r = <span class=\"keyword\">new</span> Cell(x);   <span class=\"comment\">// Optimistically create</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (cellsBusy == <span class=\"number\">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">boolean</span> created = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;               <span class=\"comment\">// Recheck under lock</span></span><br><span class=\"line\">                            Cell[] rs; <span class=\"keyword\">int</span> m, j;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> ((rs = cells) != <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">                                (m = rs.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">                                rs[j = (m - <span class=\"number\">1</span>) &amp; h] == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                rs[j] = r;</span><br><span class=\"line\">                                created = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                            cellsBusy = <span class=\"number\">0</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (created)</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;           <span class=\"comment\">// Slot is now non-empty</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                collide = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//检查是否发生了一次cas失败，如果是那就标为true，进行下一次循环</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!wasUncontended)       <span class=\"comment\">// CAS already known to fail</span></span><br><span class=\"line\">                wasUncontended = <span class=\"keyword\">true</span>;      <span class=\"comment\">// Continue after rehash</span></span><br><span class=\"line\">            <span class=\"comment\">//调用cell本身的cas</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a.cas(v = a.value, ((fn == <span class=\"keyword\">null</span>) ? v + x :</span><br><span class=\"line\">                                         fn.applyAsLong(v, x))))</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n &gt;= NCPU || cells != as)</span><br><span class=\"line\">                collide = <span class=\"keyword\">false</span>;            <span class=\"comment\">// At max size or stale</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!collide)</span><br><span class=\"line\">                collide = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"comment\">//对cells进行扩充</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cellsBusy == <span class=\"number\">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (cells == as) &#123;      <span class=\"comment\">// Expand table unless stale</span></span><br><span class=\"line\">                        Cell[] rs = <span class=\"keyword\">new</span> Cell[n &lt;&lt; <span class=\"number\">1</span>];</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)</span><br><span class=\"line\">                            rs[i] = as[i];</span><br><span class=\"line\">                        cells = rs;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    cellsBusy = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                collide = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;                   <span class=\"comment\">// Retry with expanded table</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            h = advanceProbe(h);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果cell还是为空，那么就进行自旋，如果得到锁，那么就进行初始化</span></span><br><span class=\"line\">        <span class=\"comment\">//初始化为2个的cell，finally释放自旋锁</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cellsBusy == <span class=\"number\">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> init = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;                           <span class=\"comment\">// Initialize table</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cells == as) &#123;</span><br><span class=\"line\">                    Cell[] rs = <span class=\"keyword\">new</span> Cell[<span class=\"number\">2</span>];</span><br><span class=\"line\">                    rs[h &amp; <span class=\"number\">1</span>] = <span class=\"keyword\">new</span> Cell(x);</span><br><span class=\"line\">                    cells = rs;</span><br><span class=\"line\">                    init = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                cellsBusy = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (init)</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//最后还是尝试加在base上，如果失败，那就再来一次for循环。</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (casBase(v = base, ((fn == <span class=\"keyword\">null</span>) ? v + x :</span><br><span class=\"line\">                                    fn.applyAsLong(v, x))))</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;                          <span class=\"comment\">// Fall back on using base</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这一段代码的for循环中可以分为三部分。</p>\n<p>第一个部分，如果cells已经完成初始化。</p>\n<ul>\n<li>如果cell还是空，那么就自旋，把新的cell插到cells中。</li>\n<li>如果已经发生了一次cas失败，那么就标为true，以便下一次cas</li>\n<li>如果cell不为空，那么调用cell的cas</li>\n<li>如果各种方法都试了，那么没办法了，尝试扩充cells</li>\n</ul>\n<p>第二个部分，因为cell还未完成初始化，那么就拿到自旋锁进行初始化。</p>\n<p>第三个部分，如果已经被别的线程在进行初始化，那么就再次尝试调用加在base上。<br>如果失败，那么就再来一次for循环。</p>\n<p>可以看到每次尝试失败，那么就调用代价更高的方法再进行尝试。<br>所有方法用尽了，那没办法，再重新试一次吧。</p>\n<p>可以看到LongAdder和AtomicLong比起来，都是cas的运用。<br>AtomicLong如果cas失败，那么就进行while循环进行cas。<br>但是LongAdder把cas的压力分散到很多个cell中，最后加的时候把每个cell中的value都加上去。<br>高并发效率上，肯定是LongAdder更高一点，但是LongAdder相应的也更费空间。</p>\n<p>另外，在ConcurrentHashMap中就是运用了LongAdder的思想。</p>\n<p>参考：<br><a href=\"https://coolshell.cn/articles/11454.html\" target=\"_blank\" rel=\"noopener\">https://coolshell.cn/articles/11454.html</a></p>\n","categories":["Java源码解读"],"tags":["Java"]},{"title":"Pigeon中的核心类和作用","url":"https://blog.lovezhy.cc/2018/02/18/pigeon中的核心类和作用/","content":"<h1 id=\"ServiceFactory\"><a href=\"#ServiceFactory\" class=\"headerlink\" title=\"ServiceFactory\"></a>ServiceFactory</h1><p>这个类的作用就是服务的注册发布和get的最外层接口</p>\n<p>内部有两个主要的类</p>\n<a id=\"more\"></a>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ServiceProxy serviceProxy = ServiceProxyLoader.getServiceProxy();</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> PublishPolicy publishPolicy = PublishPolicyLoader.getPublishPolicy();</span><br></pre></td></tr></table></figure>\n<p><code>ServiceProxy</code>用来获取<code>service</code>的，就是包一层<code>proxy</code>吧。</p>\n<p><code>PublishPolicy</code>简单说就是发布<code>service</code>的，但是内部还是借助于<code>ServicePublisher</code>进行操作的。</p>\n<h1 id=\"RegistryManager\"><a href=\"#RegistryManager\" class=\"headerlink\" title=\"RegistryManager\"></a>RegistryManager</h1><p>这个类的作用其实是为<code>ServicePublisher</code>的<code>addService</code>到<code>zookeeper</code>中和<code>unpublish</code>指定的<code>service</code>提供API支持的。</p>\n<p>更通俗点就是为<code>invoker</code>和<code>provider</code>提供了<code>zookeeper</code>的交流的。</p>\n<p>但是内部还是使用的<code>registry</code>类进行和<code>zookeeper</code>调用的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Registry</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//删除了好多，可以自己去看源码</span></span><br><span class=\"line\">    <span class=\"comment\">// for invoker</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isSupportNewProtocol</span><span class=\"params\">(String serviceAddress, String serviceName)</span> <span class=\"keyword\">throws</span> RegistryException</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// for provider</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setSupportNewProtocol</span><span class=\"params\">(String serviceAddress, String serviceName, <span class=\"keyword\">boolean</span> support)</span> <span class=\"keyword\">throws</span> RegistryException</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// for invoker/provider</span></span><br><span class=\"line\">    <span class=\"function\">RegistryConfig <span class=\"title\">getRegistryConfig</span><span class=\"params\">(String ip)</span> <span class=\"keyword\">throws</span> RegistryException</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"InvokerBootStrap\"><a href=\"#InvokerBootStrap\" class=\"headerlink\" title=\"InvokerBootStrap\"></a>InvokerBootStrap</h1><p>这个类看名字也知道是为了<code>invoker</code>提供方便的。</p>\n<p>看调用也是<code>AbstractServiceProxy</code>这个类调用的最多</p>\n<p>主要有两个方法，<code>startup</code>和<code>shutdown</code>，也没什么重要的成员变量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">startup</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isStartup) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (InvokerBootStrap.class) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!isStartup) &#123;</span><br><span class=\"line\">                ServiceInvocationRepository.getInstance().init();</span><br><span class=\"line\">                InvokerProcessHandlerFactory.init();</span><br><span class=\"line\">                SerializerFactory.init();</span><br><span class=\"line\">                LoadBalanceManager.init();</span><br><span class=\"line\">                RegionPolicyManager.INSTANCE.init();</span><br><span class=\"line\">                Monitor monitor = MonitorLoader.getMonitor();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (monitor != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    monitor.init();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                isStartup = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                logger.warn(<span class=\"string\">\"pigeon client[version:\"</span> + VersionUtils.VERSION + <span class=\"string\">\"] has been started\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中<code>ServiceInvocationRepository</code>的<code>init</code>方法主要是启动了一个<code>InvocationTimeoutListener</code>线程，看样子是用来检测调用超时问题。</p>\n<p>在<code>InvokerProcessHandlerFactory</code>的<code>init</code>方法中，就是在<code>service</code>的<code>proxy</code>中，加入了一条责任链。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">registerBizProcessFilter(<span class=\"keyword\">new</span> TraceFilter());</span><br><span class=\"line\">registerBizProcessFilter(<span class=\"keyword\">new</span> DegradationFilter());</span><br><span class=\"line\">registerBizProcessFilter(<span class=\"keyword\">new</span> ClusterInvokeFilter());</span><br><span class=\"line\">registerBizProcessFilter(<span class=\"keyword\">new</span> GatewayInvokeFilter());</span><br><span class=\"line\">registerBizProcessFilter(<span class=\"keyword\">new</span> ContextPrepareInvokeFilter());</span><br><span class=\"line\">registerBizProcessFilter(<span class=\"keyword\">new</span> SecurityFilter());</span><br><span class=\"line\">registerBizProcessFilter(<span class=\"keyword\">new</span> RemoteCallInvokeFilter());</span><br></pre></td></tr></table></figure>\n<p><code>SerializerFactory</code>见下</p>\n<p><code>LoadBalanceManager</code>的<code>init</code>方法，初始化了<code>pigeon</code>支持的四种负载均衡的算法。</p>\n<ul>\n<li><code>RandomLoadBalance</code></li>\n<li><code>AutoawareLoadBalance</code></li>\n<li><code>RoundRobinLoadBalance</code></li>\n<li><code>WeightedAutoawareLoadBalance</code></li>\n</ul>\n<p>在<code>RegionPolicyManager</code>的<code>init</code>方法中，就是对<code>Region</code>的选择算法进行了初始化。</p>\n<p>那个<code>monitor</code>的方法，我看好像还没写好。。。。</p>\n<h1 id=\"ProviderBootStrap\"><a href=\"#ProviderBootStrap\" class=\"headerlink\" title=\"ProviderBootStrap\"></a>ProviderBootStrap</h1><h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><p>包含了<code>SerializerFactory</code>和<code>ProviderProcessHandlerFactory</code>的初始化。</p>\n<p>同时对<code>jetty server</code>和<code>netty server</code>两个<code>server</code>进行了初始化和启动。</p>\n<p>同时启动了一个监听服务器的线程<code>ShutdownHookListener</code></p>\n<p>如果服务器关闭，那么就会调用一些类的关闭方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//从zookeeper上unpublish掉所有的服务</span></span><br><span class=\"line\">ServiceFactory.unpublishAllServices();</span><br><span class=\"line\">InvokerBootStrap.shutdown();</span><br><span class=\"line\">ProviderBootStrap.shutdown();</span><br></pre></td></tr></table></figure>\n<h2 id=\"关闭\"><a href=\"#关闭\" class=\"headerlink\" title=\"关闭\"></a>关闭</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Server server : serversMap.values()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (server != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"start to stop \"</span> + server);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                unregisterConsoleServer(server.getServerConfig());</span><br><span class=\"line\">                server.stop();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class=\"line\">                logger.info(server + <span class=\"string\">\" has been shutdown\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ProviderProcessHandlerFactory.destroy();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>把<code>server</code>从<code>zookeeper</code>上下掉，这个过程调用了<code>RegistryManager</code>的方法。</p>\n<p>然后调用了<code>ProviderProcessHandlerFactory</code>的<code>destroy</code>方法。</p>\n<h1 id=\"SerializerFactory\"><a href=\"#SerializerFactory\" class=\"headerlink\" title=\"SerializerFactory\"></a>SerializerFactory</h1><p>对框架支持的序列化方法进行了注册。</p>\n<p>内部维护了两个map</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ConcurrentHashMap&lt;String, Byte&gt; serializerTypes;</span><br><span class=\"line\">ConcurrentHashMap&lt;Byte, Serializer&gt; serializers</span><br></pre></td></tr></table></figure>\n<p>这个Serializer类有啥用呢，这个其实还值得我们去研究研究。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Serializer</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\">Object <span class=\"title\">deserializeRequest</span><span class=\"params\">(InputStream is)</span> <span class=\"keyword\">throws</span> SerializationException</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">serializeRequest</span><span class=\"params\">(OutputStream os, Object obj)</span> <span class=\"keyword\">throws</span> SerializationException</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\">Object <span class=\"title\">deserializeResponse</span><span class=\"params\">(InputStream is)</span> <span class=\"keyword\">throws</span> SerializationException</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">serializeResponse</span><span class=\"params\">(OutputStream os, Object obj)</span> <span class=\"keyword\">throws</span> SerializationException</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\">Object <span class=\"title\">proxyRequest</span><span class=\"params\">(InvokerConfig&lt;?&gt; invokerConfig)</span> <span class=\"keyword\">throws</span> SerializationException</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\">InvocationResponse <span class=\"title\">newResponse</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SerializationException</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\">InvocationRequest <span class=\"title\">newRequest</span><span class=\"params\">(InvokerContext invokerContext)</span> <span class=\"keyword\">throws</span> SerializationException</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Serializer</code>接口中有七个方法，都是和序列化有关，其中<code>proxyRequest</code>方法请看pigeon的服务注册与发布.</p>\n<p>我们进行方法调用，发送请求，获取调用结果。这中间的过程都是需要进行序列化的。</p>\n<p><code>pigeon</code>支持11种序列化方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> SerializerType &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    INTERNAL_THRIFT((<span class=\"keyword\">byte</span>) <span class=\"number\">1</span>, <span class=\"string\">\"internalThrift\"</span>),</span><br><span class=\"line\">  </span><br><span class=\"line\">    HESSIAN((<span class=\"keyword\">byte</span>) <span class=\"number\">2</span>, <span class=\"string\">\"hessian\"</span>),</span><br><span class=\"line\">  </span><br><span class=\"line\">    JAVA((<span class=\"keyword\">byte</span>) <span class=\"number\">3</span>, <span class=\"string\">\"java\"</span>),</span><br><span class=\"line\">  </span><br><span class=\"line\">    PROTO((<span class=\"keyword\">byte</span>) <span class=\"number\">5</span>, <span class=\"string\">\"proto\"</span>),</span><br><span class=\"line\">  </span><br><span class=\"line\">    HESSIAN1((<span class=\"keyword\">byte</span>) <span class=\"number\">6</span>, <span class=\"string\">\"hessian1\"</span>),</span><br><span class=\"line\">  </span><br><span class=\"line\">    JSON((<span class=\"keyword\">byte</span>) <span class=\"number\">7</span>, <span class=\"string\">\"json\"</span>),</span><br><span class=\"line\">  </span><br><span class=\"line\">    FST((<span class=\"keyword\">byte</span>) <span class=\"number\">8</span>, <span class=\"string\">\"fst\"</span>),</span><br><span class=\"line\">  </span><br><span class=\"line\">    PROTOBUF((<span class=\"keyword\">byte</span>) <span class=\"number\">9</span>, <span class=\"string\">\"protobuf\"</span>),</span><br><span class=\"line\">  </span><br><span class=\"line\">    THRIFT((<span class=\"keyword\">byte</span>) <span class=\"number\">10</span>, <span class=\"string\">\"thrift\"</span>),</span><br><span class=\"line\">  </span><br><span class=\"line\">    PROTOBUF3((<span class=\"keyword\">byte</span>) <span class=\"number\">11</span>, <span class=\"string\">\"protobuf3\"</span>);</span><br></pre></td></tr></table></figure>\n<p>同时有八个进行序列化操作的实体类。</p>\n<p><img src=\"/images/pigeon中的核心类和作用/1.png\" alt=\"\"></p>\n<h1 id=\"ProviderProcessHandlerFactory\"><a href=\"#ProviderProcessHandlerFactory\" class=\"headerlink\" title=\"ProviderProcessHandlerFactory\"></a>ProviderProcessHandlerFactory</h1><p>我们知道在<code>InvokerProcessHandlerFactory</code>中，给<code>invoke</code>的过程加上了一天责任链。</p>\n<p>那么这个的<code>init</code>方法就是给<code>Provide</code>的时候，也加上一条责任链。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">registerBizProcessFilter(<span class=\"keyword\">new</span> TraceFilter());</span><br><span class=\"line\"><span class=\"keyword\">if</span> (Constants.MONITOR_ENABLE) &#123;</span><br><span class=\"line\">    registerBizProcessFilter(<span class=\"keyword\">new</span> MonitorProcessFilter());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">registerBizProcessFilter(<span class=\"keyword\">new</span> WriteResponseProcessFilter());</span><br><span class=\"line\">registerBizProcessFilter(<span class=\"keyword\">new</span> ContextTransferProcessFilter());</span><br><span class=\"line\">registerBizProcessFilter(<span class=\"keyword\">new</span> ExceptionProcessFilter());</span><br><span class=\"line\">registerBizProcessFilter(<span class=\"keyword\">new</span> SecurityFilter());</span><br><span class=\"line\">registerBizProcessFilter(<span class=\"keyword\">new</span> GatewayProcessFilter());</span><br><span class=\"line\">registerBizProcessFilter(<span class=\"keyword\">new</span> BusinessProcessFilter());</span><br></pre></td></tr></table></figure>\n","categories":["Pigeon"],"tags":["pigeon"]},{"title":"Pigeon的服务注册与发现","url":"https://blog.lovezhy.cc/2018/02/18/pigeon的服务注册与发现/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><code>pigeon</code>是大众点评内部一直在使用的<code>rpc</code>框架，同时带有服务治理的功能。<br>组件是使用<code>zookeeper</code> + <code>netty</code> + <code>jetty</code>完成。<br>现在也已经开源</p>\n<a id=\"more\"></a>\n<p><a href=\"https://github.com/dianping/pigeon\" target=\"_blank\" rel=\"noopener\">pigeon</a></p>\n<p>但是开源似乎做的不用心，可能也是看<code>dubbo</code>很火热，<code>pigeon</code>没人用<br>而且<code>pigeon</code>和点评内部的一点闭源的框架联系紧密，所以用的人并不多(反正我是一个没看到)。</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><h3 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h3><h4 id=\"Server端\"><a href=\"#Server端\" class=\"headerlink\" title=\"Server端\"></a>Server端</h4><p><code>pigeon</code>是与<code>spring</code>进行了很重的耦合的，如果要使用<code>pigeon</code>，那么必须使用<code>spring</code>框架。</p>\n<p>如果要暴露我们的服务<br>比如创建一个简单的<code>UserService</code>接口和实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">getNameById</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getNameById</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"id + name\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于<code>pigeon</code>的服务注册和发现是依赖<code>zookeeper</code>的，我们还需要装载一个<code>zookeeper</code><br>在resources文件夹下创建<code>config</code>文件夹，在<code>config</code>文件夹下创建<code>pigeon.properties</code>文件<br>在其中写上zookeeper的ip和端口<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pigeon.registry.address=localhost:<span class=\"number\">2181</span></span><br></pre></td></tr></table></figure></p>\n<p>同时为了区分服务，需要给我们的服务起一个名字<br>在<code>sources</code>的<code>META-INF</code>文件夹的<code>app.properties</code>里写上<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pigeon.registry.address=localhost:<span class=\"number\">2181</span></span><br></pre></td></tr></table></figure></p>\n<p>如果使用<code>typical</code>的方法声明服务的话，我们创建一个<code>spring</code>的配置文件，假设就叫<code>spring.xml</code><br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userServiceImpl\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"cc.lovezhy.service.UserServiceImpl\"</span>/&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.dianping.pigeon.remoting.provider.config.spring.ServiceBean\"</span> <span class=\"attr\">init-method</span>=<span class=\"string\">\"init\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"services\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">map</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">entry</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">key</span>=<span class=\"string\">\"cc.lovezhy.service.UserService\"</span> <span class=\"attr\">value-ref</span>=<span class=\"string\">\"userServiceImpl\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">map</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>这时候，就可以直接用Main方法启动了<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        SpringContainer container = <span class=\"keyword\">new</span> SpringContainer(<span class=\"string\">\"classpath*:/META-INF/spring.xml\"</span>);</span><br><span class=\"line\">        container.start();</span><br><span class=\"line\">        System.in.read();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当然如果你想要部署到<code>tomcat</code>中也是可以的。</p>\n<p>同时默认在<code>localhost:4080/services</code>上我们可以看到当前我们暴露出去的服务<br>并且可以调用。</p>\n<p><img src=\"/images/pigeon的服务注册与发现/pigeon.png\" alt=\"4080/services\"></p>\n<h4 id=\"client端\"><a href=\"#client端\" class=\"headerlink\" title=\"client端\"></a>client端</h4><p><code>client</code>端只需要包含服务的接口就行了。<br>所以<code>service</code>端的代码编写都是分模块写的，一个模块专门提供<code>DTO</code>和<code>service</code>接口<br>打包成<code>maven</code>供其他人使用。<br>然后具体的实现我们再在另外一个模块里写。</p>\n<p><code>resources</code>和<code>META-INF</code>的内容和服务端一样的。<br>就是在<code>bean</code>的声明的时候，我们需要这样<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userService\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.dianping.pigeon.remoting.invoker.config.spring.ReferenceBean\"</span></span></span><br><span class=\"line\"><span class=\"tag\">          <span class=\"attr\">init-method</span>=<span class=\"string\">\"init\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"interfaceName\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"cc.lovezhy.service.UserService\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>然后我们就可以在<code>Main</code>方法中引用了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ApplicationContext applicationContext = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"classpath*:spring.xml\"</span>);</span><br><span class=\"line\">        UserService userService = applicationContext.getBean(UserService.class);</span><br><span class=\"line\">        System.out.println(userService.getNameById());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置客户端调用模式\"><a href=\"#配置客户端调用模式\" class=\"headerlink\" title=\"配置客户端调用模式\"></a>配置客户端调用模式</h2><p>在<code>pigeon</code>内部，客户端调用远程服务有4种模式</p>\n<ul>\n<li><code>sync</code>同步</li>\n<li><code>future</code>异步</li>\n<li><code>callback</code>也是异步，只是通过回调的方式来处理结果</li>\n<li><code>oneway</code>不需要回复</li>\n</ul>\n<p>例如<code>spring</code>编程方式下只需要配置<code>callType</code>属性：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"babyAccountService\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.dianping.pigeon.remoting.invoker.config.spring.ReferenceBean\"</span> <span class=\"attr\">init-method</span>=<span class=\"string\">\"init\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"interfaceName\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"com.dianping.babytech.casecenter.api.BabyAccountService\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"serialize\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"hessian\"</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"callType\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"sync\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"timeout\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"5000\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>官方文档解释的很清楚了所有的选项。<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"echoService\"</span> </span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">class</span>=<span class=\"string\">\"com.dianping.pigeon.remoting.invoker.config.spring.ReferenceBean\"</span> </span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">init-method</span>=<span class=\"string\">\"init\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 服务全局唯一的标识url，默认是服务接口类名，必须设置 --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"url\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"http://service.dianping.com/demoService/echoService_1.0.0\"</span> /&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- 接口名称，必须设置 --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"interfaceName\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"com.dianping.pigeon.demo.EchoService\"</span> /&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- 超时时间，毫秒，默认5000，建议自己设置 --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"timeout\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"2000\"</span> /&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- 序列化，hessian/fst/protostuff，默认hessian，可不设置--&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"serialize\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"hessian\"</span> /&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- 调用方式，sync/future/callback/oneway，默认sync，可不设置 --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"callType\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"sync\"</span> /&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- 失败策略，快速失败failfast/失败转移failover/失败忽略failsafe/并发取最快返回forking，默认failfast，可不设置 --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"cluster\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"failfast\"</span> /&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- 是否超时重试，默认false，可不设置 --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"timeoutRetry\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"false\"</span> /&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- 重试次数，默认1，可不设置 --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"retries\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"1\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"ReferenceBean的获取，init方法\"><a href=\"#ReferenceBean的获取，init方法\" class=\"headerlink\" title=\"ReferenceBean的获取，init方法\"></a>ReferenceBean的获取，init方法</h2><p>这个我也画了一个简单的图，不过省略了很多细节部分，在<code>InvokerBootStrap</code>部分和<code>Serializer.proxyRequest</code>部分省略了很多。</p>\n<p><img src=\"/images/pigeon的服务注册与发现/服务发现.svg\" alt=\"\"></p>\n<p>下面具体看代码。</p>\n<p>在我们声明<code>bean</code>的时候还带有一个<code>init-method</code>参数<br><code>init-method=&quot;init&quot;</code><br>意思是在这个<code>bean</code>创建的时候还会调用一下<code>ReferenceBean</code>的<code>init</code>方法。</p>\n<p>在<code>init</code>方法中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.objType = ClassUtils.loadClass(<span class=\"keyword\">this</span>.classLoader, <span class=\"keyword\">this</span>.interfaceName.trim());</span><br><span class=\"line\">    <span class=\"comment\">//这里直接就创建了，其实如果配置简单的话，很多的参数都是空的。</span></span><br><span class=\"line\">    InvokerConfig&lt;?&gt; invokerConfig = <span class=\"keyword\">new</span> InvokerConfig(<span class=\"keyword\">this</span>.objType, <span class=\"keyword\">this</span>.url, <span class=\"keyword\">this</span>.timeout, <span class=\"keyword\">this</span>.callType,</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.serialize, <span class=\"keyword\">this</span>.callback, <span class=\"keyword\">this</span>.group, <span class=\"keyword\">this</span>.writeBufferLimit, <span class=\"keyword\">this</span>.loadBalance, <span class=\"keyword\">this</span>.cluster,</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.retries, <span class=\"keyword\">this</span>.timeoutRetry, <span class=\"keyword\">this</span>.vip, <span class=\"keyword\">this</span>.version, <span class=\"keyword\">this</span>.protocol);</span><br><span class=\"line\">    invokerConfig.setClassLoader(classLoader);</span><br><span class=\"line\">    invokerConfig.setSecret(secret);</span><br><span class=\"line\">    invokerConfig.setRegionPolicy(regionPolicy);</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!CollectionUtils.isEmpty(methods)) &#123;</span><br><span class=\"line\">        Map&lt;String, InvokerMethodConfig&gt; methodMap = <span class=\"keyword\">new</span> HashMap&lt;String, InvokerMethodConfig&gt;();</span><br><span class=\"line\">        invokerConfig.setMethods(methodMap);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (InvokerMethodConfig method : methods) &#123;</span><br><span class=\"line\">            methodMap.put(method.getName(), method);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//降级配置检查</span></span><br><span class=\"line\">    checkMock(); </span><br><span class=\"line\">    invokerConfig.setMock(mock);</span><br><span class=\"line\">    checkRemoteAppkey();</span><br><span class=\"line\">    invokerConfig.setRemoteAppKey(remoteAppKey);</span><br><span class=\"line\">    <span class=\"comment\">//这里就得到了service的代理实例。</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.obj = ServiceFactory.getService(invokerConfig);</span><br><span class=\"line\">    configLoadBalance(invokerConfig);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InvokerConfig&lt;?&gt; invokerConfig = <span class=\"keyword\">new</span> InvokerConfig(<span class=\"keyword\">this</span>.objType, <span class=\"keyword\">this</span>.url, <span class=\"keyword\">this</span>.timeout, <span class=\"keyword\">this</span>.callType,</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.serialize, <span class=\"keyword\">this</span>.callback, <span class=\"keyword\">this</span>.suffix, <span class=\"keyword\">this</span>.writeBufferLimit, <span class=\"keyword\">this</span>.loadBalance, <span class=\"keyword\">this</span>.cluster,</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.retries, <span class=\"keyword\">this</span>.timeoutRetry, <span class=\"keyword\">this</span>.vip, <span class=\"keyword\">this</span>.version, <span class=\"keyword\">this</span>.protocol);</span><br></pre></td></tr></table></figure>\n<p><code>InvokerConfig</code>参数</p>\n<ul>\n<li><code>Class&lt;T&gt; serviceInterface</code>                     接口的Class类</li>\n<li><code>String url</code>                                  服务全局唯一的标识url，感觉有了<code>serviceInterface</code>就够了</li>\n<li><code>String version</code>                                 版本？ </li>\n<li><code>byte callMethod</code>                             就是call的方式，sync还是future之类，但是是byte类型的，1代表sync等</li>\n<li><code>String callType</code>                              callType就是callMethod的String</li>\n<li><code>byte serialize</code>                                 序列化方式，默认是hessian</li>\n<li><code>int timeout</code>                                 超时时间</li>\n<li><code>InvocationCallback callback</code>                 设置了callback模式才有</li>\n<li><code>String suffix</code>  </li>\n<li><code>String loadbalance</code>                             负载均衡的策略设置</li>\n<li><code>String routePolicy</code>                             路由的规则</li>\n<li><code>RoutePolicy routePolicyObj</code> </li>\n<li><code>boolean timeoutRetry</code></li>\n<li><code>String cluster</code>                             </li>\n<li><code>int retries</code>                                 失败了重试的次数</li>\n<li><code>String vip</code></li>\n<li><code>int maxRequests</code></li>\n<li><code>String protocol</code></li>\n<li><code>Map&lt;String, InvokerMethodConfig&gt; methods</code></li>\n<li><code>ClassLoader classLoader</code></li>\n<li><code>String secret</code></li>\n<li><code>String remoteAppKey</code></li>\n<li><code>Object mock</code></li>\n</ul>\n<p>上面还提到一个服务降级的问题，这个我们之后再说。</p>\n<p>从上面看到，得到的<code>service</code>是从<code>ServiceFactory</code>这个类直接得到的。</p>\n<p>在<code>getService</code>的时候直接<code>get</code>了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ServiceFactory这个类，主要就是管理service的加载，发布和获取的。</span></span><br><span class=\"line\"><span class=\"comment\">//它的很多方法，从名字就可以看出来，发布service，取消service，获得service，给service设置权重之类。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceFactory</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ServiceProxy serviceProxy = ServiceProxyLoader.getServiceProxy();</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> PublishPolicy publishPolicy = PublishPolicyLoader.getPublishPolicy();</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//这个类，从名字上就可以看到和Provider相关的，进行了一些东西的初始化</span></span><br><span class=\"line\">\t\t\tProviderBootStrap.init();</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">\t\t\tlogger.error(<span class=\"string\">\"error while initializing service factory:\"</span>, t);</span><br><span class=\"line\">\t\t\tSystem.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">getService</span><span class=\"params\">(InvokerConfig&lt;T&gt; invokerConfig)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> serviceProxy.getProxy(invokerConfig);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>默认的话是建一个<code>DefaultServiceProxy</code><br>它的调用是调用了父类的<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultServiceProxy</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractServiceProxy</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">getProxy</span><span class=\"params\">(InvokerConfig&lt;T&gt; invokerConfig)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.getProxy(invokerConfig);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在<code>AbstractServiceProxy</code>中<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这个其实是个缓存的map，看下面的get过程中有个加锁的过程</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Map&lt;InvokerConfig&lt;?&gt;, Object&gt; services = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;InvokerConfig&lt;?&gt;, Object&gt;();</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">getProxy</span><span class=\"params\">(InvokerConfig&lt;T&gt; invokerConfig)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...省略好多好多</span></span><br><span class=\"line\">    Object service = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    service = services.get(invokerConfig);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (service == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//这个锁，好像用的guava中一个东西，提供和String.intern相同的作用但是不会占用老年代空间？</span></span><br><span class=\"line\">        <span class=\"comment\">//有时间再研究研究</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (interner.intern(invokerConfig)) &#123;</span><br><span class=\"line\">            service = services.get(invokerConfig);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (service == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//参见另外一篇文章</span></span><br><span class=\"line\">                    InvokerBootStrap.startup();</span><br><span class=\"line\">  </span><br><span class=\"line\">                    <span class=\"comment\">//下面这句就调用AbstractSerializer中的proxyRequest动态生成一个代理类</span></span><br><span class=\"line\">                    service = SerializerFactory.getSerializer(invokerConfig.getSerialize()).proxyRequest(invokerConfig);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (StringUtils.isNotBlank(invokerConfig.getLoadbalance())) &#123;</span><br><span class=\"line\">                        LoadBalanceManager.register(invokerConfig.getUrl(), invokerConfig.getSuffix(), invokerConfig.getLoadbalance());</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(<span class=\"string\">\"error while trying to get service:\"</span> + invokerConfig, t);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//配置地域策略，默认的是autoSwitch</span></span><br><span class=\"line\">                    routePolicyManager.register(invokerConfig.getUrl(), invokerConfig.getSuffix(),</span><br><span class=\"line\">                    invokerConfig.getRoutePolicy());</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RouteException(<span class=\"string\">\"error while setup region route policy: \"</span> + invokerConfig, t);</span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">  </span><br><span class=\"line\">                <span class=\"comment\">// watch service config</span></span><br><span class=\"line\">               <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                   serviceConfigManager.register(invokerConfig.getUrl());</span><br><span class=\"line\">               &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                   <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConfigException(<span class=\"string\">\"error while trying to watch service config: \"</span> + invokerConfig, t);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">               <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                  ClientManager.getInstance().registerClients(invokerConfig);</span><br><span class=\"line\">               &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                   logger.warn(<span class=\"string\">\"error while trying to setup service client:\"</span> + invokerConfig, t);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               <span class=\"comment\">//加到Map缓存里</span></span><br><span class=\"line\">               services.put(invokerConfig, service);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) service;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在<code>InvokerBootStrap.startup()</code>中<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//有很多的init方法，说明都是和invoke相关的一些配件。</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//这是处理调用超时问题的，把一个InvocationTimeoutListener跑在一个线程中</span></span><br><span class=\"line\">ServiceInvocationRepository.getInstance().init();</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//初始化那个proxy的handle，下面会提到</span></span><br><span class=\"line\">InvokerProcessHandlerFactory.init();</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//序列化工厂的初始化，默认支持很多序列化方式</span></span><br><span class=\"line\">SerializerFactory.init();</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//负载均衡调度的初始化，默认支持四种</span></span><br><span class=\"line\">LoadBalanceManager.init();</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//Region策略，就是分地域的策略，如果是北京上海都有服务，那么调用哪一边的问题。</span></span><br><span class=\"line\">RegionPolicyManager.INSTANCE.init();</span><br><span class=\"line\">Monitor monitor = MonitorLoader.getMonitor();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (monitor != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\tmonitor.init();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">isStartup = <span class=\"keyword\">true</span>;</span><br></pre></td></tr></table></figure></p>\n<p>得到服务的唯一标志，如果不指定url的话，默认就是接口的全称。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ServiceFactory.getServiceUrl(invokerConfig);</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">String <span class=\"title\">getServiceUrl</span><span class=\"params\">(InvokerConfig&lt;T&gt; invokerConfig)</span> </span>&#123;</span><br><span class=\"line\">\tString url = invokerConfig.getServiceInterface().getCanonicalName();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> url;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>service代理对象<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//proxyRequest得到一个proxy的对象</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractSerializer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">proxyRequest</span><span class=\"params\">(InvokerConfig&lt;?&gt; invokerConfig)</span> <span class=\"keyword\">throws</span> SerializationException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//第一个参数是ClassLoader，第二个参数是interface的数组，第三个参数是Proxy类</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Proxy.newProxyInstance(ClassUtils.getCurrentClassLoader(invokerConfig.getClassLoader()),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Class[] &#123; invokerConfig.getServiceInterface() &#125;, <span class=\"keyword\">new</span> ServiceInvocationProxy(invokerConfig,</span><br><span class=\"line\">                InvokerProcessHandlerFactory.selectInvocationHandler(invokerConfig)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这里的handler是连接远程调用的桥梁</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceInvocationProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ServiceInvocationProxy</span><span class=\"params\">(InvokerConfig&lt;?&gt; invokerConfig, ServiceInvocationHandler handler)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.invokerConfig = invokerConfig;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handler = handler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        String methodName = method.getName();</span><br><span class=\"line\">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> method.invoke(handler, args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"string\">\"toString\"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> handler.toString();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"string\">\"hashCode\"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> handler.hashCode();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"string\">\"equals\"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> handler.equals(args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> extractResult(handler.handle(<span class=\"keyword\">new</span> DefaultInvokerContext(invokerConfig, methodName, parameterTypes, args)),</span><br><span class=\"line\">            method.getReturnType());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当我们调用其他的方法时，其实是在<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handler.handle(<span class=\"keyword\">new</span> DefaultInvokerContext(invokerConfig, methodName, parameterTypes, args)</span><br></pre></td></tr></table></figure></p>\n<p>这里面进行处理的。</p>\n<p>这里的handle是<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> ServiceInvocationHandler handler;</span><br></pre></td></tr></table></figure></p>\n<p>在<code>InvokerProcessHandlerFactory</code>中得到一个实例<br>//这里应该是最重要的部分了<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InvokerProcessHandlerFactory</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;InvocationInvokeFilter&gt; bizProcessFilters = <span class=\"keyword\">new</span> LinkedList&lt;InvocationInvokeFilter&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ServiceInvocationHandler bizInvocationHandler = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> isInitialized = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">//这里进行了一个责任链的处理，类似于netty的那种</span></span><br><span class=\"line\">    <span class=\"comment\">//在调用前进行日志，权限之类的分析。</span></span><br><span class=\"line\">    <span class=\"comment\">//最后的RemoteCallInvokeFilter才是真正调用我们想要的方法</span></span><br><span class=\"line\">    <span class=\"comment\">//初始化在之前就进行了，见上</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isInitialized) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Constants.MONITOR_ENABLE) &#123;</span><br><span class=\"line\">                registerBizProcessFilter(<span class=\"keyword\">new</span> RemoteCallMonitorInvokeFilter());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//trace 监控信息</span></span><br><span class=\"line\">            registerBizProcessFilter(<span class=\"keyword\">new</span> TraceFilter());</span><br><span class=\"line\">            <span class=\"comment\">//服务降级</span></span><br><span class=\"line\">            registerBizProcessFilter(<span class=\"keyword\">new</span> DegradationFilter());</span><br><span class=\"line\">  </span><br><span class=\"line\">            registerBizProcessFilter(<span class=\"keyword\">new</span> ClusterInvokeFilter());</span><br><span class=\"line\">            <span class=\"comment\">//网关，统计流量啥的</span></span><br><span class=\"line\">            registerBizProcessFilter(<span class=\"keyword\">new</span> GatewayInvokeFilter());</span><br><span class=\"line\">            registerBizProcessFilter(<span class=\"keyword\">new</span> ContextPrepareInvokeFilter());</span><br><span class=\"line\">            <span class=\"comment\">//安全验证</span></span><br><span class=\"line\">            registerBizProcessFilter(<span class=\"keyword\">new</span> SecurityFilter());</span><br><span class=\"line\">            <span class=\"comment\">//通过Netty调用</span></span><br><span class=\"line\">            registerBizProcessFilter(<span class=\"keyword\">new</span> RemoteCallInvokeFilter());</span><br><span class=\"line\">            bizInvocationHandler = createInvocationHandler(bizProcessFilters);</span><br><span class=\"line\">            isInitialized = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ServiceInvocationHandler <span class=\"title\">selectInvocationHandler</span><span class=\"params\">(InvokerConfig&lt;?&gt; invokerConfig)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bizInvocationHandler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(&#123; <span class=\"string\">\"rawtypes\"</span> &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> &lt;V extends ServiceInvocationFilter&gt; <span class=\"function\">ServiceInvocationHandler <span class=\"title\">createInvocationHandler</span><span class=\"params\">( List&lt;V&gt; internalFilters)</span> </span>&#123;</span><br><span class=\"line\">        ServiceInvocationHandler last = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        List&lt;V&gt; filterList = <span class=\"keyword\">new</span> ArrayList&lt;V&gt;();</span><br><span class=\"line\">        filterList.addAll(internalFilters);</span><br><span class=\"line\">        <span class=\"comment\">//创建一个调用链</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = filterList.size() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> V filter = filterList.get(i);</span><br><span class=\"line\">            <span class=\"keyword\">final</span> ServiceInvocationHandler next = last;</span><br><span class=\"line\">            last = <span class=\"keyword\">new</span> ServiceInvocationHandler() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> InvocationResponse <span class=\"title\">handle</span><span class=\"params\">(InvocationContext invocationContext)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">                    InvocationResponse resp = filter.invoke(next, invocationContext);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> resp;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">registerBizProcessFilter</span><span class=\"params\">(InvocationInvokeFilter filter)</span> </span>&#123;</span><br><span class=\"line\">        bizProcessFilters.add(filter);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在<code>RemoteCallInvokeFilter</code>中invoke方法中，<br>调用的是<code>InvokerUtils</code>的方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response = InvokerUtils.sendRequest(client, invocationContext.getRequest(), future);</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> InvocationResponse <span class=\"title\">sendRequest</span><span class=\"params\">(Client client, InvocationRequest request, Callback callback)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (request.getCallType() == Constants.CALLTYPE_REPLY) &#123;</span><br><span class=\"line\">        RemoteInvocationBean invocationBean = <span class=\"keyword\">new</span> RemoteInvocationBean();</span><br><span class=\"line\">        invocationBean.request = request;</span><br><span class=\"line\">        invocationBean.callback = callback;</span><br><span class=\"line\">        callback.setRequest(request);</span><br><span class=\"line\">        callback.setClient(client);</span><br><span class=\"line\">        invocationRepository.put(request.getSequence(), invocationBean);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    InvocationResponse response = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//发送的请求在这儿发送的</span></span><br><span class=\"line\">        response = client.write(request);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NetworkException e) &#123;</span><br><span class=\"line\">        invocationRepository.remove(request.getSequence());</span><br><span class=\"line\">        logger.warn(<span class=\"string\">\"network exception ocurred:\"</span> + request, e);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (response != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        invocationRepository.remove(request.getSequence());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>client</code>的实现有两种，一个是<code>Tcp</code>的还有一个是<code>Http</code>的，<code>pigeon</code>两种都支持。<br>好像一般的调用是调用的<code>tcp</code>的方案，然后在<code>4080/services</code>查看和调用的是<code>http</code>的协议。</p>\n<p><img src=\"/images/pigeon的服务注册与发现/Client.jpg\" alt=\"Client实现\"></p>\n<p>在<code>Netty</code>的实现中的<code>doWrite</code>方法，其实就是调用了<code>channel</code>的<code>write0</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> InvocationResponse <span class=\"title\">doWrite</span><span class=\"params\">(InvocationRequest request)</span> <span class=\"keyword\">throws</span> NetworkException </span>&#123;</span><br><span class=\"line\">    NettyChannel channel = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        channel = channelPool.selectChannel();</span><br><span class=\"line\">        ChannelFuture future = channel.write0(request);</span><br><span class=\"line\">        afterWrite(request, channel);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (request.getMessageType() == Constants.MESSAGE_TYPE_SERVICE</span><br><span class=\"line\">            || request.getMessageType() == Constants.MESSAGE_TYPE_HEART) &#123;</span><br><span class=\"line\">            future.addListener(<span class=\"keyword\">new</span> MessageWriteListener(request, channel));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NetworkException(<span class=\"string\">\"[doRequest] remote call failed:\"</span> + request, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>至此，代理<code>bean</code>的创建和<code>invoke</code>的流程大概就理清楚了。</p>\n<p>但是其实它是怎么和<code>zookeeper</code>沟通拿到<code>service</code>的呢。</p>\n<p>我猜想肯定是从那条责任链的某个地方中取得的，于是进行了一番苦苦查找。</p>\n<p>在<code>ClusterFactory</code>的<code>select</code>中，默认是返回<code>FailfastCluster</code>，在它的<code>invoke</code>方法中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Client remoteClient = clientManager.getClient(invokerConfig, request, <span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n<p>有这句话。</p>\n<p>这个<code>Client</code>默认是<code>NettyClient</code>。</p>\n<p>如果我们在仔细看一下<code>ClientManager</code>的构造函数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">ClientManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.providerAvailableListener = <span class=\"keyword\">new</span> ProviderAvailableListener();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.clusterListener = <span class=\"keyword\">new</span> DefaultClusterListener(providerAvailableListener);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.clusterListenerManager.addListener(<span class=\"keyword\">this</span>.clusterListener);</span><br><span class=\"line\">    providerAvailableThreadPool.execute(<span class=\"keyword\">this</span>.providerAvailableListener);</span><br><span class=\"line\">    RegistryEventListener.addListener(providerChangeListener);</span><br><span class=\"line\">    RegistryEventListener.addListener(registryConnectionListener);</span><br><span class=\"line\">    RegistryEventListener.addListener(groupChangeListener);</span><br><span class=\"line\">    registerThreadPool.getExecutor().allowCoreThreadTimeOut(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里其实启动了一个<code>ProviderAvailableListener</code>。</p>\n<p>这个类和<code>RegisterManager</code>关系密切，而<code>RegisterManager</code>则是掌管和<code>zookeeper</code>沟通的，由此不难看出，这里的<code>service</code>就是从这儿得到的。</p>\n<h3 id=\"服务端集群策略\"><a href=\"#服务端集群策略\" class=\"headerlink\" title=\"服务端集群策略\"></a>服务端集群策略</h3><p>在<code>ClusterInvokeFilter</code>中进行的配置</p>\n<ul>\n<li><code>failfast</code> - 调用服务的一个节点失败后抛出异常返回，可以同时配置重试timeoutRetry和retries属性  </li>\n<li><code>failover</code> - 调用服务的一个节点失败后会尝试调用另外的一个节点，可以同时配置重试  timeoutRetry和retries属性  </li>\n<li><code>failsafe</code> - 调用服务的一个节点失败后不会抛出异常，返回null，后续版本会考虑按配置默认值返回  </li>\n<li><code>forking</code> - 同时调用服务的所有可用节点，返回调用最快的节点结果数据。<br>可以通过配置forkingSize，指定最多调用的节点数（pigeon2.10.3及以上版本通过xml配置forkingSize，其余版本可以通过lion配置{appkey}.pigeon.invoker.forking.size）  </li>\n<li><code>hedged</code> - 发出第一个请求后，如果<code>hedgedDelay</code>时间内没有返回，会向其他节点发送第二个请求，返回最先返回的结果数据  </li>\n</ul>\n<h2 id=\"ServiceBean的注册\"><a href=\"#ServiceBean的注册\" class=\"headerlink\" title=\"ServiceBean的注册\"></a>ServiceBean的注册</h2><p><img src=\"/images/pigeon的服务注册与发现/服务注册.svg\" alt=\"\"><br>（画了我好久的图）<br>具体的流程和<code>ReferenceBean</code>的获取其实差不了太多。</p>\n","categories":["Pigeon"],"tags":["pigeon"]},{"title":"fat-jar配置","url":"https://blog.lovezhy.cc/2018/02/10/fat-jar/","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>maven打包的时候，默认只是把你的源文件打包起来<br>如果你的项目中还依赖了其他的项目，那是不打包进去的。</p>\n<p>这样我们在启动的时候，配置起来可能就会很麻烦。</p>\n<p>于是fat-jar的方式诞生了。<br><a id=\"more\"></a></p>\n<p>比如最熟悉的spring-boot项目，我们在package时候，在target目录的jar文件<br>我们可以直接java -jar 运行。不需要手动管理依赖。</p>\n<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><p>有好几个maven插件支持fat-jar的方式。<br>介绍一下spring-boot的插件。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>&#123;version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mainClass</span>&gt;</span>&#123;MainClass&#125;<span class=\"tag\">&lt;/<span class=\"name\">mainClass</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">layout</span>&gt;</span>JAR<span class=\"tag\">&lt;/<span class=\"name\">layout</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>repackage<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>同时，需要进行java-version的一些配置</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">java.version</span>&gt;</span>1.8<span class=\"tag\">&lt;/<span class=\"name\">java.version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.source</span>&gt;</span>1.8<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.source</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.target</span>&gt;</span>1.8<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.target</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h1><p>运行的话，可以直接运行或者打包好后运行<br><code>mvn spring-boot:run</code></p>\n<p><code>mvn package</code><br>在target目录会生成一个大的jar文件<br><code>java -jar XXXX.jar</code><br>就可以启动了</p>\n","categories":["技术却无分类"],"tags":["java"]},{"title":"log4j和slf4j配置","url":"https://blog.lovezhy.cc/2018/02/07/log4j和slf4j配置/","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>之前自己写的时候哪管什么log不log的，遇到啥都是直接sout。<br>后来在写自己的框架的时候，发现不行啊，我要做一个log出来，像<code>spring</code>启动那样。<br>来了美团，这里的log更加的严谨了，除了要运行的时候打印出log，还要把log分类分时间打到本地的文件里，</p>\n<p>当然这还不够，美团有个cat框架，还需要我们把log通过网络，打到专门管理log的服务器上去。</p>\n<p>大的系统log是很有必要的，这样出了问了log能给我们很大的启示。</p>\n<a id=\"more\"></a>\n<h1 id=\"Log框架\"><a href=\"#Log框架\" class=\"headerlink\" title=\"Log框架\"></a>Log框架</h1><p>Java的Log框架是比较乱的，之前一直没搞懂，不知道依赖关系。</p>\n<p>主要的有</p>\n<ul>\n<li><code>apache</code> 的<code>log4j</code></li>\n<li>升级版的<code>log4j2</code></li>\n<li><code>apache</code>的<code>common logging</code></li>\n<li><code>java.util.Logging</code></li>\n<li><code>slf4j</code></li>\n<li><code>LogBack</code></li>\n</ul>\n<p>不自己去了解一下其实是很乱的，光<code>apache</code>的log就有好几套。</p>\n<p>不过主流的还是<code>log4j</code>和<code>LogBack</code>，但是为了避免框架的Log和用户的Log不一样。<br>总不能一个系统里就有几套不同的Log吧。<br>于是<code>slf4j</code>出现了，这个框架，不提供实现，只提供接口。<br>幸运的是<code>Log4j</code>和<code>LogBack</code>都实现了这个框架的接口。<br>所以现在大多数还是直接调用<code>slf4j</code>的接口。实现的话，我们选一个去<code>import</code>一下就行。</p>\n<h1 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h1><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.slf4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>slf4j-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.7.25<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.logging.log4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>log4j-slf4j-impl<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.10.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>以<code>log4j</code>为例，首先我们得引入<code>slf4j</code>的规定的接口包，然后再引入<code>log4j</code>的实现包就行了。</p>\n<p>再加上log的配置文件。（见下）</p>\n<p>在代码中就直接写<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger log = LoggerFactory.getLogger(Main.class);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"dddddddd\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>就可以了。</p>\n<h1 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h1><p>log4j的配置文件其实也不难。<br>在<code>resources</code>目录下建立<code>log4j2.xml</code>文件。<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Configuration</span>&gt;</span></span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Properties</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">Property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"log-path\"</span>&gt;</span>/Users/zhuyichen/log/testLogs.txt<span class=\"tag\">&lt;/<span class=\"name\">Property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">Properties</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Appenders</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">Console</span> <span class=\"attr\">name</span>=<span class=\"string\">\"Console\"</span> <span class=\"attr\">target</span>=<span class=\"string\">\"SYSTEM_OUT\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">PatternLayout</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">Console</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">File</span> <span class=\"attr\">name</span>=<span class=\"string\">\"file\"</span> <span class=\"attr\">fileName</span>=<span class=\"string\">\"$&#123;log-path&#125;\"</span> <span class=\"attr\">append</span>=<span class=\"string\">\"false\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">PatternLayout</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">File</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">RollingFile</span> <span class=\"attr\">name</span>=<span class=\"string\">\"rollingFile\"</span> <span class=\"attr\">fileName</span>=<span class=\"string\">\"$&#123;log-path&#125;\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                     <span class=\"attr\">filePattern</span>=<span class=\"string\">\"$&#123;sys:user.home&#125;/log/$$&#123;date:yyyy-MM&#125;/info-%d&#123;yyyy-MM-dd&#125;-%i.log\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                     <span class=\"attr\">append</span>=<span class=\"string\">\"true\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">ThresholdFilter</span> <span class=\"attr\">level</span>=<span class=\"string\">\"info\"</span> <span class=\"attr\">onMatch</span>=<span class=\"string\">\"ACCEPT\"</span> <span class=\"attr\">onMismatch</span>=<span class=\"string\">\"DENY\"</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">PatternLayout</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n\"</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">Policies</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">TimeBasedTriggeringPolicy</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">SizeBasedTriggeringPolicy</span> <span class=\"attr\">size</span>=<span class=\"string\">\"100MB\"</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">Policies</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">DefaultRolloverStrategy</span> <span class=\"attr\">max</span>=<span class=\"string\">\"20\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">RollingFile</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">Appenders</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Loggers</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">Logger</span> <span class=\"attr\">name</span>=<span class=\"string\">\"Main\"</span> <span class=\"attr\">level</span>=<span class=\"string\">\"error, info\"</span> <span class=\"attr\">additivity</span>=<span class=\"string\">\"false\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">AppenderRef</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"Console\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">Logger</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">Root</span> <span class=\"attr\">level</span>=<span class=\"string\">\"all\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">AppenderRef</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"Console\"</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">AppenderRef</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"file\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">Root</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">Loggers</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Properties\"><a href=\"#Properties\" class=\"headerlink\" title=\"Properties\"></a>Properties</h2><p>首先<code>Properties</code>的条目是随便写的，只是方便我们下面引用的时候方便管理而已。<br>比如我们把我的log目录文件路径放进去了。<br>下面就可以用<code>${log-path}</code>来引用</p>\n<h2 id=\"Appenders\"><a href=\"#Appenders\" class=\"headerlink\" title=\"Appenders\"></a>Appenders</h2><p>下面就是<code>Appenders</code>，这里相当于我们设定几个log模式。</p>\n<p><code>Console</code>是<code>console</code>直接打印的模式。<br><code>PatternLayout</code>是打印出来的样式。</p>\n<p>File就是打印到文件的模式。</p>\n<ul>\n<li><code>name</code> 名字，由下面的Logger引用用</li>\n<li><code>fileName</code> Log文件的路径</li>\n<li><code>append</code> 每次启动，log是加到文件里，还是清空文件。</li>\n</ul>\n<p><code>RollingFile</code>就是轮转的<code>Log</code>，可以指定策略创建新的，删除旧的。<br>叫滚动日志</p>\n<ul>\n<li><code>name</code> <code>Appenders</code>的名字</li>\n<li><code>fileName</code>文件的名字</li>\n<li><code>filePattern</code>就是指定创建新的log文件的格式</li>\n<li><code>Policies</code> 指定滚动日志的策略<ul>\n<li><code>TimeBasedTriggeringPolicy</code> 基于时间的滚动策略</li>\n<li><code>SizeBasedTriggeringPolicy</code> 基于指定文件大小的滚动策略，size属性用来定义每个日志文件的大小</li>\n<li><code>DefaultRolloverStrategy</code> 用来指定同一个文件夹下最多有几个日志文件时开始删除最旧的</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Loggers\"><a href=\"#Loggers\" class=\"headerlink\" title=\"Loggers\"></a>Loggers</h2><p><code>Loggers</code>才是真正控制我们<code>Log</code>的地方。</p>\n<p>一般有两种节点，一个是<code>Logger</code>，一个是<code>Root</code>。</p>\n<p>level:日志输出级别，共有8个级别，按照从低到高为：<code>All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF</code>。</p>\n<p>按这个级别排序呢，就是说如果是all，那么大于等于它的级别的都会输出。</p>\n<p><code>Logger</code>一般单独指认某个类或者某个的输出日志。</p>\n<ul>\n<li><code>name</code> 指某个类所在全程或者某个包的全程</li>\n<li><code>level</code> 输出的日记级别</li>\n<li><code>additivity</code> 如果设为<code>false</code>，那么就不会在下面的<code>Root</code>节点再输出了。</li>\n</ul>\n<p><code>Root</code>是个特殊的条目，就是剩下来的所有<br>相比较<code>Logger</code>配置只有一个<code>level</code></p>\n<p>在每个配置中具体日志打到哪儿，需要引用我们上面定义的<code>Appender</code>了。<br>你需要这个Log打印到哪儿，就在里面增加一个<code>AppenderRef</code>条目。</p>\n<p>比如我的<code>Root</code>节点需要全部既打印到终端，又打印到文件，我就把两个都引用进去。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.cnblogs.com/hafiz/p/6170702.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/hafiz/p/6170702.html</a><br><a href=\"https://logging.apache.org/log4j/2.x/manual/index.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n","categories":["技术却无分类"],"tags":["Java"]},{"title":"ThreadLocal源码分析","url":"https://blog.lovezhy.cc/2017/12/21/ThreadLocal源码分析/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>ThreadLocal类的作用就是对于每个线程，保存一份类的实例。</p>\n<p>简单的说实现的话，就是存一个map，key就是当前的线程，value是该变量。<br>但是实际上的实现还是和我最初想的不一样，这个还要更复杂点。<br><a id=\"more\"></a></p>\n<h2 id=\"底层结构\"><a href=\"#底层结构\" class=\"headerlink\" title=\"底层结构\"></a>底层结构</h2><h3 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h3><p>ThreadLocal中有三个变量，其中只有一个是成员变量。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> threadLocalHashCode = nextHashCode();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//这个可以看做是ThreadLocal的hashcode()，但是是通过nextHashCode得到的。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> threadLocalHashCode = nextHashCode();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AtomicInteger nextHashCode =</span><br><span class=\"line\">        <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//这个是每次增加的数，为啥要设为这个奇怪的数呢，我百度了下</span></span><br><span class=\"line\">    <span class=\"comment\">//0x61c88647可以使 hashcode 均匀的分布在大小为 2 的 N 次方的数组里</span></span><br><span class=\"line\">    <span class=\"comment\">//叫做Fibonacci Hash，这是我们下面进行Entry分配的基础。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> HASH_INCREMENT = <span class=\"number\">0x61c88647</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">nextHashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ThreadLocalMap\"><a href=\"#ThreadLocalMap\" class=\"headerlink\" title=\"ThreadLocalMap\"></a>ThreadLocalMap</h3><p>每个Entry的key存的是ThreadLocal而并不是线程。</p>\n<p>和HashMap的分离链表法不同，ThreadLocalMap中处理冲突的方法是开放定址法。<br>不会产生链表，而是往下找。<br>这就要求我们散列分的比较均匀。这也是采用Fibonacci的原因。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这个Map的Entry继承了WeakReferenece，也就是弱引用。</span></span><br><span class=\"line\"><span class=\"comment\">//如果这个对象只被弱引用引用，那么它只能活到下一次gc前。</span></span><br><span class=\"line\"><span class=\"comment\">//这个把key作为一个弱引用，就是为了在我们ThreadLocal对象在不被使用后</span></span><br><span class=\"line\"><span class=\"comment\">//能被GC自动清除，避免内存泄漏</span></span><br><span class=\"line\"><span class=\"comment\">//当我们发现key == null的时候，就可以进行清理value的工作。</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadLocalMap</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">super</span>(k);</span><br><span class=\"line\">                value = v;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//初始的默认大小，参照HashMap的话，这里也必须是2的整数次方。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> INITIAL_CAPACITY = <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"comment\">//底层数组</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Entry[] table;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//下一次要扩展的容量大小。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> threshold;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//构造函数，key是ThreadLocal</span></span><br><span class=\"line\">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class=\"line\">            table = <span class=\"keyword\">new</span> Entry[INITIAL_CAPACITY];</span><br><span class=\"line\">            <span class=\"comment\">//这个可以看做是Hash函数。因为是通过的Fibonacci Hashing实现的。</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class=\"number\">1</span>);</span><br><span class=\"line\">            table[i] = <span class=\"keyword\">new</span> Entry(firstKey, firstValue);</span><br><span class=\"line\">            size = <span class=\"number\">1</span>;</span><br><span class=\"line\">            setThreshold(INITIAL_CAPACITY);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">   <span class=\"comment\">//其他的方法我们下面结合ThreadLocal方法看。</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中这个map的实例并不是放在ThreadLocal中，而是在Thread中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Thread</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    ThreadLocal.ThreadLocalMap threadLocals = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>虽然是在Thread类中，但是还是在ThreadLocal中进行操作的。<br>Thread类很少对这个类进行操作。</p>\n<h3 id=\"SuppliedThreadLocal\"><a href=\"#SuppliedThreadLocal\" class=\"headerlink\" title=\"SuppliedThreadLocal\"></a>SuppliedThreadLocal</h3><p>这个类的定义在ThreadLocal中，提供了ThreadLocal的初始值。<br>正常的我们ThreadLocal如果没有进行set就get的话会得到一个null。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SuppliedThreadLocal</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">ThreadLocal</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Supplier&lt;? extends T&gt; supplier;</span><br><span class=\"line\"></span><br><span class=\"line\">        SuppliedThreadLocal(Supplier&lt;? extends T&gt; supplier) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.supplier = Objects.requireNonNull(supplier);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> T <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> supplier.get();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这个类重写了initialValue方法，返回我们指定的初始值。<br>如果我们想得到这个类的实例，ThreadLocal提供了一个静态方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;S&gt; <span class=\"function\">ThreadLocal&lt;S&gt; <span class=\"title\">withInitial</span><span class=\"params\">(Supplier&lt;? extends S&gt; supplier)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SuppliedThreadLocal&lt;&gt;(supplier);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个是在1.8中新增的。</p>\n<h2 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createMap</span><span class=\"params\">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class=\"line\">        t.threadLocals = <span class=\"keyword\">new</span> ThreadLocalMap(<span class=\"keyword\">this</span>, firstValue);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>方法定义在ThreadLocal中，给线程t创建一个ThreadLocalMap，key为自己。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ThreadLocalMap <span class=\"title\">getMap</span><span class=\"params\">(Thread t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> t.threadLocals;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>返回线程t的ThreadLocalMap</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread t = Thread.currentThread();</span><br><span class=\"line\">        ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">                T result = (T)e.value;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> setInitialValue();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//ThreadLocalMap中的getEntry方法</span></span><br><span class=\"line\"><span class=\"comment\">//首先进行Hash找到entry，如果发现key和我们的不同，那就是发生了两种情况</span></span><br><span class=\"line\"><span class=\"comment\">//第一种是已经被GC清除了，或者产生了冲突，这时候我们调用getEntryAfterMiss方法。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Entry <span class=\"title\">getEntry</span><span class=\"params\">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">            Entry e = table[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span> &amp;&amp; e.get() == key)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> getEntryAfterMiss(key, i, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Entry <span class=\"title\">getEntryAfterMiss</span><span class=\"params\">(ThreadLocal&lt;?&gt; key, <span class=\"keyword\">int</span> i, Entry e)</span> </span>&#123;</span><br><span class=\"line\">            Entry[] tab = table;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (k == key)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">                <span class=\"comment\">//如果是被GC收集掉了，那么调用expungeStaleEntry方法把后面的重新Hash</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    expungeStaleEntry(i);</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    <span class=\"comment\">//不然就是继续找下一个桶。</span></span><br><span class=\"line\">                    i = nextIndex(i, len);</span><br><span class=\"line\">                e = tab[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">expungeStaleEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> staleSlot)</span> </span>&#123;</span><br><span class=\"line\">            Entry[] tab = table;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//做清除工作。</span></span><br><span class=\"line\">            tab[staleSlot].value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            tab[staleSlot] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            size--;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//将后面的Entry重新Hash</span></span><br><span class=\"line\">            Entry e;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i = nextIndex(staleSlot, len);</span><br><span class=\"line\">                 (e = tab[i]) != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                 i = nextIndex(i, len)) &#123;</span><br><span class=\"line\">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    e.value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    tab[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    size--;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> h = k.threadLocalHashCode &amp; (len - <span class=\"number\">1</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (h != i) &#123;</span><br><span class=\"line\">                        tab[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">while</span> (tab[h] != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                            h = nextIndex(h, len);</span><br><span class=\"line\">                        tab[h] = e;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>key为弱引用，避免内存泄漏</li>\n<li>采用开地址法，运用Fibonacci Hash是hashcode分配均匀。</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.cnblogs.com/zhangjk1993/archive/2017/03/29/6641745.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/zhangjk1993/archive/2017/03/29/6641745.html</a></p>\n","categories":["Java源码解读"],"tags":["Java"]},{"title":"ConcurrentHashMap源码分析","url":"https://blog.lovezhy.cc/2017/12/18/ConcurrentHashMap源码分析/","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p><code>ConcurrentHashMap</code>的源码长的让人惊叹。<br>我在<code>idea</code>打开的1.8版本达到了6000多行。</p>\n<a id=\"more\"></a>\n<p><code>ConcurrentHashMap</code>是多线程安全的<code>HashMap</code>，但是和<code>HashTable</code>的简单的加上同步的方法不同，他运用了很多高级复杂的方法来进行同步，很多都是避免的昂贵的锁操作。</p>\n<p>底层其实有很多和<code>HashMap</code>相同的地方，比如处理<code>Hash</code>冲突都是链表和红黑树。<br>树化和链表化的阈值都是一样的。</p>\n<p>简单的说有下面几个重点：</p>\n<ul>\n<li><code>Unsafe</code>的运用，就是<code>CAS</code>操作</li>\n<li>每个<code>bin</code>为一把锁</li>\n<li>红黑树的读写分离</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcurrentHashMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;  </span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">ConcurrentMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;, <span class=\"title\">Serializable</span></span></span><br></pre></td></tr></table></figure>\n<h1 id=\"ConcurrentMap\"><a href=\"#ConcurrentMap\" class=\"headerlink\" title=\"ConcurrentMap\"></a>ConcurrentMap</h1><p><code>ConcureentHashMap</code>实现了<code>ConcurrentMap</code>接口，这个接口的方法全部来自<code>Map</code>。<br>看起来只是一个标记作用，但是其实不是。<br>比如在<code>Map</code>中<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">default</span> V <span class=\"title\">putIfAbsent</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    V v = get(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (v == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        v = put(key, value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>putIfAbsent</code>方法被设为<code>default</code>，只要<code>implements</code>了这个接口就自动获得这个方法。<br>但是在<code>ConcurrentMap</code>中，<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">V <span class=\"title\">putIfAbsent</span><span class=\"params\">(K key, V value)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>去掉了<code>default</code>，这样在<code>ConcurrentHashMap</code>就必须自己实现了。<br><code>ConcurrentHashMap</code>的实现都是原子的。</p>\n<h1 id=\"阈值参数\"><a href=\"#阈值参数\" class=\"headerlink\" title=\"阈值参数\"></a>阈值参数</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//数组的最大长度，就是桶的数量，下面简称bin了</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//如果我们没有指定初始的bin的大小，默认是16，2的4次方</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CAPACITY = <span class=\"number\">16</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//和toArray及相关的方法有关，最大的Array大小</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class=\"number\">8</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//和之前的版本的分段锁有关，这个我们最后再谈，这个保留这个只是为了保持兼容性</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class=\"number\">16</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//默认的负载因子，当桶被填了超过百分之75时，会resize，增加桶的数量</span></span><br><span class=\"line\"><span class=\"comment\">//换句话说，当空的bin少于百分之25时，会增加bin的数量</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> LOAD_FACTOR = <span class=\"number\">0.75f</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//当bin中链表的数量超过8时，会变成红黑树</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TREEIFY_THRESHOLD = <span class=\"number\">8</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//当树中节点少于6时，会变成链表。</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> UNTREEIFY_THRESHOLD = <span class=\"number\">6</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//进行树化的另一个条件，就是需要bin的数量达到64</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MIN_TREEIFY_CAPACITY = <span class=\"number\">64</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MIN_TRANSFER_STRIDE = <span class=\"number\">16</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> RESIZE_STAMP_BITS = <span class=\"number\">16</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//help resize的最大线程数</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_RESIZERS = (<span class=\"number\">1</span> &lt;&lt; (<span class=\"number\">32</span> - RESIZE_STAMP_BITS)) - <span class=\"number\">1</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> RESIZE_STAMP_SHIFT = <span class=\"number\">32</span> - RESIZE_STAMP_BITS;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//在扩容时的状态</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MOVED     = -<span class=\"number\">1</span>; </span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TREEBIN   = -<span class=\"number\">2</span>; </span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> RESERVED  = -<span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Node类\"><a href=\"#Node类\" class=\"headerlink\" title=\"Node类\"></a>Node类</h1><h2 id=\"链表Node\"><a href=\"#链表Node\" class=\"headerlink\" title=\"链表Node\"></a>链表Node</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//为了简化删了一些，重点是这个类的setValue方法，是不支持的。</span></span><br><span class=\"line\"><span class=\"comment\">//这个是链表节点的类，而树节点的类在下面。</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> V val;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> Node&lt;K,V&gt; next;</span><br><span class=\"line\">  </span><br><span class=\"line\">    Node(<span class=\"keyword\">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hash = hash;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.val = val;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span>   </span>&#123; <span class=\"keyword\">return</span> key.hashCode() ^ val.hashCode(); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123; <span class=\"keyword\">return</span> key + <span class=\"string\">\"=\"</span> + val; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">setValue</span><span class=\"params\">(V value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\">Node&lt;K,V&gt; <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> h, Object k)</span> </span>&#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                K ek;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == h &amp;&amp;</span><br><span class=\"line\">                    ((ek = e.key) == k || (ek != <span class=\"keyword\">null</span> &amp;&amp; k.equals(ek))))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"红黑树节点\"><a href=\"#红黑树节点\" class=\"headerlink\" title=\"红黑树节点\"></a>红黑树节点</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这个是红黑树的节点类，继承了Node类。</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; parent;  <span class=\"comment\">// red-black tree links</span></span><br><span class=\"line\">    TreeNode&lt;K,V&gt; left;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; right;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; prev;    <span class=\"comment\">// needed to unlink next upon deletion</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> red;</span><br><span class=\"line\">  </span><br><span class=\"line\">    TreeNode(<span class=\"keyword\">int</span> hash, K key, V val, Node&lt;K,V&gt; next,</span><br><span class=\"line\">             TreeNode&lt;K,V&gt; parent) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(hash, key, val, next);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.parent = parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\">Node&lt;K,V&gt; <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> h, Object k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> findTreeNode(h, k, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns the TreeNode (or null if not found) for the given key</span></span><br><span class=\"line\"><span class=\"comment\">     * starting at given root.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> TreeNode&lt;K,V&gt; <span class=\"title\">findTreeNode</span><span class=\"params\">(<span class=\"keyword\">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"红黑树Bin\"><a href=\"#红黑树Bin\" class=\"headerlink\" title=\"红黑树Bin\"></a>红黑树Bin</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这个是红黑树的一个抽象。也是继承了Node类，</span></span><br><span class=\"line\"><span class=\"comment\">//所以在进行一些操作的时候需要用instanceof进行一些判断。</span></span><br><span class=\"line\"><span class=\"comment\">//我们一开始说ConcurrentHashMap和之前的分段锁不同，</span></span><br><span class=\"line\"><span class=\"comment\">//他每个bin都是一把锁，所以在TreeBin中有一些lock函数</span></span><br><span class=\"line\"><span class=\"comment\">//这个类还自带读写锁属性，因为ConcurrentHashMap的读是没有给头Node进行同步</span></span><br><span class=\"line\"><span class=\"comment\">//而是直接调用的红黑树的查找方法</span></span><br><span class=\"line\"><span class=\"comment\">//如果是链表的话，不加锁，但是如果是红黑树的话，会加上读锁</span></span><br><span class=\"line\"><span class=\"comment\">//线程得到写锁的时候必须先等读锁释放。</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeBin</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; root;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> Thread waiter;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> lockState;</span><br><span class=\"line\">    <span class=\"comment\">// values for lockState</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> WRITER = <span class=\"number\">1</span>; <span class=\"comment\">// set while holding write lock</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> WAITER = <span class=\"number\">2</span>; <span class=\"comment\">// set when waiting for write lock</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> READER = <span class=\"number\">4</span>; <span class=\"comment\">// increment value for setting read lock</span></span><br><span class=\"line\">    <span class=\"comment\">//TreeBin的put，get，remove基本操作。就是红黑树的操作。</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ForwardingNode\"><a href=\"#ForwardingNode\" class=\"headerlink\" title=\"ForwardingNode\"></a>ForwardingNode</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这是一个特殊的Node，当table正在transfer的时候，会被切到原table的bin的头结点去</span></span><br><span class=\"line\"><span class=\"comment\">//用于连接原table和nextTable</span></span><br><span class=\"line\"><span class=\"comment\">//它包含了nextTable，hash值为-1，其他的都是null。</span></span><br><span class=\"line\"><span class=\"comment\">//在并发transfer的时候，如果发现这个节点是ForwardingNode，那就说明这个节点的转移已经完成了。</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ForwardingNode</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class=\"line\">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(MOVED, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.nextTable = tab;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Node&lt;K,V&gt; <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> h, Object k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// loop to avoid arbitrarily deep recursion on forwarding nodes</span></span><br><span class=\"line\">        outer: <span class=\"keyword\">for</span> (Node&lt;K,V&gt;[] tab = nextTable;;) &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; e; <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span> || tab == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span> ||</span><br><span class=\"line\">                (e = tabAt(tab, (n - <span class=\"number\">1</span>) &amp; h)) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> eh; K ek;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((eh = e.hash) == h &amp;&amp;</span><br><span class=\"line\">                    ((ek = e.key) == k || (ek != <span class=\"keyword\">null</span> &amp;&amp; k.equals(ek))))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (eh &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> ForwardingNode) &#123;</span><br><span class=\"line\">                        tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span> outer;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                        <span class=\"keyword\">return</span> e.find(h, k);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = e.next) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"重要的成员变量\"><a href=\"#重要的成员变量\" class=\"headerlink\" title=\"重要的成员变量\"></a>重要的成员变量</h1><hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//cpu的个数</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//bin数组，在第一次插入操作进行初始化</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//扩容时的数组</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//当前键值对总个数</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> baseCount;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//这个比较重要，是控制标识符，源码中叫Table initialization and resizing control</span></span><br><span class=\"line\"><span class=\"comment\">//就是进行初始化和扩容的控制。</span></span><br><span class=\"line\"><span class=\"comment\">//当是负数时，table正在初始化或者扩容</span></span><br><span class=\"line\"><span class=\"comment\">//-1代表正在初始化 ,-N 表示有N-1个线程正在进行扩容操作</span></span><br><span class=\"line\"><span class=\"comment\">//当table是null时，如果这个值大于0，那就是tablede初始化大小，如果等于0，那就使用默认大小</span></span><br><span class=\"line\"><span class=\"comment\">//当table不是null时，等于下一次resize时node需要达到的数量，就是容量乘以负载因子。</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> sizeCtl;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> transferIndex;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//自旋锁</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> cellsBusy;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//这个与size有关</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> CounterCell[] counterCells;</span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//下面这三个和迭代有关</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> KeySetView&lt;K,V&gt; keySet;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> ValuesView&lt;K,V&gt; values;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> EntrySetView&lt;K,V&gt; entrySet;</span><br></pre></td></tr></table></figure>\n<h1 id=\"unsafe\"><a href=\"#unsafe\" class=\"headerlink\" title=\"unsafe\"></a>unsafe</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Unsafe mechanics</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> sun.misc.Unsafe U;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> SIZECTL;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> TRANSFERINDEX;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> BASECOUNT;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> CELLSBUSY;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> CELLVALUE;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ABASE;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> ASHIFT;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        U = sun.misc.Unsafe.getUnsafe();</span><br><span class=\"line\">        Class&lt;?&gt; k = ConcurrentHashMap.class;</span><br><span class=\"line\">        SIZECTL = U.objectFieldOffset</span><br><span class=\"line\">            (k.getDeclaredField(<span class=\"string\">\"sizeCtl\"</span>));</span><br><span class=\"line\">        TRANSFERINDEX = U.objectFieldOffset</span><br><span class=\"line\">            (k.getDeclaredField(<span class=\"string\">\"transferIndex\"</span>));</span><br><span class=\"line\">        BASECOUNT = U.objectFieldOffset</span><br><span class=\"line\">            (k.getDeclaredField(<span class=\"string\">\"baseCount\"</span>));</span><br><span class=\"line\">        CELLSBUSY = U.objectFieldOffset</span><br><span class=\"line\">            (k.getDeclaredField(<span class=\"string\">\"cellsBusy\"</span>));</span><br><span class=\"line\">        Class&lt;?&gt; ck = CounterCell.class;</span><br><span class=\"line\">        CELLVALUE = U.objectFieldOffset</span><br><span class=\"line\">            (ck.getDeclaredField(<span class=\"string\">\"value\"</span>));</span><br><span class=\"line\">        Class&lt;?&gt; ak = Node[].class;</span><br><span class=\"line\">        <span class=\"comment\">//可以获取数组第一个元素的偏移地址</span></span><br><span class=\"line\">        ABASE = U.arrayBaseOffset(ak);</span><br><span class=\"line\">        <span class=\"comment\">//arrayIndexScale可以获取数组的转换因子，也就是数组中元素的增量地址</span></span><br><span class=\"line\">        <span class=\"comment\">//将arrayBaseOffset与arrayIndexScale配合使用，可以定位数组中每个元素在内存中的位置。</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> scale = U.arrayIndexScale(ak);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((scale &amp; (scale - <span class=\"number\">1</span>)) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"data type scale not a power of two\"</span>);</span><br><span class=\"line\">        ASHIFT = <span class=\"number\">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"辅助方法\"><a href=\"#辅助方法\" class=\"headerlink\" title=\"辅助方法\"></a>辅助方法</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//让hash值分布的更均匀，让原本的hash值前16位和后16位取异或在和HASH_BITS取与。</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> HASH_BITS = <span class=\"number\">0x7fffffff</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">spread</span><span class=\"params\">(<span class=\"keyword\">int</span> h)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (h ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>)) &amp; HASH_BITS;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//找到与c最接近的2的整数次方的那个数，用的方法很巧妙。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = c - <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//得到tab第i个位置的Node，用了unsafe，很玄幻的操作。</span></span><br><span class=\"line\"><span class=\"comment\">//为什么不直接用tab[i]返回呢</span></span><br><span class=\"line\"><span class=\"comment\">//因为在java内存模型中，我们已经知道每个线程都有一个工作内存，里面存储着table的副本</span></span><br><span class=\"line\"><span class=\"comment\">//虽然table是volatile修饰的，但不能保证线程每次都拿到table中的最新元素</span></span><br><span class=\"line\"><span class=\"comment\">//Unsafe.getObjectVolatile可以直接获取指定内存的数据，保证了每次拿到数据都是最新的。</span></span><br><span class=\"line\"><span class=\"comment\">//来自参考的第一篇文章。</span></span><br><span class=\"line\"><span class=\"comment\">//这里的ABASE指的是一个元素的长度</span></span><br><span class=\"line\"><span class=\"comment\">//i &lt;&lt; ASHIFT计算的是第i个元素和第一个的偏移</span></span><br><span class=\"line\"></span><br><span class=\"line\">Class&lt;?&gt; ak = Node[].class;</span><br><span class=\"line\">ABASE = U.arrayBaseOffset(ak);</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> &lt;K,V&gt; <span class=\"function\">Node&lt;K,V&gt; <span class=\"title\">tabAt</span><span class=\"params\">(Node&lt;K,V&gt;[] tab, <span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class=\"keyword\">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//原理同上。</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> &lt;K,V&gt; <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">casTabAt</span><span class=\"params\">(Node&lt;K,V&gt;[] tab, <span class=\"keyword\">int</span> i,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> U.compareAndSwapObject(tab, ((<span class=\"keyword\">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"树化操作\"><a href=\"#树化操作\" class=\"headerlink\" title=\"树化操作\"></a>树化操作</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将index位置的tab树化</span></span><br><span class=\"line\"><span class=\"comment\">//但是如果table小于64，而直接扩容</span></span><br><span class=\"line\"><span class=\"comment\">//运用了同步，所以在多线程中是安全的。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">treeifyBin</span><span class=\"params\">(Node&lt;K,V&gt;[] tab, <span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; b; <span class=\"keyword\">int</span> n, sc;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果table的长度小于64，则不转树，而进行扩容到两倍</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class=\"line\">            tryPresize(n &lt;&lt; <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">//不然就进行转树操作。</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((b = tabAt(tab, index)) != <span class=\"keyword\">null</span> &amp;&amp; b.hash &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (b) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class=\"line\">                    TreeNode&lt;K,V&gt; hd = <span class=\"keyword\">null</span>, tl = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (Node&lt;K,V&gt; e = b; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</span><br><span class=\"line\">                        TreeNode&lt;K,V&gt; p =</span><br><span class=\"line\">                            <span class=\"keyword\">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class=\"line\">                                              <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((p.prev = tl) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                            hd = p;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span></span><br><span class=\"line\">                            tl.next = p;</span><br><span class=\"line\">                        tl = p;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    setTabAt(tab, index, <span class=\"keyword\">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"树退化为链表\"><a href=\"#树退化为链表\" class=\"headerlink\" title=\"树退化为链表\"></a>树退化为链表</h1><hr>\n<p>这个操作只有在transfer时，发现红黑树节点少于6，才会进行。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &lt;K,V&gt; <span class=\"function\">Node&lt;K,V&gt; <span class=\"title\">untreeify</span><span class=\"params\">(Node&lt;K,V&gt; b)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; hd = <span class=\"keyword\">null</span>, tl = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Node&lt;K,V&gt; q = b; q != <span class=\"keyword\">null</span>; q = q.next) &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; p = <span class=\"keyword\">new</span> Node&lt;K,V&gt;(q.hash, q.key, q.val, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tl == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            hd = p;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            tl.next = p;</span><br><span class=\"line\">        tl = p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hd;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"初始化方法\"><a href=\"#初始化方法\" class=\"headerlink\" title=\"初始化方法\"></a>初始化方法</h1><hr>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//空的，使用默认值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConcurrentHashMap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//自定义初始化的容量大小，就是bin的数量。</span></span><br><span class=\"line\"><span class=\"comment\">//其中的tableSizeFor方法在HashMap中是一样的，为了保证容量是2的整数次方</span></span><br><span class=\"line\"><span class=\"comment\">//会找到最接近initialCapacity的那个2的整数次方数。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConcurrentHashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class=\"number\">1</span>)) ?</span><br><span class=\"line\">                   MAXIMUM_CAPACITY :</span><br><span class=\"line\">                   tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>));</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.sizeCtl = cap;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//还可以自定义负载因子，但是并不能改变系统的负载因子，仅仅是用在构造函数中。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConcurrentHashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(initialCapacity, loadFactor, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//自定义负载因子，初始容量，并发线程数，concurrencyLevel的是并发更新map的线程数</span></span><br><span class=\"line\"><span class=\"comment\">//就是1.8之前的实现的分段锁的个数，现在已经不用，在这儿仅仅为了保持兼容性。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConcurrentHashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                             <span class=\"keyword\">float</span> loadFactor, <span class=\"keyword\">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(loadFactor &gt; <span class=\"number\">0.0f</span>) || initialCapacity &lt; <span class=\"number\">0</span> || concurrencyLevel &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &lt; concurrencyLevel)   <span class=\"comment\">// Use at least as many bins</span></span><br><span class=\"line\">            initialCapacity = concurrencyLevel;   <span class=\"comment\">// as estimated threads</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> size = (<span class=\"keyword\">long</span>)(<span class=\"number\">1.0</span> + (<span class=\"keyword\">long</span>)initialCapacity / loadFactor);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cap = (size &gt;= (<span class=\"keyword\">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class=\"line\">            MAXIMUM_CAPACITY : tableSizeFor((<span class=\"keyword\">int</span>)size);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.sizeCtl = cap;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"table初始化\"><a href=\"#table初始化\" class=\"headerlink\" title=\"table初始化\"></a>table初始化</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//table的初始化，这里需要考虑多线程竞争。</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; </span><br><span class=\"line\">    <span class=\"keyword\">int</span> sc;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((tab = table) == <span class=\"keyword\">null</span> || tab.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果已经有线程正在进行初始化，那么调用一下yield进入自旋等待初始化结束</span></span><br><span class=\"line\">        <span class=\"comment\">//这里的yield其实取决于操作系统，作用是提醒操作系统我这个线程主动让出时间片。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((sc = sizeCtl) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            Thread.yield(); <span class=\"comment\">// lost initialization race; just spin</span></span><br><span class=\"line\">        <span class=\"comment\">//cas操作，只有一个线程进入初始化，通过cas设为-1。</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (U.compareAndSwapInt(<span class=\"keyword\">this</span>, SIZECTL, sc, -<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || tab.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> n = (sc &gt; <span class=\"number\">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class=\"line\">                    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node&lt;?,?&gt;[n];</span><br><span class=\"line\">                    table = tab = nt;</span><br><span class=\"line\">                    <span class=\"comment\">//这个相当于sc = n*0.75，也就是乘上了负载因子0.75</span></span><br><span class=\"line\">                    <span class=\"comment\">//不过这种写法也真的是服。。。。</span></span><br><span class=\"line\">                    sc = n - (n &gt;&gt;&gt; <span class=\"number\">2</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                sizeCtl = sc;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h1><h2 id=\"put方法\"><a href=\"#put方法\" class=\"headerlink\" title=\"put方法\"></a>put方法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(key, value, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//第三个参数是是否只有在没有的情况进行put</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//key和value都不允许null</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span> || value == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"comment\">//得到key的hash值，spread函数让他分布的更均匀点。</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> hash = spread(key.hashCode());</span><br><span class=\"line\">    <span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; f; <span class=\"keyword\">int</span> n, i, fh;</span><br><span class=\"line\">        <span class=\"comment\">//如果table还没有进行初始化，进行初始化。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tab == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            tab = initTable();</span><br><span class=\"line\">        <span class=\"comment\">//如果tab[i]</span></span><br><span class=\"line\">        <span class=\"comment\">//的位置还是空的，就进行cas操作set进去</span></span><br><span class=\"line\">        <span class=\"comment\">//如果cas成功，就put成功了，就直接退出循环。</span></span><br><span class=\"line\">        <span class=\"comment\">//如果失败，那就进行自旋，再次尝试插入。</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((f = tabAt(tab, i = (n - <span class=\"number\">1</span>) &amp; hash)) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (casTabAt(tab, i, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                         <span class=\"keyword\">new</span> Node&lt;K,V&gt;(hash, key, value, <span class=\"keyword\">null</span>)))</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;                  </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果发现为-1，说明有其他线程正在进行扩容操作，就不自旋了</span></span><br><span class=\"line\">        <span class=\"comment\">//一起去参加扩容把，关于扩容参见下面</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((fh = f.hash) == MOVED)</span><br><span class=\"line\">            tab = helpTransfer(tab, f);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//准备进行同步方法，和分段不同的是</span></span><br><span class=\"line\">            <span class=\"comment\">//这里会给tab[i]的元素进行加锁。相当于一个bin一个锁。</span></span><br><span class=\"line\">            V oldVal = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (f) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//如果fh大于0，说明这个bin是链表</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (fh &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        binCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class=\"line\">                            K ek;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                                ((ek = e.key) == key ||</span><br><span class=\"line\">                                 (ek != <span class=\"keyword\">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class=\"line\">                                oldVal = e.val;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (!onlyIfAbsent)</span><br><span class=\"line\">                                    e.val = value;</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            Node&lt;K,V&gt; pred = e;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> ((e = e.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                pred.next = <span class=\"keyword\">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class=\"line\">                                                          value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">//不然就是红黑树，调用TreeBin的put方法。</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (f <span class=\"keyword\">instanceof</span> TreeBin) &#123;</span><br><span class=\"line\">                        Node&lt;K,V&gt; p;</span><br><span class=\"line\">                        binCount = <span class=\"number\">2</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class=\"line\">                                                       value)) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            oldVal = p.val;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (!onlyIfAbsent)</span><br><span class=\"line\">                                p.val = value;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (binCount != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//如果链表长度大于阈值，就进行树化</span></span><br><span class=\"line\">                <span class=\"comment\">//但是其实进去treeifyBin就会看到，还需要bin的数量大于64</span></span><br><span class=\"line\">                <span class=\"comment\">//不然就是直接扩容</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class=\"line\">                    treeifyBin(tab, i);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (oldVal != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> oldVal;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//如果插入成功，就总数加一，判断要不要进行扩容</span></span><br><span class=\"line\">    addCount(<span class=\"number\">1L</span>, binCount);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"get方法\"><a href=\"#get方法\" class=\"headerlink\" title=\"get方法\"></a>get方法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class=\"keyword\">int</span> n, eh; K ek;</span><br><span class=\"line\">    <span class=\"comment\">//得到hash值</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = spread(key.hashCode());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        (e = tabAt(tab, (n - <span class=\"number\">1</span>) &amp; h)) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((eh = e.hash) == h) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((ek = e.key) == key || (ek != <span class=\"keyword\">null</span> &amp;&amp; key.equals(ek)))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> e.val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//说明正在进行扩容操作，node是forwardingNode，调用forwardingNode的find方法。</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (eh &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (p = e.find(h, key)) != <span class=\"keyword\">null</span> ? p.val : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e.hash == h &amp;&amp;</span><br><span class=\"line\">                ((ek = e.key) == key || (ek != <span class=\"keyword\">null</span> &amp;&amp; key.equals(ek))))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> e.val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove\"></a>remove</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">remove</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> replaceNode(key, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">      </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">replaceNode</span><span class=\"params\">(Object key, V value, Object cv)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> hash = spread(key.hashCode());</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; f; <span class=\"keyword\">int</span> n, i, fh;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tab == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span> ||</span><br><span class=\"line\">            (f = tabAt(tab, i = (n - <span class=\"number\">1</span>) &amp; hash)) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"comment\">//如果正在进行迁移，那么就加入transfer行列。</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((fh = f.hash) == MOVED)</span><br><span class=\"line\">            tab = helpTransfer(tab, f);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            V oldVal = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> validated = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">//否则就对table[i]进行加锁</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (f) &#123;</span><br><span class=\"line\">               <span class=\"comment\">//...省略了，和get的方法差不多</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (validated) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (oldVal != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                        addCount(-<span class=\"number\">1L</span>, -<span class=\"number\">1</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> oldVal;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"扩容操作\"><a href=\"#扩容操作\" class=\"headerlink\" title=\"扩容操作\"></a>扩容操作</h1><p>扩容操作分为两步</p>\n<ul>\n<li>初始化nextTable数组，这个由单线程完成</li>\n<li>迁移table中的数据到nextTable中，这个可以并发的进行<br>主要操作是在transfer中，transfer方法可能被下面三个函数调用。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//扩容到size</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">tryPresize</span><span class=\"params\">(<span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class=\"number\">1</span>)) ? MAXIMUM_CAPACITY :</span><br><span class=\"line\">        tableSizeFor(size + (size &gt;&gt;&gt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sc;</span><br><span class=\"line\">    <span class=\"comment\">//sizeCtl&gt;=0说明没有正在扩容，或者表还没初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((sc = sizeCtl) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] tab = table; <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">        <span class=\"comment\">//如果表还没初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tab == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//扩容的值取两者的较大的</span></span><br><span class=\"line\">            n = (sc &gt; c) ? sc : c;</span><br><span class=\"line\">            <span class=\"comment\">//进行cas操作</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (U.compareAndSwapInt(<span class=\"keyword\">this</span>, SIZECTL, sc, -<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//成功，进行初始化</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (table == tab) &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node&lt;?,?&gt;[n];</span><br><span class=\"line\">                        table = nt;</span><br><span class=\"line\">                        sc = n - (n &gt;&gt;&gt; <span class=\"number\">2</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    sizeCtl = sc;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果现在的容量已经到达最大值或者扩容值比现在的小，就直接退出</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"comment\">//已经进行过初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tab == table) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> rs = resizeStamp(n);</span><br><span class=\"line\">            <span class=\"comment\">//如果sc小于0，说明正在进行扩容</span></span><br><span class=\"line\">            <span class=\"comment\">//不过这个可能小于0么，，我看了看好像不太可能啊。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sc &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                Node&lt;K,V&gt;[] nt;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class=\"number\">1</span> ||</span><br><span class=\"line\">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class=\"keyword\">null</span> ||</span><br><span class=\"line\">                    transferIndex &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (U.compareAndSwapInt(<span class=\"keyword\">this</span>, SIZECTL, sc, sc + <span class=\"number\">1</span>))</span><br><span class=\"line\">                    transfer(tab, nt);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//这里才是真正的进行扩容操作。</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (U.compareAndSwapInt(<span class=\"keyword\">this</span>, SIZECTL, sc,</span><br><span class=\"line\">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class=\"number\">2</span>))</span><br><span class=\"line\">                transfer(tab, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">resizeStamp</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Integer.numberOfLeadingZeros(n) | (<span class=\"number\">1</span> &lt;&lt; (RESIZE_STAMP_BITS - <span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//检查并进行扩容操作。</span></span><br><span class=\"line\"><span class=\"comment\">//首先初始化nextTable，大小为原来table大小的两倍</span></span><br><span class=\"line\"><span class=\"comment\">//把当前的size加上x，然后检查是否要进行扩容。</span></span><br><span class=\"line\"><span class=\"comment\">//这里涉及到size的计算，这个我们下面会讲。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">addCount</span><span class=\"params\">(<span class=\"keyword\">long</span> x, <span class=\"keyword\">int</span> check)</span> </span>&#123;</span><br><span class=\"line\">    CounterCell[] as; <span class=\"keyword\">long</span> b, s;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((as = counterCells) != <span class=\"keyword\">null</span> ||</span><br><span class=\"line\">        !U.compareAndSwapLong(<span class=\"keyword\">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class=\"line\">        CounterCell a; <span class=\"keyword\">long</span> v; <span class=\"keyword\">int</span> m;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> uncontended = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (as == <span class=\"keyword\">null</span> || (m = as.length - <span class=\"number\">1</span>) &lt; <span class=\"number\">0</span> ||</span><br><span class=\"line\">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class=\"keyword\">null</span> ||</span><br><span class=\"line\">            !(uncontended =</span><br><span class=\"line\">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class=\"line\">            fullAddCount(x, uncontended);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (check &lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        s = sumCount();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (check &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] tab, nt; <span class=\"keyword\">int</span> n, sc;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (s &gt;= (<span class=\"keyword\">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> rs = resizeStamp(n);</span><br><span class=\"line\">            <span class=\"comment\">//如果sc小于0，说明正在进行扩容操作，而加入进去进行扩容。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sc &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class=\"number\">1</span> ||</span><br><span class=\"line\">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class=\"keyword\">null</span> ||</span><br><span class=\"line\">                    transferIndex &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (U.compareAndSwapInt(<span class=\"keyword\">this</span>, SIZECTL, sc, sc + <span class=\"number\">1</span>))</span><br><span class=\"line\">                    transfer(tab, nt);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//不然就进行扩容，同nextTable中传了一个null进去</span></span><br><span class=\"line\">            <span class=\"comment\">//在transfer中会检查，如果是null就会先new一下nextTable。</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (U.compareAndSwapInt(<span class=\"keyword\">this</span>, SIZECTL, sc,</span><br><span class=\"line\">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class=\"number\">2</span>))</span><br><span class=\"line\">                transfer(tab, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">            s = sumCount();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//因为进行扩容时，需要把原来的元素搬到nextTable中，这个过程可以各个线程协助完成。</span></span><br><span class=\"line\"><span class=\"comment\">//如果在put操作中发现table正在扩容，则当前线程就会加入help转移的队伍中来。</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] nextTab; <span class=\"keyword\">int</span> sc;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tab != <span class=\"keyword\">null</span> &amp;&amp; (f <span class=\"keyword\">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class=\"line\">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rs = resizeStamp(tab.length);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class=\"line\">               (sc = sizeCtl) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class=\"number\">1</span> ||</span><br><span class=\"line\">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"comment\">//这里把通过cas把sc+1，如果成功，就加入transfer行列。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (U.compareAndSwapInt(<span class=\"keyword\">this</span>, SIZECTL, sc, sc + <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                transfer(tab, nextTab);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nextTab;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> table;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中并发迁移操作又分为几步：</p>\n<ul>\n<li>首先从table的最后一个节点开始找，如果table[i]是空，则通过cas把一个ForwardingNode放进去，标志已经迁移结束</li>\n<li>如果table[i]是forwardingNode，则继续向前找</li>\n<li>如果table[i]不为空，那么就对这个点进行加锁，把这个点的节点放到nextTable的i和i+n中。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这个是扩容的转移函数，也是最重要的部分，上面的函数都对这个进行了调用。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//其中transferIndex标记了在transfer中之前的table长度。</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> transferIndex;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">transfer</span><span class=\"params\">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = tab.length, stride;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((stride = (NCPU &gt; <span class=\"number\">1</span>) ? (n &gt;&gt;&gt; <span class=\"number\">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class=\"line\">        stride = MIN_TRANSFER_STRIDE; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//这里的判断为什么没有加锁呢，在多线程情况下看起来好像会造成错误</span></span><br><span class=\"line\">    <span class=\"comment\">//我看了下这个函数的调用，其实就是上面几个，上面几个调用的时候</span></span><br><span class=\"line\">    <span class=\"comment\">//nextTab肯定是已经进行了初始化的</span></span><br><span class=\"line\">    <span class=\"comment\">//除了addCount中，那个也进行了cas进行保护。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextTab == <span class=\"keyword\">null</span>) &#123;            </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">            <span class=\"comment\">//构造一个nextTable，他的容量是原来的两倍</span></span><br><span class=\"line\">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class=\"number\">1</span>];</span><br><span class=\"line\">            nextTab = nt;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;      <span class=\"comment\">// try to cope with OOME</span></span><br><span class=\"line\">            sizeCtl = Integer.MAX_VALUE;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nextTable = nextTab;</span><br><span class=\"line\">        transferIndex = n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nextn = nextTab.length;</span><br><span class=\"line\">    <span class=\"comment\">//构造一个ForwardingNode，用于标记当前的bin已经被转移结束了。</span></span><br><span class=\"line\">    ForwardingNode&lt;K,V&gt; fwd = <span class=\"keyword\">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class=\"line\">    <span class=\"comment\">//标记是否继续往下个节点找的标志</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> advance = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">//表示是否迁移结束的标志。</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> finishing = <span class=\"keyword\">false</span>; </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, bound = <span class=\"number\">0</span>;;) &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; f; <span class=\"keyword\">int</span> fh;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (advance) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nextIndex, nextBound;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (--i &gt;= bound || finishing)</span><br><span class=\"line\">                advance = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((nextIndex = transferIndex) &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                i = -<span class=\"number\">1</span>;</span><br><span class=\"line\">                advance = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (U.compareAndSwapInt</span><br><span class=\"line\">                     (<span class=\"keyword\">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class=\"line\">                      nextBound = (nextIndex &gt; stride ?</span><br><span class=\"line\">                                   nextIndex - stride : <span class=\"number\">0</span>))) &#123;</span><br><span class=\"line\">                bound = nextBound;</span><br><span class=\"line\">                <span class=\"comment\">//找到了一个，把advance置空，准备进行迁移操作。</span></span><br><span class=\"line\">                i = nextIndex - <span class=\"number\">1</span>;</span><br><span class=\"line\">                advance = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sc;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (finishing) &#123;</span><br><span class=\"line\">                nextTable = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                table = nextTab;</span><br><span class=\"line\">                sizeCtl = (n &lt;&lt; <span class=\"number\">1</span>) - (n &gt;&gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (U.compareAndSwapInt(<span class=\"keyword\">this</span>, SIZECTL, sc = sizeCtl, sc - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((sc - <span class=\"number\">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                finishing = advance = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                i = n; <span class=\"comment\">// recheck before commit</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果节点为空，那么把forwardingNode放进去，标记为已经迁移结束。</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((f = tabAt(tab, i)) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            advance = casTabAt(tab, i, <span class=\"keyword\">null</span>, fwd);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((fh = f.hash) == MOVED)</span><br><span class=\"line\">            advance = <span class=\"keyword\">true</span>; </span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//把table[i]进行加锁。</span></span><br><span class=\"line\">            <span class=\"comment\">//这边还对链表进行遍历,有点对半拆分的感觉</span></span><br><span class=\"line\">            <span class=\"comment\">//把链表分表拆分为，hash&amp;n等于0和不等于0的，然后分别放在新表的i和i+n位置</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (f) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class=\"line\">                    Node&lt;K,V&gt; ln, hn;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (fh &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> runBit = fh &amp; n;</span><br><span class=\"line\">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class=\"keyword\">null</span>; p = p.next) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">int</span> b = p.hash &amp; n;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (b != runBit) &#123;</span><br><span class=\"line\">                                runBit = b;</span><br><span class=\"line\">                                lastRun = p;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (runBit == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                            ln = lastRun;</span><br><span class=\"line\">                            hn = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            hn = lastRun;</span><br><span class=\"line\">                            ln = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> ((ph &amp; n) == <span class=\"number\">0</span>)</span><br><span class=\"line\">                                ln = <span class=\"keyword\">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                hn = <span class=\"keyword\">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        setTabAt(nextTab, i, ln);</span><br><span class=\"line\">                        setTabAt(nextTab, i + n, hn);</span><br><span class=\"line\">                        setTabAt(tab, i, fwd);</span><br><span class=\"line\">                        advance = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">//如果是一个红黑树bin</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (f <span class=\"keyword\">instanceof</span> TreeBin) &#123;</span><br><span class=\"line\">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class=\"line\">                        TreeNode&lt;K,V&gt; lo = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        TreeNode&lt;K,V&gt; hi = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> lc = <span class=\"number\">0</span>, hc = <span class=\"number\">0</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">int</span> h = e.hash;</span><br><span class=\"line\">                            TreeNode&lt;K,V&gt; p = <span class=\"keyword\">new</span> TreeNode&lt;K,V&gt;</span><br><span class=\"line\">                                (h, e.key, e.val, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> ((h &amp; n) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> ((p.prev = loTail) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                    lo = p;</span><br><span class=\"line\">                                <span class=\"keyword\">else</span></span><br><span class=\"line\">                                    loTail.next = p;</span><br><span class=\"line\">                                loTail = p;</span><br><span class=\"line\">                                ++lc;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> ((p.prev = hiTail) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                    hi = p;</span><br><span class=\"line\">                                <span class=\"keyword\">else</span></span><br><span class=\"line\">                                    hiTail.next = p;</span><br><span class=\"line\">                                hiTail = p;</span><br><span class=\"line\">                                ++hc;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"comment\">//这里会判断红黑树的节点是否小于UNTREEIFY_THRESHOLD，也就是6</span></span><br><span class=\"line\">                        <span class=\"comment\">//如果小于，那么就是退化为链表</span></span><br><span class=\"line\">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class=\"line\">                            (hc != <span class=\"number\">0</span>) ? <span class=\"keyword\">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class=\"line\">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class=\"line\">                            (lc != <span class=\"number\">0</span>) ? <span class=\"keyword\">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class=\"line\">                        setTabAt(nextTab, i, ln);</span><br><span class=\"line\">                        setTabAt(nextTab, i + n, hn);</span><br><span class=\"line\">                        setTabAt(tab, i, fwd);</span><br><span class=\"line\">                        advance = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"size值的计算\"><a href=\"#size值的计算\" class=\"headerlink\" title=\"size值的计算\"></a>size值的计算</h1><p>这个是继承自AbstractMap的方法，问题是返回的是int，但是里面可能存在的值可能会大于int<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> n = sumCount();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((n &lt; <span class=\"number\">0L</span>) ? <span class=\"number\">0</span> :</span><br><span class=\"line\">            (n &gt; (<span class=\"keyword\">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class=\"line\">            (<span class=\"keyword\">int</span>)n);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>所以在1.8中增加了这个方法，并且从注释上可以看到作者希望我们应该调用这个方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">mappingCount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> n = sumCount();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0L</span>) ? <span class=\"number\">0L</span> : n; <span class=\"comment\">// ignore transient negative values</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>他们都调用了sumCount()方法，这个就是把baseCount加上所有的as的值。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@sun</span>.misc.Contended <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CounterCell</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> value;</span><br><span class=\"line\">    CounterCell(<span class=\"keyword\">long</span> x) &#123; value = x; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> CounterCell[] counterCells;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">long</span> <span class=\"title\">sumCount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> sum = baseCount;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (as != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((a = as[i]) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                sum += a.value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>那为什么要这么做呢，这个回到上面的addCount方法看看，在进行更新的时候，会尝试使用cas更新baseCount<br>但是如果更新失败，那么就尝试在counterCells上做文章，这里做的几乎和LongAdder一样，就不赘述了。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">addCount</span><span class=\"params\">(<span class=\"keyword\">long</span> x, <span class=\"keyword\">int</span> check)</span> </span>&#123;</span><br><span class=\"line\">    CounterCell[] as; <span class=\"keyword\">long</span> b, s;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((as = counterCells) != <span class=\"keyword\">null</span> ||</span><br><span class=\"line\">        !U.compareAndSwapLong(<span class=\"keyword\">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class=\"line\">        CounterCell a; <span class=\"keyword\">long</span> v; <span class=\"keyword\">int</span> m;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> uncontended = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (as == <span class=\"keyword\">null</span> || (m = as.length - <span class=\"number\">1</span>) &lt; <span class=\"number\">0</span> ||</span><br><span class=\"line\">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class=\"keyword\">null</span> ||</span><br><span class=\"line\">            !(uncontended =</span><br><span class=\"line\">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class=\"line\">            fullAddCount(x, uncontended);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (check &lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        s = sumCount();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>有很多细节其实挺让我震惊的。</p>\n<ul>\n<li>Node中如果可能是多线程访问的，都加了volatile进行修饰</li>\n<li>锲而不舍的追求高效率的位运算，连乘0.75都换成n - n &gt;&gt;&gt; 2来代替</li>\n</ul>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"http://blog.csdn.net/lsgqjh/article/details/54867107\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/lsgqjh/article/details/54867107</a></p>\n","categories":["Java源码解读"],"tags":["Java"]},{"title":"LinkedList源码分析","url":"https://blog.lovezhy.cc/2017/12/10/LinkedList源码分析/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinkedList</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">extends</span> <span class=\"title\">AbstractSequentialList</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt;, <span class=\"title\">Deque</span>&lt;<span class=\"title\">E</span>&gt;, <span class=\"title\">Cloneable</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span></span><br></pre></td></tr></table></figure>\n<p>和ArrayList相比，LinkedList多了AbstractSequentialList类和Deque接口。</p>\n<p>其中Deque又是继承自Queue，所以LinkedList可以当做队列或者双端队列。<br><a id=\"more\"></a></p>\n<p>其中AbstractSequentialList的作用可以当做是RandomAccess的对照来看。</p>\n<p>关于RandomAccess，可以看看ArrayList源码。</p>\n<h2 id=\"底层结构\"><a href=\"#底层结构\" class=\"headerlink\" title=\"底层结构\"></a>底层结构</h2><p>LinkedList每个节点都是一个Node类，Node中有next和prev。可以看到实现的是双端队列。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">        E item;</span><br><span class=\"line\">        Node&lt;E&gt; next;</span><br><span class=\"line\">        Node&lt;E&gt; prev;</span><br><span class=\"line\"></span><br><span class=\"line\">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.item = element;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.prev = prev;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>基本的成员变量，保存了链表的头部和尾部<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;E&gt; first;</span><br><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;E&gt; last;</span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h2><p>get方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        checkElementIndex(index);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node(index).item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Node&lt;E&gt; <span class=\"title\">node</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; (size &gt;&gt; <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            Node&lt;E&gt; x = first;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; index; i++)</span><br><span class=\"line\">                x = x.next;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Node&lt;E&gt; x = last;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = size - <span class=\"number\">1</span>; i &gt; index; i--)</span><br><span class=\"line\">                x = x.prev;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>get方法调用了node方法，node方法是找到index位的元素。<br>这个方法还是很有意思的，他先判断index是在前半段还是后半段，前半段就从first节点开始找，后半段就从last节点开始找。</p>\n<p>remove方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">for</span> (Node&lt;E&gt; x = first; x != <span class=\"keyword\">null</span>; x = x.next) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (x.item == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                   unlink(x);</span><br><span class=\"line\">                   <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           <span class=\"keyword\">for</span> (Node&lt;E&gt; x = first; x != <span class=\"keyword\">null</span>; x = x.next) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (o.equals(x.item)) &#123;</span><br><span class=\"line\">                   unlink(x);</span><br><span class=\"line\">                   <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>因为LinkedList支持存null，所以在remove的时候要分两种情况讨论。</p>\n<h2 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h2><h3 id=\"Iterator\"><a href=\"#Iterator\" class=\"headerlink\" title=\"Iterator\"></a>Iterator</h3><p>Iterator方法是在AbstractSequentialList中<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Iterator&lt;E&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> listIterator();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>LinkedList中重写了listIterator方法。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ListIterator&lt;E&gt; <span class=\"title\">listIterator</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        checkPositionIndex(index);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ListItr(index);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>ListLtr是LinkedList中的一个类<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListItr</span> <span class=\"keyword\">implements</span> <span class=\"title\">ListIterator</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ListIterator\"><a href=\"#ListIterator\" class=\"headerlink\" title=\"ListIterator\"></a>ListIterator</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ListIterator&lt;E&gt; <span class=\"title\">listIterator</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        checkPositionIndex(index);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ListItr(index);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，其实和Iterator方法的实现是一样的。</p>\n","categories":["Java源码解读"],"tags":["Java"]},{"title":"HashSet源码解析","url":"https://blog.lovezhy.cc/2017/12/09/HashSet源码分析/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><code>HashSet</code>其实实现很简单，也很取巧。</p>\n<a id=\"more\"></a>\n<h2 id=\"底层结构\"><a href=\"#底层结构\" class=\"headerlink\" title=\"底层结构\"></a>底层结构</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object PRESENT = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashSet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看构造函数就知道里面存了一个<code>HashMap</code>，而那个<code>PRESENT</code>的<code>Object</code>的作用就是给每个存进<code>Set</code>的对象的value。</p>\n<h2 id=\"基本方法\"><a href=\"#基本方法\" class=\"headerlink\" title=\"基本方法\"></a>基本方法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> map.put(e, PRESENT)==<span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> map.remove(o)==PRESENT;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> map.containsKey(o);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Iterator&lt;E&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> map.keySet().iterator();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这三个基本方法可以看出，其实<code>HashSet</code>就是封装了一个<code>HashMap</code>，每次存一个对象其实就是在<code>Map</code>中放了一个<code>key -&gt; Object</code>， 那个<code>Object</code>是共享的。<br>而iterator方法返回的是<code>keySet</code>的<code>iterator</code>。<br>​    </p>\n","categories":["Java源码解读"],"tags":["Java"]},{"title":"ArrayList源码分析","url":"https://blog.lovezhy.cc/2017/12/07/ArrayList源码分析/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt;, <span class=\"title\">RandomAccess</span>, <span class=\"title\">Cloneable</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span></span><br></pre></td></tr></table></figure>\n<p>继承结构是这样</p>\n<a id=\"more\"></a>\n<h2 id=\"数据结构与扩容操作\"><a href=\"#数据结构与扩容操作\" class=\"headerlink\" title=\"数据结构与扩容操作\"></a>数据结构与扩容操作</h2><p>既然名字是<code>ArrayList</code>，那么底层多多少少和数组有关。</p>\n<p>先来看看构造函数里做了啥。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">transient</span> Object[] elementData;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.elementData = <span class=\"keyword\">new</span> Object[initialCapacity];</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Capacity: \"</span>+ initialCapacity);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当构造函数的参数为空时，给成员变量<code>elementData</code>赋了一个空的数组。<br>当我们指定了初始大小的时候，如果参数大于0，那么<code>elementData</code>就是我们设的大小，如果等于0，那么还是赋了一个空的数组给<code>elementData</code>。</p>\n<p>进行add操作时 。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">\tensureCapacityInternal(size + <span class=\"number\">1</span>);</span><br><span class=\"line\">\telementData[size++] = e;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们可以注意到一个<code>ensureCapacityInternal</code>的函数，这个函数是确保底层的数组有足够的空间进行增加的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CAPACITY = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">\t\tminCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>ArrayList</code>中还有一个成员变量是<code>DEFAULT_CAPACITY</code>，默认大小是10。<br>如果是无参数的new的ArrayList话而且是第一次调用add的话，那么<code>minCapacity</code>就会是10。<br>但是如果是下面再进行add的话，再进去这个函数，则是直接调用<code>ensureExplicitCapacity</code>函数。<br>不会在进行<code>Math.max</code>的操作了。<br>这里还是没有真正就行底层扩容操作。</p>\n<p>再来看看<code>ensureExplicitCapacity</code>函数<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> modCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">\tmodCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\tgrow(minCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里用到了<code>modCount</code>变量，这个在<code>HashMap</code>中也有看到，这个和<code>fail-fast</code>有关，下面会介绍。<br>下面还对<code>minCapacity - elementData.length &gt; 0</code>进行了一次判断，因为现在的长度的数组可能还没用完，如果这样的话，那么不用扩容，直接用就行了。<br>还有一种情况就是<code>minCapacity</code>已经超过<code>int</code>最大值了，变成了负数了，那样也不会进行扩容。</p>\n<p>关键是在grow函数中<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class=\"number\">8</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\tnewCapacity = minCapacity;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\tnewCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">\t<span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">\telementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里才看到了真正的扩容操作。但是别急，在操作之前还需要进行判断作为保证。<br>这里有三个变量，和名字一样，</p>\n<ul>\n<li><code>minCapacity</code>就是这次扩容后的最小容量</li>\n<li><code>newCapacity</code>是最后进行扩容的大小，也就是最终扩容时用到的</li>\n<li><code>oldCapacity</code>是现在的大小。</li>\n</ul>\n<p>现在我们在回去看add参数的话，会看到他调用的<code>ensureCapacityInternal</code>时的参数是当前的大小加1，注意，只是加了1而已，每次add都扩容的话，那么代价肯定会非常高的。</p>\n<p>这里的溢出检查的<code>newCapacity</code>是现在的<code>size</code>加上<code>size</code>的一半。也就是原来的大小的3/2。<br>所以不出意外的话，大多数情况下，每次扩容的大小都是原来的大小的3/2。<br>那么我们还需要考虑特殊情况，就是溢出的情况。</p>\n<p>如果<code>newCapacity</code>乘上了原来的3/2，超过了int的范围，变成了负数，那么就是<code>newCapacity - minCapacity &lt; 0</code>为true了，那么<code>newCapacity</code>的大小就是<code>minCapacity</code>，也就是原来的大小加上了1。</p>\n<p>如果没有溢出，但是比<code>MAX_ARRAY_SIZE</code>大，也就是在<code>Integer.MAX_VALUE - 9</code> 到<code>Integer.MAX_VALUE</code>之间。那么<code>newCapacity</code>的大小就是<code>hugeCapacity</code>的返回值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class=\"number\">8</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hugeCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> OutOfMemoryError();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class=\"line\">\t\tInteger.MAX_VALUE :</span><br><span class=\"line\">\t\tMAX_ARRAY_SIZE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里如果<code>minCapacity</code>溢出了，也就是现在的<code>size</code>的大小已经是<code>Integer.MAX_VALUE</code>了，那么就抛出<code>OutOfMemoryError</code>了。</p>\n<p>在<code>hugeCapacity</code>函数中，<code>minCapacity</code>和<code>MAX_ARRAY_SIZE</code>进行了比较，如果<code>minCapacity</code>大于<code>MAX_ARRAY_SIZE</code>但是还没有溢出，那么就直接扩容到<code>Integer.MAX_VALUE</code>。</p>\n<p>看到这里我猜想了如果出现了极端的情况，就是<code>add</code>时<code>size</code>刚好是<code>Integer</code>的最大值会怎么样？<br>那时，<code>minCapacity - elementData.length</code>的结果是1，还是可以进入<code>grow</code>函数。最后进入<code>hugeCapacity</code>函数，最后抛出<code>OutOfMemoryError</code>。<br>给力。代码的鲁棒性很好。</p>\n<h2 id=\"fail-fast机制与遍历\"><a href=\"#fail-fast机制与遍历\" class=\"headerlink\" title=\"fail-fast机制与遍历\"></a>fail-fast机制与遍历</h2><p>上面我们提到一个变量<code>modCount</code>，每次我们进行add或者是进行一些其他的修改数组的操作时，这个参数就会加1。<br>在单线程中，这个当然是不会出错的。<br>但是在多线程中，我们知道如果我们在遍历时，可能会抛出<code>ConcurrentModificationException</code>。<br>这个异常就是提醒我们在遍历时，有其他的线程对数组进行了修改。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">forEach</span><span class=\"params\">(Consumer&lt;? <span class=\"keyword\">super</span> E&gt; action)</span> </span>&#123;</span><br><span class=\"line\">\tObjects.requireNonNull(action);</span><br><span class=\"line\">\t<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> expectedModCount = modCount;</span><br><span class=\"line\">\t<span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">final</span> E[] elementData = (E[]) <span class=\"keyword\">this</span>.elementData;</span><br><span class=\"line\">\t<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> size = <span class=\"keyword\">this</span>.size;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class=\"line\">\t\taction.accept(elementData[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (modCount != expectedModCount) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>比如这个<code>forEach</code>方法，在进行操作前先记录当前的<code>modCount</code>大小，最后操作完比对现在的<code>modCount</code>，如果不一样，那么就抛出异常。</p>\n<h2 id=\"RandomAccess接口\"><a href=\"#RandomAccess接口\" class=\"headerlink\" title=\"RandomAccess接口\"></a>RandomAccess接口</h2><p>这个接口是空的，只是做一个标记的作用。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">RandomAccess</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>什么标记呢，就是对实现了这类接口的类进行遍历时，<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>, n=list.size(); i &amp;lt; n; i++)</span><br><span class=\"line\">    list.get(i);</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (Iterator i=list.iterator(); i.hasNext(); )</span><br><span class=\"line\">    i.next();</span><br></pre></td></tr></table></figure>\n<p>如果第一种遍历方式要比第二种快，那么他就应该实现RandomAccess接口，这样我们在使用的时候，在特定场景可能会根据是否实现了RandomAccess来进行遍历。<br>这个我们在比较LinkedList的时候就能理解了。<br>因为LinkedList是链表的方式，如果我们使用第一种遍历，那相当于每次get都从头开始找了。<br>所以LinkedList就不能实现这个接口。<br>而ArrayList底层是数组，所以直接get反而更快一点，而用第二种还需要进行一个SubList的构造。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trimToSize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tmodCount++;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (size &lt; elementData.length) &#123;</span><br><span class=\"line\">\t\telementData = (size == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t  ? EMPTY_ELEMENTDATA</span><br><span class=\"line\">\t\t  : Arrays.copyOf(elementData, size);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个方法很有意思，因为我们的扩容机制不是一个一个的增加的，一下子增加原来的3/2大小。<br>如果我们不再往里面增加元素的话，那么多出来的就很浪费。<br>这个方法就是去除多余的没设置值的空间。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\tArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">\t\tv.elementData = Arrays.copyOf(elementData, size);</span><br><span class=\"line\">\t\tv.modCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> v;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// this shouldn't happen, since we are Cloneable</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InternalError(e);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>clone</code>方法可以看到，做的是浅拷贝。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">\trangeCheck(index);</span><br><span class=\"line\"></span><br><span class=\"line\">\tmodCount++;</span><br><span class=\"line\">\tE oldValue = elementData(index);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\tSystem.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">\t\t\t\t\t\t numMoved);</span><br><span class=\"line\">\telementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个方法，可以看到开销还是挺大的，那个注释很有意思，把后面缩小之后的引用置位null。<br>如果不置位<code>null</code>，仅仅是<code>size-1</code>的话，那么位于<code>size</code>位的对象无法被<code>GC</code>收集。<br>这样就会造成内存泄漏。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tmodCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">\t\telementData[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsize = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>clear方法并没有释放底层的数组，只是把每个引用置位<code>null</code>。</p>\n","categories":["Java源码解读"],"tags":["Java"]},{"title":"JsessionId的生成","url":"https://blog.lovezhy.cc/2017/11/18/jsessionid的生成/","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>因为http是无状态的，所以产生了cookie，session机制来构造一个会话。</p>\n<p>一般流程是这样：</p>\n<ul>\n<li>客户端发送请求</li>\n<li>服务端接收请求，并且设置Set-Cookie头，分配一个sessionId</li>\n<li>客户端存在cookie，下次发送时带上sessionid</li>\n<li>服务端解析sessionid，找到对应的session信息<a id=\"more\"></a>\n</li>\n</ul>\n<p>所以我们可以知道，核心就在这个sessionid身上。</p>\n<p>那么这个sessionid需要哪些特质呢</p>\n<ul>\n<li><p>唯一性:<br>这个是肯定的，万一前一个人请求，发送sessionid，后面紧接着又来一个人，发送一个sessionid，两个人的id重合了，那就出问题了。</p>\n</li>\n<li><p>不容易猜到性:<br>这个其实是阻拦一些攻击的。<br>java中自带了UUID</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UUID.randomUUID().toString().replaceAll(<span class=\"string\">\"-\"</span>, <span class=\"string\">\"\"</span>);</span><br></pre></td></tr></table></figure>\n<p>这样做其实可以满足唯一性，但是使用UUID的一个问题是，UUID其实并不是那么不好猜。<br>因为UUID的使用领域就不是为了安全领域的。<br>参见StackOverFlow</p>\n<p> <a href=\"https://stackoverflow.com/questions/5244455/best-practices-for-sessionid-authentication-token-generation\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/5244455/best-practices-for-sessionid-authentication-token-generation</a></p>\n</li>\n</ul>\n<h1 id=\"Tomcat的实现\"><a href=\"#Tomcat的实现\" class=\"headerlink\" title=\"Tomcat的实现\"></a>Tomcat的实现</h1><p>由于本人算法渣，自己想不到什么好办法实现，所以就去看了Tomcat怎么实现。</p>\n<h2 id=\"SecureRandom\"><a href=\"#SecureRandom\" class=\"headerlink\" title=\"SecureRandom\"></a>SecureRandom</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//SecureRandom是在java.security包中</span></span><br><span class=\"line\"><span class=\"comment\">//主要是用来产生随机数</span></span><br><span class=\"line\"><span class=\"comment\">//这个类主要依赖sun.security.provider.SecureRandom()我是没看明白。。。</span></span><br><span class=\"line\"><span class=\"comment\">//下面的sessionid的实现主要也是利用这个类实现的</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecureRandom</span> <span class=\"keyword\">extends</span> <span class=\"title\">java</span>.<span class=\"title\">util</span>.<span class=\"title\">Random</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"SessionIdGenerator\"><a href=\"#SessionIdGenerator\" class=\"headerlink\" title=\"SessionIdGenerator\"></a>SessionIdGenerator</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">SessionIdGenerator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//这个参数和集群有关，下面会看到</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getJvmRoute</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setJvmRoute</span><span class=\"params\">(String jvmRoute)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//sessionid的长度</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getSessionIdLength</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//设置sessionid的长度</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setSessionIdLength</span><span class=\"params\">(<span class=\"keyword\">int</span> sessionIdLength)</span></span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">//这是最核心的方法，下面会看到他的实现</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">generateSessionId</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">generateSessionId</span><span class=\"params\">(String route)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"SessionIdGeneratorBase\"><a href=\"#SessionIdGeneratorBase\" class=\"headerlink\" title=\"SessionIdGeneratorBase\"></a>SessionIdGeneratorBase</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SessionIdGeneratorBase</span> <span class=\"keyword\">extends</span> <span class=\"title\">LifecycleBase</span></span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">SessionIdGenerator</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//这里保存了很多的SecureRandom实例，因为单个的SecureRandom使用了同步</span></span><br><span class=\"line\">    <span class=\"comment\">//这样如果队列为空，就创建一个SecureRandom实例，这样会快点</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Queue&lt;SecureRandom&gt; randoms = <span class=\"keyword\">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String secureRandomClass = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String secureRandomAlgorithm = <span class=\"string\">\"SHA1PRNG\"</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String secureRandomProvider = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//这个参数很有意思，如果是单机上的，就是\"\"，如果是在tomcat集群中，那么这个就是集群的编号</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String jvmRoute = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">\t  </span><br><span class=\"line\">    <span class=\"comment\">//默认长度是16</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> sessionIdLength = <span class=\"number\">16</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//产生一个sessionid</span></span><br><span class=\"line\">    <span class=\"comment\">//如果是单机的话，就是调用了</span></span><br><span class=\"line\">    <span class=\"comment\">//generateSessionId(\"\")</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">generateSessionId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> generateSessionId(jvmRoute);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//利用queue中的SecureRandom产生随机数</span></span><br><span class=\"line\">    <span class=\"comment\">//这里可以看到为什么要用一个队列存SecureRandom实例了。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">getRandomBytes</span><span class=\"params\">(<span class=\"keyword\">byte</span> bytes[])</span> </span>&#123;</span><br><span class=\"line\">        SecureRandom random = randoms.poll();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (random == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            random = createSecureRandom();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        random.nextBytes(bytes);</span><br><span class=\"line\">        randoms.add(random);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//这里产生一个SecureRandom实例，一般来说会从找是否设置了</span></span><br><span class=\"line\">    <span class=\"comment\">//自定义的SecureRandom，如果没有，就创建一个系统的</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> SecureRandom <span class=\"title\">createSecureRandom</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        SecureRandom result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> t1 = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (secureRandomClass != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Construct and seed a new random number generator</span></span><br><span class=\"line\">                Class&lt;?&gt; clazz = Class.forName(secureRandomClass);</span><br><span class=\"line\">                result = (SecureRandom) clazz.getConstructor().newInstance();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                log.error(sm.getString(<span class=\"string\">\"sessionIdGeneratorBase.random\"</span>,</span><br><span class=\"line\">                        secureRandomClass), e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> error = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">       \t\t...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span> &amp;&amp; error) &#123;</span><br><span class=\"line\">\t\t \t\t....</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t  \t</span><br><span class=\"line\">        <span class=\"comment\">//用系统的</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Nothing works - use platform default</span></span><br><span class=\"line\">            result = <span class=\"keyword\">new</span> SecureRandom();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">// Force seeding to take place</span></span><br><span class=\"line\">        result.nextInt();</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"keyword\">long</span> t2 = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((t2 - t1) &gt; <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">            log.warn(sm.getString(<span class=\"string\">\"sessionIdGeneratorBase.createRandom\"</span>,</span><br><span class=\"line\">                    result.getAlgorithm(), Long.valueOf(t2 - t1)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"StandardSessionIdGenerator\"><a href=\"#StandardSessionIdGenerator\" class=\"headerlink\" title=\"StandardSessionIdGenerator\"></a>StandardSessionIdGenerator</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这个类只重写了一个generateSessionId方法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StandardSessionIdGenerator</span> <span class=\"keyword\">extends</span> <span class=\"title\">SessionIdGeneratorBase</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">generateSessionId</span><span class=\"params\">(String route)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">byte</span> random[] = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">16</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sessionIdLength = getSessionIdLength();</span><br><span class=\"line\">  </span><br><span class=\"line\">        StringBuilder buffer = <span class=\"keyword\">new</span> StringBuilder(<span class=\"number\">2</span> * sessionIdLength + <span class=\"number\">20</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> resultLenBytes = <span class=\"number\">0</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (resultLenBytes &lt; sessionIdLength) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//这个方法就是利用SecureRandom得到随机数</span></span><br><span class=\"line\">            getRandomBytes(random);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">            j &lt; random.length &amp;&amp; resultLenBytes &lt; sessionIdLength;</span><br><span class=\"line\">            j++) &#123;</span><br><span class=\"line\">            \t<span class=\"comment\">//对产生的随机数进行一些处理</span></span><br><span class=\"line\">                <span class=\"keyword\">byte</span> b1 = (<span class=\"keyword\">byte</span>) ((random[j] &amp; <span class=\"number\">0xf0</span>) &gt;&gt; <span class=\"number\">4</span>);</span><br><span class=\"line\">                <span class=\"keyword\">byte</span> b2 = (<span class=\"keyword\">byte</span>) (random[j] &amp; <span class=\"number\">0x0f</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (b1 &lt; <span class=\"number\">10</span>)</span><br><span class=\"line\">                    buffer.append((<span class=\"keyword\">char</span>) (<span class=\"string\">'0'</span> + b1));</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    buffer.append((<span class=\"keyword\">char</span>) (<span class=\"string\">'A'</span> + (b1 - <span class=\"number\">10</span>)));</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (b2 &lt; <span class=\"number\">10</span>)</span><br><span class=\"line\">                    buffer.append((<span class=\"keyword\">char</span>) (<span class=\"string\">'0'</span> + b2));</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    buffer.append((<span class=\"keyword\">char</span>) (<span class=\"string\">'A'</span> + (b2 - <span class=\"number\">10</span>)));</span><br><span class=\"line\">                resultLenBytes++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">//加上集群中的本机编号</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (route != <span class=\"keyword\">null</span> &amp;&amp; route.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            buffer.append(<span class=\"string\">'.'</span>).append(route);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            String jvmRoute = getJvmRoute();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (jvmRoute != <span class=\"keyword\">null</span> &amp;&amp; jvmRoute.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                buffer.append(<span class=\"string\">'.'</span>).append(jvmRoute);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> buffer.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>总的来说</p>\n<ul>\n<li>Tomcat的sessionid的生成主要是随机数，依赖的类是java.security.SecureRandom</li>\n<li>为了避免多线程竞争的问题，引入了一个queue，当SecureRandom不够用就生成一个。</li>\n<li>同时在集群中加入了本机的编号</li>\n</ul>\n","categories":["Tomcat"],"tags":["Tomcat"]},{"title":"HotSpot原理指南-哪些可以作为GCRoots","url":"https://blog.lovezhy.cc/2017/10/24/哪些可以作为GCRoots/","content":"<h1 id=\"主要的GC算法\"><a href=\"#主要的GC算法\" class=\"headerlink\" title=\"主要的GC算法\"></a>主要的GC算法</h1><hr>\n<ul>\n<li>引用计数<br>不赘述了，主要是无法解决互相引用的问题</li>\n<li>可达性分析<br>就是从一些叫做<code>GC Roots</code>的引用开始，一步一步的找能达到的对象，如果没达到，那么就不可达的，就会开始回收它。</li>\n</ul>\n<p><code>HotSpot</code>采用的是可达性分析。<br>那么哪些可以作为GC Roots呢？</p>\n<a id=\"more\"></a>\n<h1 id=\"书上的\"><a href=\"#书上的\" class=\"headerlink\" title=\"书上的\"></a>书上的</h1><hr>\n<p>在《深入理解Java虚拟机-JVM高级特性与最佳实践》中，简单的提了一下</p>\n<ul>\n<li>虚拟机栈（栈帧中的本地变量表）中引用的对象 </li>\n<li>方法区中类静态属性引用的对象</li>\n<li>方法区中常量引用的对象</li>\n<li>本地方法栈中JNI（native方法）引用的对象</li>\n</ul>\n<p>简单解释下</p>\n<p>第一种就是指当前的Java线程中正在调用的方法的引用类型的参数，局部变量，临时值，这个具有随机性。</p>\n<p>第二种就是指类对象的引用对象，比如<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;String&gt; list = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里的<code>list</code>就是这种。</p>\n<p>第三种是指的常量一般指<code>static final</code>这种，比如<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String name = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里的<code>name</code>就是，当然枚举类中的也是。</p>\n<p>第四种就是<code>native</code>方法了，就是一般是c语言或者c++写的。</p>\n<h1 id=\"再进行拓展\"><a href=\"#再进行拓展\" class=\"headerlink\" title=\"再进行拓展\"></a>再进行拓展</h1><hr>\n<p>我又去搜了一下。</p>\n<p>又找到了更具体的一下，其实哪些能作为GC Roots在一定程度上也是依赖收集器的设计的。</p>\n<blockquote>\n<p>来自<a href=\"https://www.zhihu.com/question/53613423/answer/135743258\" target=\"_blank\" rel=\"noopener\">RednaxelaFX</a>的答案</p>\n<ul>\n<li>（看情况）所有当前被加载的Java类</li>\n<li>（看情况）Java类的引用类型静态变量</li>\n<li>（看情况）Java类的运行时常量池里的引用类型常量（String或Class类型）</li>\n</ul>\n</blockquote>\n<p>这里还多了Class类型，。。。。</p>\n<p>在<code>eclipse</code>的文档网站，找到了更为详细的</p>\n<p><a href=\"http://help.eclipse.org/luna/index.jsp?topic=%2Forg.eclipse.mat.ui.help%2Fconcepts%2Fgcroots.html&amp;cp=37_2_3\" target=\"_blank\" rel=\"noopener\">eclipse</a></p>\n<ul>\n<li><p>System Class<br>被bootstrap类加载器加载的类</p>\n</li>\n<li><p>JNI Local<br>JNI定义的局部变量</p>\n</li>\n<li><p>JNI Global<br>JNI定义的全局变量</p>\n</li>\n<li><p>Thread Block<br>当前线程块中的对象</p>\n</li>\n<li><p>Thread<br>未停止的线程</p>\n</li>\n<li><p>Busy Monitor<br>调用了wait()或者notify()或者正在进行同步的对象和类</p>\n</li>\n<li><p>Java Local<br>当前线程虚拟机栈中的本地变量</p>\n</li>\n<li><p>Native Stack<br>本地方法栈中的对象</p>\n</li>\n<li><p>Finalizable<br>一个正在在等待finalize的对象</p>\n</li>\n<li><p>Unfinalized<br>拥有finalize方法，但是不在等待finalize的对象</p>\n</li>\n<li><p>Unreachable<br>一个不可达的对象，但是仍然被Memory Analyzer标记为GC Root的对象<br>这个的解释就是对于一些小对象，GC觉得收集它太浪费珍贵的GC时间了，就放弃了。</p>\n</li>\n<li><p>Java Stack Frame<br>Java栈帧，如果你设定栈帧也为一个对象的话</p>\n</li>\n<li><p>Unknown<br>其他未知的</p>\n</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><hr>\n<p>上面说的很多重复的，有些是看不懂的。所以我自己总结了下</p>\n<ul>\n<li>所有线程当前虚拟机栈（栈帧中的本地变量表）中引用的对象，包括局部变量，参数对象。</li>\n<li>方法区中类静态属性引用的对象</li>\n<li>方法区中常量引用的对象</li>\n<li>本地方法栈中JNI（native方法）引用的对象，包括局部变量和全局变量</li>\n<li>被bootstrap类加载器加载的类</li>\n<li>当前所有活跃的线程</li>\n<li>调用了wait()或者notify()或者正在进行同步的对象和类</li>\n<li>一个正在在等待finalize的对象</li>\n<li>拥有finalize方法，但是不在等待finalize的对象</li>\n<li>一个不可达的对象，但是仍然被Memory Analyzer标记为GC Root的对象</li>\n</ul>\n","categories":["HotSpot"],"tags":["Java"]},{"title":"动态代理的缓存实现","url":"https://blog.lovezhy.cc/2017/09/10/动态代理的缓存实现/","content":"<p>动态代理的缓存实现<br><a id=\"more\"></a></p>\n<h1 id=\"字节码\"><a href=\"#字节码\" class=\"headerlink\" title=\"字节码\"></a>字节码</h1><hr>\n<p>我们经常听到字节码，简单的说字节码就是Java源代码到虚拟机执行的期间生成的中间代码。</p>\n<p><code>JVM</code>虽然叫Java虚拟机，但是更准确的叫法我觉得应该是字节码虚拟机。</p>\n<p>因为我们听过很多的JVM语言，其实它们之所以能在JVM上运行，也是编译成字节码丢进去运行的。</p>\n<p>我们一般使用<code>javac</code>来生成java字节码来让jvm去运行。</p>\n<p>那其实宽泛的说<code>javac</code>也就是一个字节码生成器。</p>\n<p>因为字节码是二进制流，所以我们自然也可以用<code>java</code>语言手动产生一个字节码流。</p>\n<h1 id=\"字节码生成器\"><a href=\"#字节码生成器\" class=\"headerlink\" title=\"字节码生成器\"></a>字节码生成器</h1><hr>\n<p>字节码生成器说到底就是根据字节码规范去用程序生成字节码。</p>\n<p>一般用的比较多的就是<code>Javaassist</code>，<code>CGLIB</code>之类。</p>\n<p>提到<code>CGLIB</code>我们很容易想到的就是代理。</p>\n<p>不过在java的动态代理的实现中，也是利用这种方法自动产生动态类加载进去的。</p>\n<h1 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h1><hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//声明一个接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Greeting</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sayWorld</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">implements</span> <span class=\"title\">Greeting</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sayWorld</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"world\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StudentInvocationHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object object;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">StudentInvocationHandler</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.object = o;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (method.getName().equals(<span class=\"string\">\"sayHello\"</span>)) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"beforeSayHello\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.getName().equals(<span class=\"string\">\"sayWorld\"</span>)) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"beforeSayWorld\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> method.invoke(object,args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Aop</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Student student = <span class=\"keyword\">new</span> Student();</span><br><span class=\"line\">        StudentInvocationHandler studentAop = <span class=\"keyword\">new</span> StudentInvocationHandler(student);</span><br><span class=\"line\">        Greeting greeting = (Greeting) Proxy.newProxyInstance(</span><br><span class=\"line\">                student.getClass().getClassLoader(),</span><br><span class=\"line\">                student.getClass().getInterfaces(),</span><br><span class=\"line\">                studentAop);</span><br><span class=\"line\">        greeting.sayHello();</span><br><span class=\"line\">        greeting.sayWorld();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果是</p>\n<p>beforeSayHello<br>hello<br>beforeSayWorld<br>world</p>\n<p>那么大概动态代理帮我们生成了什么代理类呢</p>\n<p>声明大概是这样</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyClass</span> <span class=\"keyword\">extends</span> <span class=\"title\">Students</span> <span class=\"keyword\">implements</span> <span class=\"title\">Greeting</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>并且把其中的每个方法的内容大概都改为了</p>\n<p><code>public Object invoke(Object proxy, Method method, Object[] args) throws Throwable</code></p>\n<p>的内容。</p>\n<h1 id=\"Proxy类\"><a href=\"#Proxy类\" class=\"headerlink\" title=\"Proxy类\"></a>Proxy类</h1><hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">newProxyInstance</span><span class=\"params\">(ClassLoader loader,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                      InvocationHandler h)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> IllegalArgumentException</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tClass&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class=\"line\"></span><br><span class=\"line\">   </span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> InvocationHandler ih = h;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class=\"line\">\t\t\tAccessController.doPrivileged(<span class=\"keyword\">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> Void <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t\t\t\tcons.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> cons.newInstance(<span class=\"keyword\">new</span> Object[]&#123;h&#125;);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">catch</span> ( ... ) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//...</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>进行了一些缩减，try里面的代码是对新的类进行了newInstance，所以在getProxyClass0中就已经生成好了新的代理类并进行了加载。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class=\"line\">                                           Class&lt;?&gt;... interfaces) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (interfaces.length &gt; <span class=\"number\">65535</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"interface limit exceeded\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的proxyClassCache，在类中定义为，保存的是代理Class的缓存</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class=\"line\">    proxyClassCache = <span class=\"keyword\">new</span> WeakCache&lt;&gt;(<span class=\"keyword\">new</span> KeyFactory(), <span class=\"keyword\">new</span> ProxyClassFactory());</span><br></pre></td></tr></table></figure>\n<p>简单说一下这个WeakCache的作用，在这儿之前，先看看new的两个类分别是做什么用的？</p>\n<p>先看KeyFactory<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 这个类是一个函数式类，实现了BiFunction，实现了apply方法</span></span><br><span class=\"line\"><span class=\"comment\"> * 其中Key1，Key2和KeyX类都是大概是下面这样，选取了KeyX</span></span><br><span class=\"line\"><span class=\"comment\"> * private final int hash;</span></span><br><span class=\"line\"><span class=\"comment\"> * private final WeakReference&lt;Class&lt;?&gt;&gt;[] refs;</span></span><br><span class=\"line\"><span class=\"comment\"> * KeyX(Class&lt;?&gt;[] interfaces) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     hash = Arrays.hashCode(interfaces);</span></span><br><span class=\"line\"><span class=\"comment\"> *     refs = (WeakReference&lt;Class&lt;?&gt;&gt;[])new WeakReference&lt;?&gt;[interfaces.length];</span></span><br><span class=\"line\"><span class=\"comment\"> *     for (int i = 0; i &lt; interfaces.length; i++) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     refs[i] = new WeakReference&lt;&gt;(interfaces[i]);</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * 就是说把构造参数整体取个Hash存在hash属性中，然后把每个interface都放到一个弱引用中</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果你知道java中的引用级别的话，就知道弱引用的对象只能活到下次gc前。</span></span><br><span class=\"line\"><span class=\"comment\"> * 其中key0是这么写的</span></span><br><span class=\"line\"><span class=\"comment\"> * private static final Object key0 = new Object();</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KeyFactory</span></span></span><br><span class=\"line\">    implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Object&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">apply</span><span class=\"params\">(ClassLoader classLoader, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (interfaces.length) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Key1(interfaces[<span class=\"number\">0</span>]); <span class=\"comment\">// the most frequent</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">2</span>: <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Key2(interfaces[<span class=\"number\">0</span>], interfaces[<span class=\"number\">1</span>]);</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">0</span>: <span class=\"keyword\">return</span> key0;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>: <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> KeyX(interfaces);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>再来看看ProxyClassFactory<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> *  这个类也是实现了一个函数式接口，实现了apply方法，最终的结果就是返回了我们要生成的代理类</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyClassFactory</span></span></span><br><span class=\"line\">    implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// prefix for all proxy class names</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String proxyClassNamePrefix = <span class=\"string\">\"$Proxy\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// next number to use for generation of unique proxy class names</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> AtomicLong nextUniqueNumber = <span class=\"keyword\">new</span> AtomicLong();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//返回代理类的class</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>看完了参数中的两个类，我们再看看看WeakCache到底怎么实现缓存的，因为直观上看，其实我们觉得这个缓存类非常复杂<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 我们还是具体问题具体分析，根据上面的构造</span></span><br><span class=\"line\"><span class=\"comment\"> * WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * K是ClassLoader， P是接口数组，V是要产生的代理类</span></span><br><span class=\"line\"><span class=\"comment\"> * 还是回到最原始的问题上来，既然我们知道这个是做缓存用的，那么最基本的肯定要是Map的key，value的格式</span></span><br><span class=\"line\"><span class=\"comment\"> * 根据这个最基本的点，我们来看是怎么做的</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WeakCache</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">P</span>, <span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 这个refQueue是用来保存</span></span><br><span class=\"line\"><span class=\"comment\">     * 在weak reference指向的对象被回收后, weak reference本身其实也就没有用了. </span></span><br><span class=\"line\"><span class=\"comment\">     * java提供了一个ReferenceQueue来保存这些所指向的对象已经被回收的reference. </span></span><br><span class=\"line\"><span class=\"comment\">     * 用法是在定义WeakReference的时候将一个ReferenceQueue的对象作为参数传入构函数.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReferenceQueue&lt;K&gt; refQueue</span><br><span class=\"line\">        = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">//这里是实际的缓存类，这里配备的是两级缓存</span></span><br><span class=\"line\">    <span class=\"comment\">//第一级就是对应的classLoader缓存</span></span><br><span class=\"line\">    <span class=\"comment\">//第二级是subKeyFactory.apply(key, parameter)产生的key</span></span><br><span class=\"line\">    <span class=\"comment\">//supplier#get返回的就是我们需要的代理类class</span></span><br><span class=\"line\">    <span class=\"comment\">//为什么需要按照classLoader来划分呢，因为双亲委派机制的存在</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentMap&lt;Object, ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt;&gt; map</span><br><span class=\"line\">        = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentMap&lt;Supplier&lt;V&gt;, Boolean&gt; reverseMap</span><br><span class=\"line\">        = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BiFunction&lt;K, P, ?&gt; subKeyFactory;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BiFunction&lt;K, P, V&gt; valueFactory;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//构造函数，我们传进去了</span></span><br><span class=\"line\">    <span class=\"comment\">//new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory());</span></span><br><span class=\"line\">    <span class=\"comment\">//如果你还记得，KeyFactory里面有个字段是对所有的接口做了hash</span></span><br><span class=\"line\">    <span class=\"comment\">//ProxyClassFactory是返回我们要生成的代理类</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WeakCache</span><span class=\"params\">(BiFunction&lt;K, P, ?&gt; subKeyFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                     BiFunction&lt;K, P, V&gt; valueFactory)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.subKeyFactory = Objects.requireNonNull(subKeyFactory);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.valueFactory = Objects.requireNonNull(valueFactory);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  WeakCache中还有几个静态内部类，CacheValue和CacheKey</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Value继承了Supplier接口，Supplier也是一个函数式接口，里面有一个get方法</span></span><br><span class=\"line\"><span class=\"comment\">     * public interface Supplier&lt;T&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">     *\t\tT get();</span></span><br><span class=\"line\"><span class=\"comment\">\t * &#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * CacheValue继承了WeakReference类，也就是弱引用。</span></span><br><span class=\"line\"><span class=\"comment\">     * 其中的hash值调用了System.identityHashCode</span></span><br><span class=\"line\"><span class=\"comment\">     * 这是个native方法，还是返回了hashcode，那为什么不直接调用hashcode方法呢，</span></span><br><span class=\"line\"><span class=\"comment\">     * 文档中写的是这个方法排除了这个类覆盖了hashcode方法，也就是调用了Object的hashcode方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Value</span>&lt;<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Supplier</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CacheValue</span>&lt;<span class=\"title\">V</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Value</span>&lt;<span class=\"title\">V</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;</span><br><span class=\"line\"></span><br><span class=\"line\">        CacheValue(V value) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(value);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.hash = System.identityHashCode(value); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> hash;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">            V value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> obj == <span class=\"keyword\">this</span> ||</span><br><span class=\"line\">                   obj <span class=\"keyword\">instanceof</span> Value &amp;&amp;</span><br><span class=\"line\">                   <span class=\"comment\">// cleared CacheValue is only equal to itself</span></span><br><span class=\"line\">                   (value = get()) != <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">                   value == ((Value&lt;?&gt;) obj).get(); <span class=\"comment\">// compare by identity</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * CacheKey也是继承了WeakReference方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CacheKey</span>&lt;<span class=\"title\">K</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">K</span>&gt; </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">// a replacement for null keys</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object NULL_KEY = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"keyword\">static</span> &lt;K&gt; <span class=\"function\">Object <span class=\"title\">valueOf</span><span class=\"params\">(K key, ReferenceQueue&lt;K&gt; refQueue)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> key == <span class=\"keyword\">null</span></span><br><span class=\"line\">                   <span class=\"comment\">// null key means we can't weakly reference it,</span></span><br><span class=\"line\">                   <span class=\"comment\">// so we use a NULL_KEY singleton as cache key</span></span><br><span class=\"line\">                   ? NULL_KEY</span><br><span class=\"line\">                   <span class=\"comment\">// non-null key requires wrapping with a WeakReference</span></span><br><span class=\"line\">                   : <span class=\"keyword\">new</span> CacheKey&lt;&gt;(key, refQueue);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">CacheKey</span><span class=\"params\">(K key, ReferenceQueue&lt;K&gt; refQueue)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(key, refQueue);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.hash = System.identityHashCode(key);  <span class=\"comment\">// compare by identity</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> hash;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">            K key;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> obj == <span class=\"keyword\">this</span> ||</span><br><span class=\"line\">                   obj != <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">                   obj.getClass() == <span class=\"keyword\">this</span>.getClass() &amp;&amp;</span><br><span class=\"line\">                   <span class=\"comment\">// cleared CacheKey is only equal to itself</span></span><br><span class=\"line\">                   (key = <span class=\"keyword\">this</span>.get()) != <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">                   <span class=\"comment\">// compare key by identity</span></span><br><span class=\"line\">                   key == ((CacheKey&lt;K&gt;) obj).get();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">expungeFrom</span><span class=\"params\">(ConcurrentMap&lt;?, ? extends ConcurrentMap&lt;?, ?&gt;&gt; map,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                         ConcurrentMap&lt;?, Boolean&gt; reverseMap)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// removing just by key is always safe here because after a CacheKey</span></span><br><span class=\"line\">            <span class=\"comment\">// is cleared and enqueue-ed it is only equal to itself</span></span><br><span class=\"line\">            <span class=\"comment\">// (see equals method)...</span></span><br><span class=\"line\">            ConcurrentMap&lt;?, ?&gt; valuesMap = map.remove(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            <span class=\"comment\">// remove also from reverseMap if needed</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (valuesMap != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (Object cacheValue : valuesMap.values()) &#123;</span><br><span class=\"line\">                    reverseMap.remove(cacheValue);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 来看看我们的get方法</span></span><br><span class=\"line\"><span class=\"comment\"> * 回忆一下我们是怎么调用它的</span></span><br><span class=\"line\"><span class=\"comment\"> * proxyClassCache.get(loader, interfaces);</span></span><br><span class=\"line\"><span class=\"comment\"> * key就是我们的classLoader， parameter是我们的接口数组</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(K key, P parameter)</span> </span>&#123;</span><br><span class=\"line\">    Objects.requireNonNull(parameter);</span><br><span class=\"line\">   </span><br><span class=\"line\">    expungeStaleEntries();</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//由于是第一次调用，所以new了一个新的cacheKey出来</span></span><br><span class=\"line\">    Object cacheKey = CacheKey.valueOf(key, refQueue);</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//由于是第一次调用，所以这里还是等于null</span></span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * 再来分析一下这个map</span></span><br><span class=\"line\"><span class=\"comment\">     * 这个map的声明是</span></span><br><span class=\"line\"><span class=\"comment\">     *  ConcurrentMap&lt;Object, ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt;&gt; map</span></span><br><span class=\"line\"><span class=\"comment\">     *                                               = new ConcurrentHashMap&lt;&gt;();</span></span><br><span class=\"line\"><span class=\"comment\">     * 这三个字段分别是什么意思呢，我们从下面的putIfAbsent()可以看出</span></span><br><span class=\"line\"><span class=\"comment\">     * 第一个就是CacheKey，是一个弱引用，下一次gc后不存在了</span></span><br><span class=\"line\"><span class=\"comment\">     * 第二个的key是subKeyFactory.apply(key, parameter)产生的keyX对象</span></span><br><span class=\"line\"><span class=\"comment\">     * 第二个的value就是产生我们代理类class的Supplier，其中的get方法返回的是代理类的class</span></span><br><span class=\"line\"><span class=\"comment\">     * 如果我们已经看了下面就会发现第二个value就是CacheValue，也是一个弱引用，下一次gc后不存在了</span></span><br><span class=\"line\"><span class=\"comment\">     * 那其实唯一的一个强引用就是keyX对象，但是keyX中的字段中的interfce[]数组还是弱引用的</span></span><br><span class=\"line\"><span class=\"comment\">     * 如果经历过一次gc，那唯一存在的就是keyX中的hash值，那其实还是一个过期值。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (valuesMap == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap</span><br><span class=\"line\">            = map.putIfAbsent(cacheKey,</span><br><span class=\"line\">                              valuesMap = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldValuesMap != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            valuesMap = oldValuesMap;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//这里利用KeyFactory返回了一个KeyX对象</span></span><br><span class=\"line\">    Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class=\"line\">    <span class=\"comment\">//得到class的supplier</span></span><br><span class=\"line\">    Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class=\"line\">    Factory factory = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//这里是个循环，循环退出的条件是supplier.get()返回一个非null的值，这个值就是我们代理类的class</span></span><br><span class=\"line\">    <span class=\"comment\">//这里的设计是考虑了并发的情况的</span></span><br><span class=\"line\">    <span class=\"comment\">//factory的get方法是用来计算出class文件，然后放到缓存中</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (supplier != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果得到了value，那么就返回</span></span><br><span class=\"line\">            <span class=\"comment\">//这里有两种情况</span></span><br><span class=\"line\">            <span class=\"comment\">//第一种就是已经在缓存中了，所以直接返回就好</span></span><br><span class=\"line\">            <span class=\"comment\">//第二种就是缓存中没有它，这里的supplier其实已经被替换成了一个Factory(见下面的代码)</span></span><br><span class=\"line\">            <span class=\"comment\">//然后调用factory的get方法同步得到一个class</span></span><br><span class=\"line\">            V value = supplier.get();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (value != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">//懒加载一个Factory</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (factory == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            factory = <span class=\"keyword\">new</span> Factory(key, parameter, subKey, valuesMap);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//反复检查supplier是不是空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (supplier == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            supplier = valuesMap.putIfAbsent(subKey, factory);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (supplier == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                supplier = factory;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (valuesMap.replace(subKey, supplier, factory)) &#123;</span><br><span class=\"line\">                supplier = factory;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//如果已经有线程进行了处理并加到了缓存中</span></span><br><span class=\"line\">                supplier = valuesMap.get(subKey);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下面看看Factory到底实现了什么<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 从上面用法看这个Factory最终赋给了Supplier，所以这个类也是提供代理类class的</span></span><br><span class=\"line\"><span class=\"comment\"> * 不过这个类的get方法比较特殊，是个同步方法</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Factory</span> <span class=\"keyword\">implements</span> <span class=\"title\">Supplier</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> P parameter;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object subKey;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap;</span><br><span class=\"line\">   </span><br><span class=\"line\">    Factory(K key, P parameter, Object subKey,</span><br><span class=\"line\">            ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.parameter = parameter;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.subKey = subKey;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.valuesMap = valuesMap;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"comment\">//这个get方法是个同步的方法，用来保证在多线程环境下的并发安全</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> V <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">        <span class=\"comment\">//再次检查一遍，这样第二个往后进来的线程就可以直接返回，得到缓存中的值</span></span><br><span class=\"line\">        <span class=\"comment\">//避免重复计算</span></span><br><span class=\"line\">        Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (supplier != <span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//现在supplier == this</span></span><br><span class=\"line\">        V value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//这里产生新的代理类class</span></span><br><span class=\"line\">            value = Objects.requireNonNull(valueFactory.apply(key, parameter));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">                <span class=\"comment\">//如果value还是null，说明出现了失败</span></span><br><span class=\"line\">                valuesMap.remove(subKey, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//还是检查一遍value不为空</span></span><br><span class=\"line\">        <span class=\"keyword\">assert</span> value != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">//把代理类class包装进CacheValue中</span></span><br><span class=\"line\">        CacheValue&lt;V&gt; cacheValue = <span class=\"keyword\">new</span> CacheValue&lt;&gt;(value);</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (valuesMap.replace(subKey, <span class=\"keyword\">this</span>, cacheValue)) &#123;</span><br><span class=\"line\">            reverseMap.put(cacheValue, Boolean.TRUE);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError(<span class=\"string\">\"Should not reach here\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>那是怎么处理过期的缓存呢，就是被gc收集走的那些缓存</p>\n<p>在WeakCache#get中还执行了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expungeStaleEntries();</span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果你还记得在WeakCache中有个对象是</span></span><br><span class=\"line\"><span class=\"comment\"> * private final ReferenceQueue&lt;K&gt; refQueue = new ReferenceQueue&lt;&gt;();</span></span><br><span class=\"line\"><span class=\"comment\"> * 因为弱引用在下一次gc后被回收，那么那些指向对象的引用，就会被放到这个queue中</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">expungeStaleEntries</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        CacheKey&lt;K&gt; cacheKey;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((cacheKey = (CacheKey&lt;K&gt;)refQueue.poll()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            cacheKey.expungeFrom(map, reverseMap);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//CacheKey方法中，把自己从map中移除</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">expungeFrom</span><span class=\"params\">(ConcurrentMap&lt;?, ? extends ConcurrentMap&lt;?, ?&gt;&gt; map,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                         ConcurrentMap&lt;?, Boolean&gt; reverseMap)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// removing just by key is always safe here because after a CacheKey</span></span><br><span class=\"line\">            <span class=\"comment\">// is cleared and enqueue-ed it is only equal to itself</span></span><br><span class=\"line\">            <span class=\"comment\">// (see equals method)...</span></span><br><span class=\"line\">            ConcurrentMap&lt;?, ?&gt; valuesMap = map.remove(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            <span class=\"comment\">// remove also from reverseMap if needed</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (valuesMap != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (Object cacheValue : valuesMap.values()) &#123;</span><br><span class=\"line\">                    reverseMap.remove(cacheValue);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>至此，分析都差不多了，下面看看到底是怎么生成字节码的，在ProxyClassFactory的apply方法中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class=\"keyword\">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * Verify that the class loader resolves the name of this</span></span><br><span class=\"line\"><span class=\"comment\">         * interface to the same Class object.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        Class&lt;?&gt; interfaceClass = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            interfaceClass = Class.forName(intf.getName(), <span class=\"keyword\">false</span>, loader);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (interfaceClass != intf) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(</span><br><span class=\"line\">                intf + <span class=\"string\">\" is not visible from class loader\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * Verify that the Class object actually represents an</span></span><br><span class=\"line\"><span class=\"comment\">         * interface.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(</span><br><span class=\"line\">                interfaceClass.getName() + <span class=\"string\">\" is not an interface\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * Verify that this interface is not a duplicate.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(</span><br><span class=\"line\">                <span class=\"string\">\"repeated interface: \"</span> + interfaceClass.getName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    String proxyPkg = <span class=\"keyword\">null</span>;     <span class=\"comment\">// package to define proxy class in</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Record the package of a non-public proxy interface so that the</span></span><br><span class=\"line\"><span class=\"comment\">     * proxy class will be defined in the same package.  Verify that</span></span><br><span class=\"line\"><span class=\"comment\">     * all non-public proxy interfaces are in the same package.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> flags = intf.getModifiers();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class=\"line\">            accessFlags = Modifier.FINAL;</span><br><span class=\"line\">            String name = intf.getName();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> n = name.lastIndexOf(<span class=\"string\">'.'</span>);</span><br><span class=\"line\">            String pkg = ((n == -<span class=\"number\">1</span>) ? <span class=\"string\">\"\"</span> : name.substring(<span class=\"number\">0</span>, n + <span class=\"number\">1</span>));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (proxyPkg == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                proxyPkg = pkg;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(</span><br><span class=\"line\">                    <span class=\"string\">\"non-public interfaces from different packages\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (proxyPkg == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// if no non-public proxy interfaces, use com.sun.proxy package</span></span><br><span class=\"line\">        proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class=\"string\">\".\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Choose a name for the proxy class to generate.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class=\"line\">    String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Generate the specified proxy class.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class=\"line\">        proxyName, interfaces, accessFlags);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> defineClass0(loader, proxyName,</span><br><span class=\"line\">                            proxyClassFile, <span class=\"number\">0</span>, proxyClassFile.length);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ClassFormatError e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * A ClassFormatError here means that (barring bugs in the</span></span><br><span class=\"line\"><span class=\"comment\">         * proxy class generation code) there was some other</span></span><br><span class=\"line\"><span class=\"comment\">         * invalid aspect of the arguments supplied to the proxy</span></span><br><span class=\"line\"><span class=\"comment\">         * class creation (such as virtual machine limitations</span></span><br><span class=\"line\"><span class=\"comment\">         * exceeded).</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(e.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>主要方法在ProxyGenerator#generateProxyClass方法中，返回的是一个二进制的class流byte[ ]</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyGenerator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">byte</span>[] generateProxyClass(<span class=\"keyword\">final</span> String var0, Class&lt;?&gt;[] var1, <span class=\"keyword\">int</span> var2) &#123;</span><br><span class=\"line\">        ProxyGenerator var3 = <span class=\"keyword\">new</span> ProxyGenerator(var0, var1, var2);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span>[] var4 = var3.generateClassFile();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (saveGeneratedFiles) &#123;</span><br><span class=\"line\">            AccessController.doPrivileged(<span class=\"keyword\">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> Void <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> var1 = var0.lastIndexOf(<span class=\"number\">46</span>);</span><br><span class=\"line\">                        Path var2;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (var1 &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                            Path var3 = Paths.get(var0.substring(<span class=\"number\">0</span>, var1).replace(<span class=\"string\">'.'</span>, File.separatorChar));</span><br><span class=\"line\">                            Files.createDirectories(var3);</span><br><span class=\"line\">                            var2 = var3.resolve(var0.substring(var1 + <span class=\"number\">1</span>, var0.length()) + <span class=\"string\">\".class\"</span>);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            var2 = Paths.get(var0 + <span class=\"string\">\".class\"</span>);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        Files.write(var2, var4, <span class=\"keyword\">new</span> OpenOption[<span class=\"number\">0</span>]);</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (IOException var4x) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InternalError(<span class=\"string\">\"I/O exception saving generated file: \"</span> + var4x);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> var4;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面就不进行赘述了。</p>\n","categories":["Java源码解读"],"tags":["Java","动态代理"]},{"title":"同步，阻塞，非阻塞","url":"https://blog.lovezhy.cc/2017/08/20/IO之同步，阻塞，非阻塞/","content":"<h1 id=\"同步，阻塞，非阻塞\"><a href=\"#同步，阻塞，非阻塞\" class=\"headerlink\" title=\"同步，阻塞，非阻塞\"></a>同步，阻塞，非阻塞</h1><hr>\n<p>先来谈谈这个。<br>很多人一直搞不清，从概念上去解释的话，我也很难解释清楚。<br>不过知乎上有个回答很nice。我引用过来。  </p>\n<a id=\"more\"></a>\n<p><a href=\"https://www.zhihu.com/question/19732473\" target=\"_blank\" rel=\"noopener\">同步异步，阻塞非阻塞的区别</a></p>\n<p>正常的来说，一段数据流从网络到我们自己设定的数组中，需要经历以下几个阶段</p>\n<ul>\n<li>数据到端口</li>\n<li>内核把数据从端口拷贝到内核缓存区</li>\n<li>用户调用read让内核把缓存区的数据拷贝到我们设定的数组中</li>\n</ul>\n<p>同步和异步的区别在实际中就是用户和内核的交互上。<br>同步的话就是我们主动的问内核数据来了吗，数据准备好了吗，如果内核高速我们数据已经到缓冲区了，我们还需要自己再去把缓冲区的数据拷过来。  </p>\n<p>异步就是内核把数据准备好了，拷贝到了用户空间后，之后主动调用我们设置的回掉函数。</p>\n<p>阻塞和非阻塞在实际中是用户线程的IO和内核交互上。<br>阻塞就是我们写或者读内核数据时必须等待全部写完或者必须有数据让我们读到。<br>非阻塞是指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成。 </p>\n<p>下面结合代码来看看常用的IO模型是什么架构的。</p>\n<h1 id=\"阻塞IO\"><a href=\"#阻塞IO\" class=\"headerlink\" title=\"阻塞IO\"></a>阻塞IO</h1><hr>\n<p>同步阻塞模型其实最常见也是最容易理解的。<br>无论在<code>Java</code>还是<code>c</code>的网络编程中都是<code>bind</code> -&gt; <code>listen</code> -&gt; <code>accept</code>。</p>\n<p>下面是一个简单的<code>echo</code>程序，把接收到的返回回去。  </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netinet/in.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BACKLOG 1024</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BUFFERSIZE 8192</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> server_fd, conn_fd;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> port = <span class=\"number\">1080</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">addr_s</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">addr_c</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">//AF_INET ipv4</span></span><br><span class=\"line\">\t<span class=\"comment\">//SOCK_STREAM 以流的方式传递</span></span><br><span class=\"line\">\tserver_fd = socket(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;addr_s, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(addr_c));</span><br><span class=\"line\">    addr_s.sin_family = AF_INET;</span><br><span class=\"line\">    addr_s.sin_addr.s_addr = inet_addr(<span class=\"string\">\"127.0.0.1\"</span>);</span><br><span class=\"line\">    addr_s.sin_port = htons(port);</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = bind(server_fd, (struct sockaddr*)&amp;addr_s, <span class=\"keyword\">sizeof</span>(addr_c));</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">char</span> buffer[BUFFERSIZE];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> addr_clen = <span class=\"keyword\">sizeof</span>(addr_c);</span><br><span class=\"line\">    listen(server_fd, BACKLOG);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t    conn_fd = accept(server_fd, (struct sockaddr*)&amp;addr_c, (<span class=\"keyword\">socklen_t</span> *) &amp;addr_clen);</span><br><span class=\"line\">\t    <span class=\"keyword\">int</span> size = read(conn_fd, buffer, <span class=\"number\">8192</span>);</span><br><span class=\"line\">\t    write(conn_fd, buffer, size);</span><br><span class=\"line\">\t    close(conn_fd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的<code>while(1)</code>中，如果没有连接，那么程序就一直等待<code>accept</code>，直到有一个连接产生。   </p>\n<p>等到有一个连接到了，然后去调用<code>read</code>和<code>write</code>函数去响应这个请求。  </p>\n<p>但是在处理这个<code>read</code>的时候如果对方一直没有输入，那么<code>read</code>就会一直等下去。<br>那么<code>read</code>的行为就是阻塞。  </p>\n<p>同样的，对于<code>write</code>，如果发送缓冲区没有空间或者空间不足的话，write操作会直接阻塞住等待有足够的空间。 </p>\n<p>假设第一个连接停在了<code>read</code>或者<code>write</code>，那么下面的连接就无法进行处理了。</p>\n<p>所以一般会进行<code>fork</code>调用去处理请求。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(fork() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\tclose(server_fd);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> size = read(conn_fd, buffer, <span class=\"number\">8192</span>);</span><br><span class=\"line\">\tsend(conn_fd, buffer, size, <span class=\"number\">0</span>);</span><br><span class=\"line\">\tclose(conn_fd);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样可以处理小批量的并发请求，但是大了就不行了。<br>因为<code>linux</code>进程是需要资源，相对来说开销较大。<br>就像<code>Java</code>中对每一个请求都开一个线程去处理一样。  </p>\n<h1 id=\"非阻塞IO\"><a href=\"#非阻塞IO\" class=\"headerlink\" title=\"非阻塞IO\"></a>非阻塞IO</h1><p>上面提到阻塞IO的问题在<code>read</code>和<code>write</code>函数。  </p>\n<p>在<code>linux</code>或者<code>mac</code>下有一个系统调用。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fcntl</span><span class=\"params\">(<span class=\"keyword\">int</span> fildes, <span class=\"keyword\">int</span> cmd, ...)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>使用这个我们可以改变文件描述符的性质。<br>比如使它成为非阻塞的。   </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">set_no_blocking</span><span class=\"params\">(<span class=\"keyword\">int</span> fd)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> flags;</span><br><span class=\"line\">    <span class=\"comment\">//先得到文件描述符原有的属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((flags = fcntl(fd, F_GETFL, <span class=\"number\">0</span>)) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        log_err(<span class=\"string\">\"fcntl error\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//增加非阻塞属性</span></span><br><span class=\"line\">    flags |= O_NONBLOCK;</span><br><span class=\"line\">    <span class=\"comment\">//设置非阻塞属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fcntl(fd, F_SETFL, flags) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        log_err(<span class=\"string\">\"fcntl error\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样设置之后，<code>read</code>调用会立即返回。接收缓冲区中有数据时，与阻塞socket有数据的情况是一样的。</p>\n<p>如果接收缓冲区中没有数据，则返回错误号为EWOULDBLOCK,表示该操作本来应该阻塞的，但是由于本socket为非阻塞的socket，因此立刻返回，遇到这样的情况，可以在下次接着去尝试读取。</p>\n<p>如果返回值是其它负值，则表明读取错误。。  </p>\n<p>write也会立即返回。<br>在发送缓冲区没有空间时会直接返回错误号EWOULDBLOCK,表示没有空间可写数据。<br>如果错误号是别的值，则表明发送失败。<br>如果发送缓冲区中有足够空间或者是不足以拷贝所有待发送数据的空间的话，则拷贝前面N个能够容纳的数据，返回实际拷贝的字节数。  </p>\n<h1 id=\"IO复用\"><a href=\"#IO复用\" class=\"headerlink\" title=\"IO复用\"></a>IO复用</h1><hr>\n<p>异步的最普遍的实现方式是回调。<br>但是有回掉的并不就是异步的。 </p>\n<p>比如Libevent中事件回调，还有netty。</p>\n<p>下面选自我的tinyhttp仓库，<a href=\"https://github.com/zhyzhyzhy/tinyhttp\" target=\"_blank\" rel=\"noopener\">地址</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Created by zhy on 2/20/17.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span>* index_home = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_base</span> *<span class=\"title\">base</span>;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    argv[<span class=\"number\">1</span>] = <span class=\"string\">\"127.0.0.1\"</span>;</span><br><span class=\"line\">    argv[<span class=\"number\">2</span>] = <span class=\"string\">\"4000\"</span>;</span><br><span class=\"line\">    argv[<span class=\"number\">3</span>] = <span class=\"string\">\"/Users/zhuyichen/fortest/tinydemo/v3.bootcss.com/\"</span>;</span><br><span class=\"line\">    index_home = argv[<span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (chdir(index_home) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"index_home : \"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> listener;</span><br><span class=\"line\">    listener = socket_bind_listen(argv[<span class=\"number\">1</span>], argv[<span class=\"number\">2</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (listener == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    set_no_blocking(listener);</span><br><span class=\"line\">    log_info(<span class=\"string\">\"start listen in host %s port %s ...\\n\"</span>, argv[<span class=\"number\">1</span>], argv[<span class=\"number\">2</span>]);</span><br><span class=\"line\">  </span><br><span class=\"line\">    base = event_base_new();</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event</span>* <span class=\"title\">ev_listen</span> = <span class=\"title\">event_new</span>(<span class=\"title\">base</span>, <span class=\"title\">listener</span>, <span class=\"title\">EV_READ</span> | <span class=\"title\">EV_PERSIST</span>, <span class=\"title\">on_accept</span>, <span class=\"title\">NULL</span>);</span></span><br><span class=\"line\">    event_base_set(base, ev_listen);</span><br><span class=\"line\">    event_add(ev_listen, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    event_base_dispatch(base);</span><br><span class=\"line\">    event_base_free(base);</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">on_accept</span><span class=\"params\">(<span class=\"keyword\">int</span> serverfd, <span class=\"keyword\">short</span> events, <span class=\"keyword\">void</span> *arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> connfd = accept(serverfd, <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    set_no_blocking(connfd);</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重点在以下代码中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event</span>* <span class=\"title\">ev_listen</span> = <span class=\"title\">event_new</span>(<span class=\"title\">base</span>, <span class=\"title\">listener</span>, <span class=\"title\">EV_READ</span> | <span class=\"title\">EV_PERSIST</span>, <span class=\"title\">on_accept</span>, <span class=\"title\">NULL</span>);</span></span><br><span class=\"line\">event_base_set(base, ev_listen);</span><br><span class=\"line\">event_add(ev_listen, <span class=\"literal\">NULL</span>);</span><br></pre></td></tr></table></figure>\n<p>我们创建了一个<code>ev_listen</code>事件用来监听<code>socket</code>描述符上的<code>READ</code>事件,设置回调函数为<code>on_accept</code>。<br>这样只要<code>listener</code>文件句柄上产生了新的连接，就是回调<code>on_accept</code>函数，在<code>on_accept</code>函数中进行<code>accept</code>。  </p>\n<p>这就是一个异步的例子。</p>\n<p>很多人以为这就是异步，但是上面我们提到，异步的特点就是，操作系统会自己把数据从内核缓冲区拷贝到用户区，仔细看就会发现，libevent还是需要我们自己去进行read的，只是我们read的时候不会遇到缓冲区为空的情况，说到底，还是同步的读。</p>\n<h1 id=\"同步IO\"><a href=\"#同步IO\" class=\"headerlink\" title=\"同步IO\"></a>同步IO</h1><hr>\n<p>我们再来谈谈同步的IO。<br>其实同步异步非阻塞并不是相互独立的<br>我们说同步就是内核的数据是否准备好需要我们自己去询问和如果准备好了还是需要我们自己去拷贝到用户空间。<br>按照这个条件，其实前两种阻塞IO和非阻塞IO和IO复用都是同步IO。<br>包括<code>select</code> <code>poll</code> <code>epoll</code>函数，都是同步的，因为我们还是需要自己区拷贝数据到用户空间。<br>真正的异步IO这一层是系统帮我们做的。  </p>\n","categories":["编程随想"],"tags":["Network"]},{"title":"Java泛型","url":"https://blog.lovezhy.cc/2017/08/09/Java泛型数组/","content":"<h3 id=\"Java泛型的实现\"><a href=\"#Java泛型的实现\" class=\"headerlink\" title=\"Java泛型的实现\"></a>Java泛型的实现</h3><p>提到Java的泛型一般人都会想到类型擦除(Type Erasure)机制。<br>如果你没想到，请去补一补。。。。  </p>\n<a id=\"more\"></a>\n<h3 id=\"创建泛型数组\"><a href=\"#创建泛型数组\" class=\"headerlink\" title=\"创建泛型数组\"></a>创建泛型数组</h3><p>Java不允许创建泛型数组 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello&lt;String&gt;[] hello = <span class=\"keyword\">new</span> Hello&lt;String&gt;[<span class=\"number\">12</span>];</span><br></pre></td></tr></table></figure>\n<p>这句话是编译不通过的。 </p>\n<p>答案有点让人失望的简单，因为数组必须知道里面的元素是什么。 </p>\n<p>但是这句话很误导人<br>真的不允许创建我们想要的泛型数组么，那种可以编译时检查的泛型数组。<br>答案是可以的，不过得通过一些技巧。</p>\n<p>好，那么怎么创建呢。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;String&gt;[] lists = (List&lt;String&gt;[])<span class=\"keyword\">new</span> ArrayList[<span class=\"number\">12</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是其中之一的方法，可能有人觉得这样和  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List[] lists = <span class=\"keyword\">new</span> ArrayList[<span class=\"number\">12</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>没有区别。</p>\n<p>划重点！！！！！<br>第一种方法相对于第二种方法还是具有编译时类型检查的。  </p>\n<h3 id=\"泛型类中的泛型数组\"><a href=\"#泛型类中的泛型数组\" class=\"headerlink\" title=\"泛型类中的泛型数组\"></a>泛型类中的泛型数组</h3><p>怎么在范型类中创建泛型数组呢  </p>\n<p>其实第一来说没必要， 比如在ArrayList中维护的底层的数组是Object数组。  </p>\n<p>如果你硬是想创建，可以这样</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T[] arr = (T[])<span class=\"keyword\">new</span> Object[<span class=\"number\">12</span>];</span><br></pre></td></tr></table></figure>\n<p>很多人或许觉得奇怪为什么，这不是向上转型么。   </p>\n<p>然后举出例子为什么</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt;[] list = (List&lt;String&gt;[])<span class=\"keyword\">new</span> Object[<span class=\"number\">10</span>];</span><br></pre></td></tr></table></figure>\n<p>这种就不行。</p>\n<p>答案还是Java泛型实现的核心类型擦除。<br>在编译时</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T[] arr = (T[])<span class=\"keyword\">new</span> Object[<span class=\"number\">12</span>];</span><br><span class=\"line\"><span class=\"comment\">//会变成</span></span><br><span class=\"line\"><span class=\"comment\">//Object[] arr = (Object[])new Object[12];</span></span><br></pre></td></tr></table></figure>\n<p>这样就是毫无问题。</p>\n<h3 id=\"协变，逆变\"><a href=\"#协变，逆变\" class=\"headerlink\" title=\"协变，逆变\"></a>协变，逆变</h3><p>协变和逆变</p>\n<p>当A是B的子类时,如果有f(A)也是f(B)的子类,那么f叫做协变；<br>当A是B的子类时,如果有f(B)是f(A)的子类,那么f叫做逆变；</p>\n<p>数组是协变的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Genetic &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Fruit[] fruits;</span><br><span class=\"line\">        Apple[] apples = new Apple[10];</span><br><span class=\"line\">        fruits = apples;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Apple extends Fruit &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Fruit &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码能编译通过。</p>\n<p>但是这一段就不行了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Genetic</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Fruit&gt; list;</span><br><span class=\"line\">        List&lt;Apple&gt; list1 = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        list = list1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Apple</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fruit</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fruit</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>就是说List<fruit>和List<apple>没有关系。  </apple></fruit></p>\n<p>java通过通配符解决这个问题，还是上面的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Genetic</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;? extends Fruit&gt; list;</span><br><span class=\"line\">        List&lt;Apple&gt; list1 = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        list = list1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Apple</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fruit</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fruit</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>extends解决了协变的问题，逆变通过super解决。</p>\n<p>但是，没有那么简单。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Genetic</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;? extends Fruit&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;Apple&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//这句话并不能通过编译</span></span><br><span class=\"line\">        <span class=\"comment\">//list.add(new Apple());</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Apple</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fruit</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fruit</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&lt;? extends Fruit&gt;不是表示里面的元素只要是Fruit的子类就行，而是加入的元素必须可以向上转型为Fruit的任意一个子类。<br>那么大概只有null可以add了。</p>\n<p>同样的&lt;? super Fruit&gt;表示里面元素可以转型为Fruid的任意一个父类。</p>\n<p>要想可以编译通过，我们可以使用super </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Genetic</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;? <span class=\"keyword\">super</span> Fruit&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> Apple());</span><br><span class=\"line\">        <span class=\"comment\">//ok</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Apple</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fruit</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fruit</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那到底应该什么时候用super和extends呢。<br>Effective Java中总结了一个原则</p>\n<p><code>producer-extends, consumer-super</code></p>\n<p>看看ArrayList的源码就知道了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">     Object[] a = c.toArray();</span><br><span class=\"line\">     <span class=\"keyword\">int</span> numNew = a.length;</span><br><span class=\"line\">     ensureCapacityInternal(size + numNew);  <span class=\"comment\">// Increments modCount</span></span><br><span class=\"line\">     System.arraycopy(a, <span class=\"number\">0</span>, elementData, size, numNew);</span><br><span class=\"line\">     size += numNew;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> numNew != <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">forEach</span><span class=\"params\">(Consumer&lt;? <span class=\"keyword\">super</span> E&gt; action)</span> </span>&#123;</span><br><span class=\"line\">    Objects.requireNonNull(action);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> expectedModCount = modCount;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">final</span> E[] elementData = (E[]) <span class=\"keyword\">this</span>.elementData;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> size = <span class=\"keyword\">this</span>.size;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class=\"line\">        action.accept(elementData[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (modCount != expectedModCount) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["Java基础"],"tags":["Java"]},{"title":"Java内部类","url":"https://blog.lovezhy.cc/2017/08/05/Java内部类/","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>最近看《Java编程思想》，看了内部类的讲解，发现自己好多都没听过或者没注意到。   </p>\n<a id=\"more\"></a> \n<h3 id=\"指向外部类的指针\"><a href=\"#指向外部类的指针\" class=\"headerlink\" title=\"指向外部类的指针\"></a>指向外部类的指针</h3><p>每个内部类都有一个隐藏的外部类的<code>this</code>指针，可以通过<code>Outer.this</code>获得  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String message = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getMessage</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Inner</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            System.out.println(Main.<span class=\"keyword\">this</span>.getMessage());</span><br><span class=\"line\">            System.out.println(getMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Main main = <span class=\"keyword\">new</span> Main();</span><br><span class=\"line\">        Main.Inner inner = main.new Inner();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个例子看其实意义不大，因为函数<code>getMessage()</code>没有歧义。<br>如果Inner中也有个<code>getMessage()</code>，那么调用的就是<code>Inner</code>中的，这里<code>this</code>指针就派上用场了。</p>\n<p>题外话，在《Java并发编程实战》33页页提到了这个隐藏指针，如果把对象逸出，那么可能出现为构造未完全就调用了方法。比如下面（抱歉写的有点臃肿）。。。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Escape</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doSome</span><span class=\"params\">(Some some)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Some</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Demo demo;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printI</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        demo.printI();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Demo</span><span class=\"params\">(Escape escape)</span> </span>&#123;</span><br><span class=\"line\">        escape.doSome(<span class=\"keyword\">new</span> Some() &#123;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.demo = Demo.<span class=\"keyword\">this</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">  </span><br><span class=\"line\">        i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printI</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Escape escape = <span class=\"keyword\">new</span> Escape() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSome</span><span class=\"params\">(Some some)</span> </span>&#123;</span><br><span class=\"line\">                some.printI();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        Demo demo = <span class=\"keyword\">new</span> Demo(escape);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Demo</code>构造完应该<code>i = 1</code><br>但是这里调用过之后却是输出了<code>0</code><br>这就是内部类是对象隐藏指针逸出导致得到了未构造完全的对象。</p>\n<h3 id=\"返回private内部类\"><a href=\"#返回private内部类\" class=\"headerlink\" title=\"返回private内部类\"></a>返回private内部类</h3><p>正常类的来说，只能是public或者缺省的，不可以是private的。<br>但是内部类可以是public，priavte， protected或者缺省的。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Innter</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Innter <span class=\"title\">getInnerInstence</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Innter();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Demo demo = <span class=\"keyword\">new</span> Demo();</span><br><span class=\"line\">        <span class=\"comment\">//下面是不可以的，因为Inner是private的</span></span><br><span class=\"line\">        <span class=\"comment\">//Demo.Inner inner = demo.getInnerInstence();</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>作为一种折中的方法，我们可以申明一个接口来解决这个问题</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ForTest</span></span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Innter</span> <span class=\"keyword\">implements</span> <span class=\"title\">ForTest</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Innter <span class=\"title\">getInnerInstence</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Innter();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Demo demo = <span class=\"keyword\">new</span> Demo();</span><br><span class=\"line\">        ForTest inner = demo.getInnerInstence();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"普通内部类不能有static方法和实例变量\"><a href=\"#普通内部类不能有static方法和实例变量\" class=\"headerlink\" title=\"普通内部类不能有static方法和实例变量\"></a>普通内部类不能有static方法和实例变量</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner</span> </span>&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">//Inner classes cannot have static declarations</span></span><br><span class=\"line\">        <span class=\"comment\">//public static String message = \"hello\";</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h3><p>如果你想要内部类可以用<code>static</code>，那么可以使用静态内部类。<br>但是静态内部类没有对外部类的引用了。就像是完全的独立的一个类。<br>创建静态内部类的时候也不需要先创建外部类了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String message = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Inner</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        \t<span class=\"comment\">//Non-static field 'name' cannot be referenced from a static context</span></span><br><span class=\"line\">            <span class=\"comment\">//System.out.println(name);</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"匿名类的构造\"><a href=\"#匿名类的构造\" class=\"headerlink\" title=\"匿名类的构造\"></a>匿名类的构造</h3><p>匿名类因为没有类名，所以构造函数没法重新定义，不过可以用<code>{}</code>包裹起来作为构造函数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Main</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Main <span class=\"title\">getMain</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Main(name)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//报错</span></span><br><span class=\"line\">            <span class=\"comment\">//public Main()&#123;&#125;</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"name is\"</span> + name);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"内部类的构造参数\"><a href=\"#内部类的构造参数\" class=\"headerlink\" title=\"内部类的构造参数\"></a>内部类的构造参数</h3><p>如果想要在内部类中使用其他的对象，必须是<code>final</code>的或者<code>effectively final</code>的，也就是说不允许内部类修改外界的对象。<br>什么是<code>effectively final</code>呢，就是如果你在内部类内部没有修改这个参数，那么<code>jvm</code>就默认这个是<code>final</code>的，不需要显式的加<code>final</code>关键词了。<br>是在<code>Java8</code>中引入的，有点像语法糖。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Main</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Main <span class=\"title\">getMain</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Main(name)&#123;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">            \t<span class=\"comment\">//variable 'name' is accessed from within inner class, need to be final or effectively final</span></span><br><span class=\"line\">                name = <span class=\"string\">\"lll\"</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>显然我们想知道为什么呢？<br><a href=\"https://stackoverflow.com/questions/4732544/why-are-only-final-variables-accessible-in-anonymous-class\" target=\"_blank\" rel=\"noopener\">stackoverflow的答案</a></p>\n<h3 id=\"接口中的内部类\"><a href=\"#接口中的内部类\" class=\"headerlink\" title=\"接口中的内部类\"></a>接口中的内部类</h3><p>接口中定义的方法默认是<code>public</code>的，<br>接口中定义的类默认是<code>static</code>的。</p>\n<h3 id=\"静态内部类作为测试\"><a href=\"#静态内部类作为测试\" class=\"headerlink\" title=\"静态内部类作为测试\"></a>静态内部类作为测试</h3><p>一般我们会为每个类做一个main方法进行一些简单的测试。<br>但是这样编译过之后，class文件中还是有main方法的，占用了空间。<br>我们可以使用静态内部类作为测试，因为编译过后静态内部类会生成一个单独的class文件，<br>生产环境中可以不把它包含进去。</p>\n<p>我觉得没啥用，因为不止静态内部类，普通内部类和匿名类也会单独生成一个class文件。<br>生产环境中一个一个删除不是傻逼吗。。。</p>\n<h3 id=\"为什么要引入内部类\"><a href=\"#为什么要引入内部类\" class=\"headerlink\" title=\"为什么要引入内部类\"></a>为什么要引入内部类</h3><p>作为不能多继承的补充<br>好有道理</p>\n<h3 id=\"继承内部类\"><a href=\"#继承内部类\" class=\"headerlink\" title=\"继承内部类\"></a>继承内部类</h3><p>因为内部类拥有外部类的引用，所以继承的时候要有点技巧。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner</span></span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> <span class=\"keyword\">extends</span> <span class=\"title\">Demo</span>.<span class=\"title\">Inner</span></span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"comment\">//构造函数只能这么写。。。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Main</span><span class=\"params\">(Demo demo)</span> </span>&#123;</span><br><span class=\"line\">        demo.<span class=\"keyword\">super</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">          </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"内部类重写\"><a href=\"#内部类重写\" class=\"headerlink\" title=\"内部类重写\"></a>内部类重写</h3><p>内部类可以向方法一样重写吗并进行多态吗<br>不行</p>\n","categories":["Java基础"],"tags":["Java"]},{"title":"Libevent简单使用","url":"https://blog.lovezhy.cc/2017/08/02/libevent简单使用/","content":"<p>最近想要自己写一个简单的<code>http server</code>，因为之前的那个是<code>epoll</code>的，只能运行在<code>linux</code>平台上。<br>于是我便找到了平台通用的<code>libevent</code>。  </p>\n<p><code>libevent</code>是事件驱动的，支持异步的网络框架。  </p>\n<p>十分值得学习。</p>\n<a id=\"more\"></a>\n<p>由于基于<code>reactor</code>模型，所以事件抽象为<code>event</code>，<code>event loop</code>是<code>reactor</code>，<code>event handler</code>是各种回调函数。</p>\n<p><code>struct event</code><br>要创建<code>event</code>一般使用<code>event_new</code>函数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct event *<span class=\"title\">event_new</span><span class=\"params\">(struct event_base *base, <span class=\"keyword\">evutil_socket_t</span> fd,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">short</span> what, event_callback_fn cb, <span class=\"keyword\">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure>\n<p><code>base</code>参数是我们要把这个事件绑定的<code>event loop</code>，<br><code>fd</code>就是<code>socket fd</code>，只不过为了统一windows，重新定义了一下<br><code>what</code>是触发事件，<br>选项是下面的或</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> EV_TIMEOUT      0x01</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> EV_READ         0x02</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> EV_WRITE        0x04</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> EV_SIGNAL       0x08</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> EV_PERSIST      0x10</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> EV_ET           0x20</span></span><br></pre></td></tr></table></figure>\n<p><code>cb</code>就是触发事件的回调函数，<br><code>arg</code>是我们自定义传进去的参数。</p>\n<p>而回调函数的格式是一样的。  比如。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">on_write</span><span class=\"params\">(<span class=\"keyword\">int</span> conn_fd, <span class=\"keyword\">short</span> event, <span class=\"keyword\">void</span> *arg)</span></span></span><br></pre></td></tr></table></figure>\n<p>第一个<code>conn_fd</code>就是我们<code>event_new</code> 中的<code>fd</code>， 第二个便是<code>what</code>，第三个是<code>arg</code>。</p>\n<p><code>struct event_base</code><br>创建<code>event_base</code>使用。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct event_base* <span class=\"title\">event_base_new</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure>\n<p>把一个<code>event</code>注册到<code>event_base</code>中 </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event</span> *<span class=\"title\">base</span> = <span class=\"title\">event_base_new</span>();</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event</span>* <span class=\"title\">ev_listen</span> = <span class=\"title\">event_new</span>(<span class=\"title\">base</span>, <span class=\"title\">listen_fd</span>, <span class=\"title\">EV_READ</span> | <span class=\"title\">EV_PERSIST</span>, <span class=\"title\">on_accept</span>, <span class=\"title\">NULL</span>);</span></span><br><span class=\"line\">event_base_set(base, ev_listen);</span><br><span class=\"line\">event_add(ev_listen, <span class=\"literal\">NULL</span>);</span><br></pre></td></tr></table></figure>\n<p>开始执行loop</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">event_base_dispatch</span><span class=\"params\">(struct event_base *base)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>还有类似<code>free</code>函数  </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">event_base_free(struct event base*);</span><br><span class=\"line\">event_free(struct event*);</span><br></pre></td></tr></table></figure>\n<p>一个简答的<code>example</code><br>打开一个socket，每有一次连接进来便接受并关闭。  </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">socket_bind_listen</span><span class=\"params\">(<span class=\"keyword\">char</span> *addr, <span class=\"keyword\">char</span> *port)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> listen_fd;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> Port;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">addr_s</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">//AF_INET ipv4</span></span><br><span class=\"line\">    <span class=\"comment\">//SOCK_STREAM 以流的方式传递</span></span><br><span class=\"line\">    listen_fd = socket(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (listen_fd == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        log_err(<span class=\"string\">\"%s\"</span>, strerror(errno));</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//get port</span></span><br><span class=\"line\">    Port = (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span>) atoi(port);</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;addr_s, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(addr_s));</span><br><span class=\"line\">    addr_s.sin_family = AF_INET;</span><br><span class=\"line\">    addr_s.sin_addr.s_addr = inet_addr(addr);</span><br><span class=\"line\">    addr_s.sin_port = htons(Port);</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = bind(listen_fd, (struct sockaddr *) &amp;addr_s, <span class=\"keyword\">sizeof</span>(addr_s));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"bind:\"</span>);</span><br><span class=\"line\">        close(listen_fd);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;\t</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (listen(listen_fd, BACKLOG) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"listen:\"</span>)</span><br><span class=\"line\">        close(listen_fd);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> listen_fd;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">on_accept</span><span class=\"params\">(<span class=\"keyword\">int</span> listen_fd, <span class=\"keyword\">short</span> events, <span class=\"keyword\">void</span> *arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> conn_fd = accept(listen_fd, <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (conn_fd &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t <span class=\"built_in\">printf</span>(<span class=\"string\">\"get connect\\n\"</span>);</span><br><span class=\"line\">\t close(conn_fd);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> listen_fd = socket_bind_listen(<span class=\"string\">\"127.0.0.1\"</span>, <span class=\"string\">\"8080\"</span>);\t</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_base</span> *<span class=\"title\">base</span> = <span class=\"title\">event_base_new</span>();</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event</span>* <span class=\"title\">ev_listen</span> = <span class=\"title\">event_new</span>(<span class=\"title\">base</span>, <span class=\"title\">listen_fd</span>, <span class=\"title\">EV_READ</span> | <span class=\"title\">EV_PERSIST</span>, <span class=\"title\">on_accept</span>, <span class=\"title\">NULL</span>);</span></span><br><span class=\"line\">    event_base_set(base, ev_listen);</span><br><span class=\"line\">    event_add(ev_listen, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    event_base_dispatch(base);</span><br><span class=\"line\">    event_base_free(base);</span><br><span class=\"line\">    event_free(ev_listen);\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["技术却无分类"],"tags":["Web"]},{"title":"叶子","url":"https://blog.lovezhy.cc/2017/07/26/叶子/","content":"<p><img src=\"/images/2017-07-26_16-27-15.jpg\" alt=\"叶子\"></p>\n<p>去帮室友拿快递的时候看到的。<br>暑假没人打扫。<br>落了满地。</p>\n","categories":["我的生活"],"tags":["Logger"]},{"title":"HashMap源码解析","url":"https://blog.lovezhy.cc/2017/07/21/HashMap源码解析/","content":"<h3 id=\"Hash数据结构设计\"><a href=\"#Hash数据结构设计\" class=\"headerlink\" title=\"Hash数据结构设计\"></a><code>Hash</code>数据结构设计</h3><p>为什么HashMap的capacity是2的整数次幂？<br>JDK1.8相对于1.7改进了什么？<br>HashMap在多线程情况下会发生什么？</p>\n<a id=\"more\"></a>\n<h4 id=\"散列函数\"><a href=\"#散列函数\" class=\"headerlink\" title=\"散列函数\"></a>散列函数</h4><p><code>Java</code>中把每个对象散列成一个整数的方法是<code>hashCode()</code>，这个方法是从<code>Object</code>而来的。<br>默认的是通过对象的内存地址来。所以几乎是唯一的，不会产生碰撞的。<br>但是我们也可以自己选择重写这个方法。<br>不过我们在重写<code>hashCode</code>方法时，别忘了也要重写<code>equals</code>方法。<br>要保证<code>hashCode</code>和<code>equals</code>方法的行为一致。<br>也就是说<code>equals</code>为<code>true</code>时，<code>hashCode</code>必然时相等的。<br><code>equals</code>为<code>false</code>时，<code>hashCode</code>可以相等也可以不相等。  </p>\n<h4 id=\"碰撞冲突\"><a href=\"#碰撞冲突\" class=\"headerlink\" title=\"碰撞冲突\"></a>碰撞冲突</h4><p>如果两个键的hashCode相同，那就是产生了碰撞。<br>有很多方法解决碰撞，常见的是拉链法和线性探测法。  </p>\n<h5 id=\"拉链法\"><a href=\"#拉链法\" class=\"headerlink\" title=\"拉链法\"></a>拉链法</h5><p>就是开一个Node的数组，然后每个元素指向一个链表。<br>但hash值相同时，就存在对应的元素的单链表中。<br>实现也较为简单。</p>\n<p>借助这个再解释下<code>hashCode</code>和<code>equals</code>方法。<br><code>hashCode</code>产生的值用来寻找数组的索引，但是可能产生碰撞，于是<code>equals</code>方法就用来便利单链表找到相等的键。</p>\n<h4 id=\"线性探测法\"><a href=\"#线性探测法\" class=\"headerlink\" title=\"线性探测法\"></a>线性探测法</h4><p>就是开一个Node数组，如果hash值相同，那么找下一个空位。<br>怎么找下一个空位呢。<br>最简单的就是每次+1，当然你也可以约定+2，+3。。。<br>​    </p>\n<h3 id=\"HashMap源码解析\"><a href=\"#HashMap源码解析\" class=\"headerlink\" title=\"HashMap源码解析\"></a><code>HashMap</code>源码解析</h3><p>HashMap用的是拉链法，但是1.8中还增加了改进。<br>我们约定前面的数组的每一格称为桶<br>约定桶后面存放的每一个数据称为bin</p>\n<p>1.8中补充了红黑树，如果一个桶的bin数大于8，那么就把这个桶的链表转换为红黑树。 </p>\n<h4 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a><code>Map</code></h4><p>声明</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;, <span class=\"title\">Cloneable</span>, <span class=\"title\">Serializable</span></span></span><br></pre></td></tr></table></figure>\n<p>HashMap继承自AbstractMap， 实现了Map接口的方法。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>AbstractMap</code>同样实现了Map接口的方法。<br>很多人可能奇怪为什么HashMap为什么不直接实现Map接口就好，中间要多个AbstractMap类呢。<br>因为类库开发者考虑到有些人可能要实现自己的Map类，为了给降低他们的开发难度，于是开发了AbstractMap类。<br>这样我们如果要实现自己的Map类，就继承AbstractMap类就好了。</p>\n<p>Map接口的所有方法如下，其中有很多<code>default</code>方法，是Java8的新特性。<br>有兴趣的可以百度一下。这里就不赘述了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Map</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//Map具有特征的方法，看名字就大概就能猜到用处</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span></span>;\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">containsKey</span><span class=\"params\">(Object key)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">containsValue</span><span class=\"params\">(Object value)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\">V <span class=\"title\">get</span><span class=\"params\">(Object key)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\">V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\">V <span class=\"title\">remove</span><span class=\"params\">(Object key)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">putAll</span><span class=\"params\">(Map&lt;? extends K, ? extends V&gt; m)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\">Set&lt;K&gt; <span class=\"title\">keySet</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\">Collection&lt;V&gt; <span class=\"title\">values</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"comment\">//Entry见下</span></span><br><span class=\"line\">\tSet&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//来自Object的方法</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//底层的数据单位Entry</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"function\">K <span class=\"title\">getKey</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t\t<span class=\"function\">V <span class=\"title\">getValue</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t\t<span class=\"function\">V <span class=\"title\">setValue</span><span class=\"params\">(V value)</span></span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">//来自Object</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span></span>;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//key的比较，lambda表达式还能这么用。。。</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;K extends Comparable&lt;? <span class=\"keyword\">super</span> K&gt;, V&gt; Comparator&lt;Map.Entry&lt;K,V&gt;&gt; comparingByKey() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)</span><br><span class=\"line\">                (c1, c2) -&gt; c1.getKey().compareTo(c2.getKey());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//value的比较</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;K, V extends Comparable&lt;? <span class=\"keyword\">super</span> V&gt;&gt; Comparator&lt;Map.Entry&lt;K,V&gt;&gt; comparingByValue() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)</span><br><span class=\"line\">                (c1, c2) -&gt; c1.getValue().compareTo(c2.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//自定义key的比较</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByKey(Comparator&lt;? <span class=\"keyword\">super</span> K&gt; cmp) &#123;</span><br><span class=\"line\">            Objects.requireNonNull(cmp);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)</span><br><span class=\"line\">                (c1, c2) -&gt; cmp.compare(c1.getKey(), c2.getKey());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//自定义value的比较</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByValue(Comparator&lt;? <span class=\"keyword\">super</span> V&gt; cmp) &#123;</span><br><span class=\"line\">            Objects.requireNonNull(cmp);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)</span><br><span class=\"line\">                (c1, c2) -&gt; cmp.compare(c1.getValue(), c2.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//给定一个key获取value，同时指定一个default值，如果不存在就返回default值</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">default</span> V <span class=\"title\">getOrDefault</span><span class=\"params\">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class=\"line\">        V v;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (((v = get(key)) != <span class=\"keyword\">null</span>) || containsKey(key))</span><br><span class=\"line\">            ? v</span><br><span class=\"line\">            : defaultValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//对Map中每个键值对进行指定的action操作</span></span><br><span class=\"line\">    <span class=\"comment\">//这个方法会抛出异常如果在遍历过程中某个Entry被删除了</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">forEach</span><span class=\"params\">(BiConsumer&lt;? <span class=\"keyword\">super</span> K, ? <span class=\"keyword\">super</span> V&gt; action)</span> </span>&#123;</span><br><span class=\"line\">        Objects.requireNonNull(action);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;K, V&gt; entry : entrySet()) &#123;</span><br><span class=\"line\">            K k;</span><br><span class=\"line\">            V v;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                k = entry.getKey();</span><br><span class=\"line\">                v = entry.getValue();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span>(IllegalStateException ise) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// this usually means the entry is no longer in the map.</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException(ise);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            action.accept(k, v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//把所有的value进行重新赋值，也会抛出异常</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">replaceAll</span><span class=\"params\">(BiFunction&lt;? <span class=\"keyword\">super</span> K, ? <span class=\"keyword\">super</span> V, ? extends V&gt; function)</span> </span>&#123;</span><br><span class=\"line\">        Objects.requireNonNull(function);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;K, V&gt; entry : entrySet()) &#123;</span><br><span class=\"line\">            K k;</span><br><span class=\"line\">            V v;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                k = entry.getKey();</span><br><span class=\"line\">                v = entry.getValue();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span>(IllegalStateException ise) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// this usually means the entry is no longer in the map.</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException(ise);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// ise thrown from function is not a cme.</span></span><br><span class=\"line\">            v = function.apply(k, v);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                entry.setValue(v);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span>(IllegalStateException ise) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// this usually means the entry is no longer in the map.</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException(ise);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//如果key不存在，则put进去</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> V <span class=\"title\">putIfAbsent</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">        V v = get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            v = put(key, value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//移除一个键值对，同时必须键值对都相等</span></span><br><span class=\"line\">\t <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object key, Object value)</span> </span>&#123;</span><br><span class=\"line\">        Object curValue = get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!Objects.equals(curValue, value) ||</span><br><span class=\"line\">            (curValue == <span class=\"keyword\">null</span> &amp;&amp; !containsKey(key))) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        remove(key);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//替换一个key的value，同时oldvalue要和之前的value相等</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">boolean</span> <span class=\"title\">replace</span><span class=\"params\">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class=\"line\">        Object curValue = get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!Objects.equals(curValue, oldValue) ||</span><br><span class=\"line\">            (curValue == <span class=\"keyword\">null</span> &amp;&amp; !containsKey(key))) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        put(key, newValue);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//也是替换一个key的value，但是不要求当前的value为何值</span></span><br><span class=\"line\">\t <span class=\"function\"><span class=\"keyword\">default</span> V <span class=\"title\">replace</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">        V curValue;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (((curValue = get(key)) != <span class=\"keyword\">null</span>) || containsKey(key)) &#123;</span><br><span class=\"line\">            curValue = put(key, value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> curValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//如果map中不存在key，则根据key通过mappingFuction得到一个value并放进去</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> V <span class=\"title\">computeIfAbsent</span><span class=\"params\">(K key,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            Function&lt;? <span class=\"keyword\">super</span> K, ? extends V&gt; mappingFunction)</span> </span>&#123;</span><br><span class=\"line\">        Objects.requireNonNull(mappingFunction);</span><br><span class=\"line\">        V v;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((v = get(key)) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            V newValue;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((newValue = mappingFunction.apply(key)) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                put(key, newValue);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> newValue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//如果map中存在key，则根据key和oldvalue通过remappingFuction得到一个value并放入</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> V <span class=\"title\">computeIfPresent</span><span class=\"params\">(K key,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            BiFunction&lt;? <span class=\"keyword\">super</span> K, ? <span class=\"keyword\">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class=\"line\">        Objects.requireNonNull(remappingFunction);</span><br><span class=\"line\">        V oldValue;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((oldValue = get(key)) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            V newValue = remappingFunction.apply(key, oldValue);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (newValue != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                put(key, newValue);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> newValue;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                remove(key);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//这个有点复杂，根据oldvalue(可能不存在)和key通过remappingFunction得到一个newValue</span></span><br><span class=\"line\">    <span class=\"comment\">//如果newValue不为null，则置换或者增加这个key，newValue</span></span><br><span class=\"line\">    <span class=\"comment\">//如果newValue为null，如果old也不为null，就把这个key移除出去</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> V <span class=\"title\">compute</span><span class=\"params\">(K key,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            BiFunction&lt;? <span class=\"keyword\">super</span> K, ? <span class=\"keyword\">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class=\"line\">        Objects.requireNonNull(remappingFunction);</span><br><span class=\"line\">        V oldValue = get(key);</span><br><span class=\"line\"></span><br><span class=\"line\">        V newValue = remappingFunction.apply(key, oldValue);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newValue == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// delete mapping</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (oldValue != <span class=\"keyword\">null</span> || containsKey(key)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// something to remove</span></span><br><span class=\"line\">                remove(key);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// nothing to do. Leave things as they were.</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// add or replace old mapping</span></span><br><span class=\"line\">            put(key, newValue);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> newValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//这个也有点复杂</span></span><br><span class=\"line\">    <span class=\"comment\">//如果不存在这个键值对，就把key，value存进去</span></span><br><span class=\"line\">    <span class=\"comment\">//如果存在，则根据oldvalue和value通过remappingFunction得到一个newvalue，如果newvalue为null，则把这个key移除，否则就存进去</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> V <span class=\"title\">merge</span><span class=\"params\">(K key, V value,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            BiFunction&lt;? <span class=\"keyword\">super</span> V, ? <span class=\"keyword\">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class=\"line\">        Objects.requireNonNull(remappingFunction);</span><br><span class=\"line\">        Objects.requireNonNull(value);</span><br><span class=\"line\">        V oldValue = get(key);</span><br><span class=\"line\">        V newValue = (oldValue == <span class=\"keyword\">null</span>) ? value :</span><br><span class=\"line\">                   remappingFunction.apply(oldValue, value);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(newValue == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            remove(key);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            put(key, newValue);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newValue;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>Map的大概就是这些，我们主要了解了一些通用的default方法，通过lambda表达式可以很方便的做一些事。<br>还有就是Map内部有一个Entry的接口，一个Entry，就是一个键值对。</p>\n<h4 id=\"AbstractMap\"><a href=\"#AbstractMap\" class=\"headerlink\" title=\"AbstractMap\"></a>AbstractMap</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//key，value主要是存在这个entrySet中</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> Set&lt;Entry&lt;K,V&gt;&gt; entrySet();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//这里两个主要是为了得到所有的key集合或者value集合而设计的</span></span><br><span class=\"line\">    <span class=\"keyword\">transient</span> Set&lt;K&gt;        keySet;</span><br><span class=\"line\">    <span class=\"keyword\">transient</span> Collection&lt;V&gt; values;</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">eq</span><span class=\"params\">(Object o1, Object o2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> o1 == <span class=\"keyword\">null</span> ? o2 == <span class=\"keyword\">null</span> : o1.equals(o2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//AbstractMap中有Entry的两个实现</span></span><br><span class=\"line\">   \t<span class=\"comment\">//其中之一是SimpleEntry</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleEntry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> V value;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//省略一些正常的构造函数和getter和setter</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//equals的实现是比较key和value是否相等</span></span><br><span class=\"line\">        <span class=\"comment\">//其中eq函数是对Object的equals的封装，里面考虑了null的情况</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!(o <span class=\"keyword\">instanceof</span> Map.Entry))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> eq(key, e.getKey()) &amp;&amp; eq(value, e.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//hashCode()方法是对两个对象的hashCode求异或</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (key   == <span class=\"keyword\">null</span> ? <span class=\"number\">0</span> :   key.hashCode()) ^</span><br><span class=\"line\">                   (value == <span class=\"keyword\">null</span> ? <span class=\"number\">0</span> : value.hashCode());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//第二个是SimpleImmutableEntry</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleImmutableEntry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//可以看到key和value都是final的，所以自然没有setValue的方法，但是其实还是有的</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> V value;        </span><br><span class=\"line\">        <span class=\"comment\">//setValue方法抛出一个异常</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">setValue</span><span class=\"params\">(V value)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\">        <span class=\"comment\">//其他的和SimpleEntry的一样</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//返回一个key的Set，这里使用了懒加载，只有在第一次调用的时候才会初始化keySet</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Set&lt;K&gt; <span class=\"title\">keySet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;K&gt; ks = keySet;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ks == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ks = <span class=\"keyword\">new</span> AbstractSet&lt;K&gt;() &#123;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> Iterator&lt;K&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Iterator&lt;K&gt;() &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">private</span> Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                            <span class=\"keyword\">return</span> i.hasNext();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">public</span> K <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                            <span class=\"keyword\">return</span> i.next().getKey();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                            i.remove();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> AbstractMap.<span class=\"keyword\">this</span>.size();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> AbstractMap.<span class=\"keyword\">this</span>.isEmpty();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    AbstractMap.<span class=\"keyword\">this</span>.clear();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object k)</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> AbstractMap.<span class=\"keyword\">this</span>.containsKey(k);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;       </span><br><span class=\"line\">            <span class=\"comment\">//因为是懒加载，所以加载完之后还要再赋给keySet</span></span><br><span class=\"line\">            keySet = ks;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ks;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//返回value的值集合，同样也是懒加载</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Collection&lt;V&gt; <span class=\"title\">values</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Collection&lt;V&gt; vals = values;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (vals == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            vals = <span class=\"keyword\">new</span> AbstractCollection&lt;V&gt;() &#123;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> Iterator&lt;V&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Iterator&lt;V&gt;() &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">private</span> Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                            <span class=\"keyword\">return</span> i.hasNext();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                            <span class=\"keyword\">return</span> i.next().getValue();</span><br><span class=\"line\">                        &#125;\t</span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                            i.remove();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> AbstractMap.<span class=\"keyword\">this</span>.size();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> AbstractMap.<span class=\"keyword\">this</span>.isEmpty();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    AbstractMap.<span class=\"keyword\">this</span>.clear();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object v)</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> AbstractMap.<span class=\"keyword\">this</span>.containsValue(v);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            values = vals;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> vals;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//返回entry的大小</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> entrySet().size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//这个主要要注意是允许存放null值的，也是可以搜索null值的</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">containsValue</span><span class=\"params\">(Object value)</span> </span>&#123;</span><br><span class=\"line\">        Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value==<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i.hasNext()) &#123;</span><br><span class=\"line\">                Entry&lt;K,V&gt; e = i.next();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.getValue()==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i.hasNext()) &#123;</span><br><span class=\"line\">                Entry&lt;K,V&gt; e = i.next();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (value.equals(e.getValue()))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//同时key也是可以是null的</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">containsKey</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">        Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key==<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i.hasNext()) &#123;</span><br><span class=\"line\">                Entry&lt;K,V&gt; e = i.next();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.getKey()==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i.hasNext()) &#123;</span><br><span class=\"line\">                Entry&lt;K,V&gt; e = i.next();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (key.equals(e.getKey()))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//get方法和上面的大同小异，，分为是null或者不是两种情况</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//remove方法。。。嗯，，，好像也没什么好解释的，，看看就懂了</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">remove</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">        Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class=\"line\">        Entry&lt;K,V&gt; correctEntry = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key==<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (correctEntry==<span class=\"keyword\">null</span> &amp;&amp; i.hasNext()) &#123;</span><br><span class=\"line\">                Entry&lt;K,V&gt; e = i.next();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.getKey()==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    correctEntry = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (correctEntry==<span class=\"keyword\">null</span> &amp;&amp; i.hasNext()) &#123;</span><br><span class=\"line\">                Entry&lt;K,V&gt; e = i.next();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (key.equals(e.getKey()))</span><br><span class=\"line\">                    correctEntry = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        V oldValue = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (correctEntry !=<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            oldValue = correctEntry.getValue();</span><br><span class=\"line\">            i.remove();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//hashCode是把所有的Entry的hashCode加起来</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> h = <span class=\"number\">0</span>;</span><br><span class=\"line\">        Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i.hasNext())</span><br><span class=\"line\">            h += i.next().hashCode();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> h;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//这个toString写的很有意思，给人很有启发。。。主要是实现的比较优雅。。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! i.hasNext())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"&#123;&#125;\"</span>;</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        sb.append(<span class=\"string\">'&#123;'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            Entry&lt;K,V&gt; e = i.next();</span><br><span class=\"line\">            K key = e.getKey();</span><br><span class=\"line\">            V value = e.getValue();</span><br><span class=\"line\">            sb.append(key   == <span class=\"keyword\">this</span> ? <span class=\"string\">\"(this Map)\"</span> : key);</span><br><span class=\"line\">            sb.append(<span class=\"string\">'='</span>);</span><br><span class=\"line\">            sb.append(value == <span class=\"keyword\">this</span> ? <span class=\"string\">\"(this Map)\"</span> : value);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (! i.hasNext())</span><br><span class=\"line\">                <span class=\"keyword\">return</span> sb.append(<span class=\"string\">'&#125;'</span>).toString();</span><br><span class=\"line\">            sb.append(<span class=\"string\">','</span>).append(<span class=\"string\">' '</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h4><p>重头戏来了。。<br>前面说过jdk1.7以前的HashMap的bin就是一个单链表，但是到了1.8的时候进行了改进。<br>如果一个桶中的bin数量大于8并且当前的capacity大于64时，那么就会变成一颗红黑树。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;, <span class=\"title\">Cloneable</span>, <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//约定前面的数组的每一格称为桶 </span></span><br><span class=\"line\">    <span class=\"comment\">//约定桶后面存放的每一个数据称为bin </span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//默认的桶的数量大小，写成这样不是直接写16是因为强调要是2的倍数</span></span><br><span class=\"line\">    <span class=\"comment\">//为什么呢，往下看</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//最大的桶的数量</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//默认的负载，就是已有size／capacity，当达到这个值时，会进行resize，下面会提到</span></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//如果一个桶中的bin数量大于8，那么就变成红黑树，但是还有个条件见下</span></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TREEIFY_THRESHOLD = <span class=\"number\">8</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//同上一个相反，当桶上的链表数小于这个值时树转链表</span></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> UNTREEIFY_THRESHOLD = <span class=\"number\">6</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//数化的还有一个条件是当哈希表中的容量大于这个值时，否则即使大于8，也不会树化。</span></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MIN_TREEIFY_CAPACITY = <span class=\"number\">64</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//一些系统的参数</span></span><br><span class=\"line\">\t<span class=\"comment\">//系统的负载因子</span></span><br><span class=\"line\">\t<span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//threshold表示当HashMap的size大于threshold时会执行resize操作。</span></span><br><span class=\"line\">\t<span class=\"comment\">//threshold=capacity*loadFactor</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> threshold;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//这个table是开地址法的数组，相当于桶</span></span><br><span class=\"line\">\t<span class=\"keyword\">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class=\"line\">\t<span class=\"comment\">//放节点的Set</span></span><br><span class=\"line\">\t<span class=\"keyword\">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class=\"line\">\t<span class=\"comment\">//目前有多少对map</span></span><br><span class=\"line\">\t<span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//当前的HashMap被修改了多少次。</span></span><br><span class=\"line\">\t<span class=\"comment\">//还记得ConcurrentModificationException么</span></span><br><span class=\"line\">\t<span class=\"comment\">//这个在使用Iterator时，会判断当前的modCount和使用时是否相等</span></span><br><span class=\"line\">\t<span class=\"comment\">//如果不相等，那么就抛出异常。</span></span><br><span class=\"line\">\t<span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> modCount;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//先来看看构造函数</span></span><br><span class=\"line\">\t<span class=\"comment\">//第一个什么也没有，就是上面的值都是默认值</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//第二个可以指定初始的容量的大小，它调用了第三个构造函数。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//第三个构造函数主要对值进行了检查</span></span><br><span class=\"line\">    <span class=\"comment\">//如果传进去的大小小于0，那就抛出一个异常，如果大于最大值，就设为最大值。</span></span><br><span class=\"line\">    <span class=\"comment\">//但是loadFactor也进行了检查，不知道为什么，我好像没有看到一个方法可以对loadFactor进行修改。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal initial capacity: \"</span> +</span><br><span class=\"line\">                                               initialCapacity);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal load factor: \"</span> +</span><br><span class=\"line\">                                               loadFactor);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//还记得最开始说的容量最好是2的倍数吗？这里我们传一个数进去，它会找到最接近我们数的2的倍数作为容量。而不是就把我们的数作为容量了。具体函数见下</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//找到最接近cap的2的倍数的数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = cap - <span class=\"number\">1</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//先来看看resize函数吧，这个是核心</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">    \t <span class=\"comment\">//先拿到当前数组桶的索引</span></span><br><span class=\"line\">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">        <span class=\"comment\">//得到旧的table的长度，考虑到还没初始化，所以把null值作为0处理</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">        <span class=\"comment\">//旧的bin的阀值</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//如果oldCap大于0，大概就是已经初始化过了。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        \t  <span class=\"comment\">//如果已经达到最大值，就直接返回了，不可以在resize了。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">                threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//不然看看把oldCap乘2，如果还没大于1 &lt;&lt; 30，就是默认的最大的桶数</span></span><br><span class=\"line\">            <span class=\"comment\">//则新的cap的值就是就的值乘2</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">                newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) </span><br><span class=\"line\">        \t  <span class=\"comment\">//不然新的桶的数量就是旧的阀值</span></span><br><span class=\"line\">            newCap = oldThr;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">        \t  <span class=\"comment\">//如果以上两个条件都不满足，那么newCap就是默认的值16，新的阀值就是12.            </span></span><br><span class=\"line\">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">            newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果新的阀值为0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">                      (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        threshold = newThr;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//直接new一个新的具有newCap大小的数组</span></span><br><span class=\"line\">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];</span><br><span class=\"line\">        <span class=\"comment\">//= =这里为什么不直接和上面的合成一句话呢。。。。</span></span><br><span class=\"line\">        table = newTab;</span><br><span class=\"line\">        <span class=\"comment\">//下面就是把旧的table里的bin全部转移到新的table中</span></span><br><span class=\"line\">        <span class=\"comment\">//其实很多文章说HashMap的put操作会造成死循环</span></span><br><span class=\"line\">        <span class=\"comment\">//但是在1.8中进行了改进，所以下面这段代码在多线程环境中不会造成死循环</span></span><br><span class=\"line\">        <span class=\"comment\">//旧的有个很好的文件进行解释,见下</span></span><br><span class=\"line\">      \t</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">                Node&lt;K,V&gt; e;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    oldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                        newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                        ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// preserve order</span></span><br><span class=\"line\">                        Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        Node&lt;K,V&gt; next;</span><br><span class=\"line\">                        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                            next = e.next;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                    loHead = e;</span><br><span class=\"line\">                                <span class=\"keyword\">else</span></span><br><span class=\"line\">                                    loTail.next = e;</span><br><span class=\"line\">                                loTail = e;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                    hiHead = e;</span><br><span class=\"line\">                                <span class=\"keyword\">else</span></span><br><span class=\"line\">                                    hiTail.next = e;</span><br><span class=\"line\">                                hiTail = e;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                            newTab[j] = loHead;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                            newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//下面先来看看最常用的put函数，调用了putVal函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//对于这儿的hash()函数，其实还是挺有意思的,作者觉得原来的容易产生</span></span><br><span class=\"line\">        <span class=\"comment\">//碰撞，所以把前16位和后16为进行了异或。。。</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            n = (tab = resize()).length;</span><br><span class=\"line\">        <span class=\"comment\">//这里就是为什么capacity取2的整数次幂的原因了</span></span><br><span class=\"line\">        <span class=\"comment\">//正常我们找index的时候都是hash % length，但是用到了除法</span></span><br><span class=\"line\">        <span class=\"comment\">//如果2的整数次幂，那么hash % length = （length - 1) &amp; hash，用的是位运算</span></span><br><span class=\"line\">        <span class=\"comment\">//对于计算机来说位运算的效率更高。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">                ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                e = p;</span><br><span class=\"line\">            <span class=\"comment\">//如果是树节点</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                        <span class=\"comment\">//如果大于8，进行进入treeifyBin函数，并不就是直接进行树化，因为还有一个条件。</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">                            treeifyBin(tab, hash);</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                        ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    p = e;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">                V oldValue = e.value;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    e.value = value;</span><br><span class=\"line\">                afterNodeAccess(e);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ++modCount;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">            resize();</span><br><span class=\"line\">        afterNodeInsertion(evict);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//看看get方法，调用了getNode方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"keyword\">int</span> n; K k;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">            (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></span><br><span class=\"line\">                ((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            \t\t<span class=\"comment\">//如果这个桶里的节点是树节点，那么用找树节点的方法。见下</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                        ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//下面看看树的操作。</span></span><br><span class=\"line\">\t<span class=\"comment\">//在HashMap中Entry的实现有两个</span></span><br><span class=\"line\">\t<span class=\"comment\">//第一个就是单链表的Node</span></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//第二个是树的Node，TreeNode</span></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">LinkedHashMap</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//关于红黑树的原理，这里就不赘述了。。。完整说起来又是一遍长篇大论。</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//将一个桶中的节点树化的函数</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">treeifyBin</span><span class=\"params\">(Node&lt;K,V&gt;[] tab, <span class=\"keyword\">int</span> hash)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class=\"line\">        <span class=\"comment\">//如果桶的大小小于64，进行的是resize而不是树化。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tab == <span class=\"keyword\">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class=\"line\">            resize();</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((e = tab[index = (n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            TreeNode&lt;K,V&gt; hd = <span class=\"keyword\">null</span>, tl = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tl == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    hd = p;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    p.prev = tl;</span><br><span class=\"line\">                    tl.next = p;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                tl = p;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((tab[index] = hd) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                hd.treeify(tab);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//简单看一看TreeNode的定义。</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">LinkedHashMap</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//还有指向父节点的指针。</span></span><br><span class=\"line\">        TreeNode&lt;K,V&gt; parent;  </span><br><span class=\"line\">        TreeNode&lt;K,V&gt; left;</span><br><span class=\"line\">        TreeNode&lt;K,V&gt; right;</span><br><span class=\"line\">        TreeNode&lt;K,V&gt; prev;   </span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> red;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://hongjiang.info/hashmap-infinite-loop/\" target=\"_blank\" rel=\"noopener\">HashMap死循环</a>  </p>\n<p>我们要知道死循环的原因是链表产生了回路。<br>1.8之前产生回路的原因是换table时把原先的单链表每个节点放到了链表开头。<br>就是说比如旧table[0]中 1 -&gt; 2 -&gt; 3<br>在resize时，新的table[0]中变成 3 -&gt; 2 -&gt; 1</p>\n<p>但是在1.8中不在这样，而是规规矩矩的还是1 -&gt; 2 -&gt; 3</p>\n","categories":["Java源码解读"],"tags":["Java"]},{"title":"PathVariable及路由设计","url":"https://blog.lovezhy.cc/2017/07/21/PathVariable及route设计/","content":"<h3 id=\"项目源码\"><a href=\"#项目源码\" class=\"headerlink\" title=\"项目源码\"></a><a href=\"https://github.com/zhyzhyzhy/NoName/tree/master/src/main/java/com/noname/web/route\" target=\"_blank\" rel=\"noopener\">项目源码</a></h3><h4 id=\"PathVariable\"><a href=\"#PathVariable\" class=\"headerlink\" title=\"@PathVariable\"></a><code>@PathVariable</code></h4><p>在web后端框架中，路由设计是很重要的一步。<br>各个框架对接口设计的支持大多差不多，其中必然有</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@GET(&quot;/users/&#123;id&#125;/&quot;)   </span><br><span class=\"line\">@GET(&quot;/users/:id/&quot;)</span><br></pre></td></tr></table></figure>\n<p>这样的标准。</p>\n<p>其中<code>{id}</code>和<code>:id</code>表示是一个不确定的值，这个随着<code>rustful</code>的兴起也变得常用起来<br>比如我想要查看<code>id = 1</code>的用户的信息，那么我的请求便是<code>/users/1</code><br>如果查看<code>id = 321</code>的用户信息，请求的便是<code>/users/321</code>。</p>\n<p>那么这个id便是一个不确定量。  </p>\n<p>于是对于这个方法而言这个id值便是参数，在我们调用时需要传进去。  </p>\n<p>在<code>Spring MVC</code>中，完整的方法是这样 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"/employer/&#123;phoneNumber&#125;\"</span>)  </span><br><span class=\"line\"><span class=\"keyword\">public</span> ResponseEntity&lt;?&gt; findByPhoneNumber(<span class=\"meta\">@PathVariable</span> String phoneNumber) &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以这就要求我们在设计框架时还需要利用反射把请求的uri的特定路径值作为参数传进方法中。</p>\n<h4 id=\"route设计\"><a href=\"#route设计\" class=\"headerlink\" title=\"route设计\"></a>route设计</h4><p>正常我们进行反射调用时，像这样</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">method().invoke(object(), paramters());</span><br></pre></td></tr></table></figure>\n<p>首先<code>route</code>中需要有这个对应的<code>Method</code>，其次对应的对象也应该在其中，然后是参数。  </p>\n<p>于是我设计为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Route</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//对应的uri</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String path;</span><br><span class=\"line\">\t<span class=\"comment\">//method所在的对象</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Object object;</span><br><span class=\"line\">\t<span class=\"comment\">//对应的路由method</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Method method;</span><br><span class=\"line\">\t<span class=\"comment\">//对应的方法，比如GET，POST等</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> HttpMethod httpMethod;</span><br><span class=\"line\">\t<span class=\"comment\">//对应的参数</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Object[] paramters;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"路由匹配\"><a href=\"#路由匹配\" class=\"headerlink\" title=\"路由匹配\"></a>路由匹配</h4><p>那么问题来了，对于不同的uri，我们应该怎么匹配路由呢。</p>\n<p>我想到的是用正则<br>设计一个这样的Map</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;Pattern, Route&gt; routeMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>\n<p>对于<code>/users/{id}/</code>这样的字符串，我们需要产生一个<code>pattern</code>出来。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//根据参数进行正则替换</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Pattern <span class=\"title\">pathCompiler</span><span class=\"params\">(String path, Method method)</span> </span>&#123;</span><br><span class=\"line\">    Parameter[] parameters = method.getParameters();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Parameter parameter : parameters) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parameter.getAnnotations() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Annotation annotation = parameter.getAnnotations()[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (annotation <span class=\"keyword\">instanceof</span> PathVariable) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果是字符串</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (parameter.getType() == String.class) &#123;</span><br><span class=\"line\">                path = path.replace(<span class=\"string\">\"&#123;\"</span> + parameter.getName()+<span class=\"string\">\"&#125;\"</span>,<span class=\"string\">\"[0-9\\\\d\\\\D]*\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//如果是数字</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (parameter.getType() == Integer.class</span><br><span class=\"line\">                    || parameter.getType() == Long.class) &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">                path = path.replace(<span class=\"string\">\"&#123;\"</span> + parameter.getName()+<span class=\"string\">\"&#125;\"</span>,<span class=\"string\">\"[0-9]*\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Pattern.compile(path);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>键为<code>url</code>的<code>Pattern</code>，那么在匹配时只要遍历一下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//保存着所有的路由</span></span><br><span class=\"line\">Map&lt;Pattern, Route&gt; routeMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Route <span class=\"title\">findRoute</span><span class=\"params\">(String path, HttpMethod method)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (Pattern pattern : routeMap.keySet()) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pattern.matcher(path).matches()) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (routeMap.get(pattern).getHttpMethod().equals(method)) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">/* 进行参数的赋值 *／</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\treturn routeMap.get(pattern);</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\treturn null;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br></pre></td></tr></table></figure>\n","categories":[],"tags":["Web"]},{"title":"Hello World","url":"https://blog.lovezhy.cc/2017/07/07/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<a id=\"more\"></a>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","categories":["Hello"],"tags":[]},{"title":"使用AuthenticationProvider进行自定义登陆配置","url":"https://blog.lovezhy.cc/2017/05/28/use_AuthenticationProvider_in_springSec/","content":"<a id=\"more\"></a>\n<p>我们在使用<code>spring sec</code>的时候，一般会继承<code>WebSecurityConfigurerAdapter</code>类<br>然后选择覆盖</p>\n<p><code>protected void configure(AuthenticationManagerBuilder auth)</code><br><code>protected void configure(HttpSecurity http)</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(AuthenticationManagerBuilder auth)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    auth.userDetailsService(studentService).passwordEncoder(encoder);</span><br><span class=\"line\">    auth.userDetailsService(teacherService).passwordEncoder(encoder);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(HttpSecurity http)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    http.csrf().disable()</span><br><span class=\"line\">        .authorizeRequests()</span><br><span class=\"line\">        .antMatchers(<span class=\"string\">\"/**\"</span>).authenticated()</span><br><span class=\"line\">        .and()</span><br><span class=\"line\">        .formLogin().loginPage(<span class=\"string\">\"/login\"</span>).permitAll();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一般而言登录的数据我们在<code>protected void configure(AuthenticationManagerBuilder auth)</code>中，我们在<code>studentService</code>中配置一个</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> UserDetails <span class=\"title\">loadUserByUsername</span><span class=\"params\">(String username)</span> <span class=\"keyword\">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class=\"line\">    Student student = studentRepository.findByStudentId(username)</span><br><span class=\"line\">                                       .orElseThrow(() -&gt; <span class=\"keyword\">new</span> UsernameNotFoundException(<span class=\"string\">\"Not found: \"</span> + username));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> StudentDetails(student);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>方法就好。</p>\n<p>但是遇到一个问题，这样的话用户名和密码都是定死的，我们拿不到<code>form-data</code>数据，如果因为前端的问题，这种密码登录方式以外，我们还要稍微修改提交给我们的<code>form-data</code>中的密码数据，做一下处理，自定义一个登录呢。</p>\n<p>这个时候就需要用到<code>AuthenticationProvider</code>了。<br>这是一个接口，提供了两种方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AuthenticationProvider</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">Authentication <span class=\"title\">authenticate</span><span class=\"params\">(Authentication authentication)</span> <span class=\"keyword\">throws</span> AuthenticationException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">supports</span><span class=\"params\">(Class&lt;?&gt; authentication)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过第一个方法我们可以拿到<code>form-data</code>的数据，并且返回一个<code>UserDetails</code>如果登录成功的话，或者返回<code>null</code>如果登录失败。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Authentication <span class=\"title\">authenticate</span><span class=\"params\">(Authentication authentication)</span> <span class=\"keyword\">throws</span> AuthenticationException </span>&#123;</span><br><span class=\"line\">        String userName = (String) authentication.getPrincipal(); <span class=\"comment\">//拿到username</span></span><br><span class=\"line\">        String password = (String) authentication.getCredentials(); <span class=\"comment\">//拿到password</span></span><br><span class=\"line\"></span><br><span class=\"line\">        UserDetails userDetails = studentService.loadUserByUsername(userName);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"comment\">/*自定义的验证通过*/</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> UsernamePasswordAuthenticationToken(userDetails, <span class=\"keyword\">null</span>,userDetails.getAuthorities());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/*验证不通过*/</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二个方法是告诉<code>spring sec</code>我们这个验证支持哪种验证。</p>\n<p>这种验证属于<code>Dao</code>验证。也就是<code>DaoAuthenticationProvider</code></p>\n<p>也就是<code>UsernamePasswordAuthentication</code>。<br>所以在第二个方法中一般会这么写</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">supports</span><span class=\"params\">(Class&lt;?&gt; authentication)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> authentication.equals(UsernamePasswordAuthenticationToken.class);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面就是注册要<code>configure</code>方法中了<br>只要加入</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auth.authenticationProvider(<span class=\"keyword\">new</span> MyAuthenticationProvider());</span><br></pre></td></tr></table></figure>\n<p>就好了。。</p>\n","categories":["Spring和SpringBoot"],"tags":["Spring"]},{"title":"about","url":"https://blog.lovezhy.cc/about/index.html","content":"<h1 id=\"“We’ve-forgotten-who-we-are-explorers-pioneers…-not-caretakers”\"><a href=\"#“We’ve-forgotten-who-we-are-explorers-pioneers…-not-caretakers”\" class=\"headerlink\" title=\"“We’ve forgotten who we are: explorers, pioneers… not caretakers”\"></a>“We’ve forgotten who we are: explorers, pioneers… not caretakers”</h1><p>双非本科毕业</p>\n<p>小米有品 - Java开发工程师<br>坐标南京</p>\n","categories":[],"tags":[]},{"title":"categories","url":"https://blog.lovezhy.cc/categories/index.html","content":"","categories":[],"tags":[]},{"title":"tags","url":"https://blog.lovezhy.cc/tags/index.html","content":"","categories":[],"tags":[]}]